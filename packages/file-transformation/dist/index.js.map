{"version":3,"sources":["../src/index.ts","../src/hooks/useFileTransformation.ts","../src/types/index.ts","../src/utils/coordinateTransformer.ts","../src/transformers/vectorTransformer.ts","../src/utils/transformationValidator.ts"],"sourcesContent":["// Core hook\r\nexport { useFileTransformation } from './hooks/useFileTransformation';\r\nexport type { UseFileTransformationOptions, UseFileTransformationReturn } from './hooks/useFileTransformation';\r\n\r\n// Transformers\r\nexport { LayeraVectorTransformer } from './transformers/vectorTransformer';\r\n\r\n// Utilities\r\nexport { CoordinateTransformer } from './utils/coordinateTransformer';\r\nexport {\r\n  validateTransformationOptions,\r\n  getFormatCompatibility,\r\n  getFormatCategory,\r\n  validateBatchTransformation,\r\n  estimateTransformationComplexity\r\n} from './utils/transformationValidator';\r\n\r\n// Types\r\nexport type {\r\n  TransformationOptions,\r\n  SupportedFormat,\r\n  TransformationParams,\r\n  CoordinateTransform,\r\n  DatumTransform,\r\n  QualitySettings,\r\n  TransformationResult,\r\n  TransformationMetadata,\r\n  GeometryStatistics,\r\n  BoundingBox,\r\n  CoordinateInfo,\r\n  BatchTransformationOptions,\r\n  BatchTransformationResult,\r\n  TransformationProgress,\r\n  TransformationValidationResult,\r\n  TransformationValidationError,\r\n  TransformationValidationWarning,\r\n  FormatCompatibility,\r\n  TransformationConfig,\r\n  FormatConfig,\r\n  CRSDefinition,\r\n  TransformationEvent,\r\n  TransformationCallback,\r\n  VectorTransformer,\r\n  RasterTransformer,\r\n  CADTransformer,\r\n  TransformationWorkerMessage,\r\n  TransformationWorkerResponse\r\n} from './types';\r\n\r\n// Error classes\r\nexport {\r\n  TransformationError,\r\n  UnsupportedTransformationError,\r\n  CoordinateTransformationError\r\n} from './types';","import { useState, useCallback, useRef, useEffect } from 'react';\r\nimport { useNotifications } from '@layera/notifications';\r\nimport { useLayeraTranslation } from '@layera/i18n';\r\nimport {\r\n  TransformationOptions,\r\n  TransformationResult,\r\n  TransformationProgress,\r\n  TransformationError,\r\n  BatchTransformationOptions,\r\n  BatchTransformationResult,\r\n  TransformationValidationResult,\r\n  SupportedFormat\r\n} from '../types';\r\nimport { LayeraVectorTransformer } from '../transformers/vectorTransformer';\r\nimport { validateTransformationOptions, getFormatCompatibility } from '../utils/transformationValidator';\r\n\r\nexport interface UseFileTransformationOptions {\r\n  defaultOptions?: Partial<TransformationOptions>;\r\n  maxConcurrentFiles?: number;\r\n  showNotifications?: boolean;\r\n  onProgress?: (progress: TransformationProgress) => void;\r\n  onComplete?: (results: TransformationResult[]) => void;\r\n  onError?: (error: TransformationError) => void;\r\n}\r\n\r\nexport interface UseFileTransformationReturn {\r\n  // State\r\n  isTransforming: boolean;\r\n  progress: number;\r\n  results: TransformationResult[];\r\n  errors: TransformationError[];\r\n\r\n  // Actions\r\n  transformFile: (file: File, options: TransformationOptions) => Promise<TransformationResult>;\r\n  transformFiles: (files: File[], options: BatchTransformationOptions) => Promise<BatchTransformationResult>;\r\n  cancelTransformation: () => void;\r\n  clearResults: () => void;\r\n\r\n  // Validation & utilities\r\n  validateOptions: (options: TransformationOptions) => TransformationValidationResult;\r\n  getCompatibility: (sourceFormat: SupportedFormat, targetFormat: SupportedFormat) => Promise<{\r\n    compatible: boolean;\r\n    dataLossRisk: 'none' | 'low' | 'medium' | 'high';\r\n    limitations: string[];\r\n  }>;\r\n  detectFileFormat: (file: File) => Promise<{\r\n    detectedFormat: SupportedFormat | 'unknown';\r\n    confidence: number;\r\n  }>;\r\n  estimateTransformation: (file: File, options: TransformationOptions) => Promise<{\r\n    estimatedSize: number;\r\n    estimatedTime: number;\r\n    warnings: string[];\r\n  }>;\r\n}\r\n\r\nexport function useFileTransformation(\r\n  options: UseFileTransformationOptions = {}\r\n): UseFileTransformationReturn {\r\n  const { t } = useLayeraTranslation();\r\n  const { addNotification } = useNotifications();\r\n  const [isTransforming, setIsTransforming] = useState(false);\r\n  const [progress, setProgress] = useState(0);\r\n  const [results, setResults] = useState<TransformationResult[]>([]);\r\n  const [errors, setErrors] = useState<TransformationError[]>([]);\r\n\r\n  const vectorTransformerRef = useRef<LayeraVectorTransformer | null>(null);\r\n  const abortControllerRef = useRef<AbortController | null>(null);\r\n\r\n  const {\r\n    defaultOptions = {},\r\n    maxConcurrentFiles = 3,\r\n    showNotifications = true,\r\n    onProgress,\r\n    onComplete,\r\n    onError\r\n  } = options;\r\n\r\n  // Initialize transformers\r\n  useEffect(() => {\r\n    try {\r\n      vectorTransformerRef.current = new LayeraVectorTransformer();\r\n    } catch (error) {\r\n      console.error('Failed to initialize transformation engines:', error);\r\n      if (showNotifications) {\r\n        addNotification({\r\n          type: 'error',\r\n          message: t('transformation.engine.init.error')\r\n        });\r\n      }\r\n    }\r\n\r\n    return () => {\r\n      if (vectorTransformerRef.current) {\r\n        vectorTransformerRef.current.destroy();\r\n      }\r\n    };\r\n  }, [showNotifications, t]);\r\n\r\n  const reportProgress = useCallback((\r\n    fileId: string,\r\n    stage: TransformationProgress['stage'],\r\n    progress: number,\r\n    message: string,\r\n    currentOperation?: string\r\n  ) => {\r\n    const progressData: TransformationProgress = {\r\n      fileId,\r\n      stage,\r\n      progress,\r\n      message,\r\n      ...(currentOperation && { currentOperation })\r\n    };\r\n\r\n    setProgress(progress);\r\n    onProgress?.(progressData);\r\n\r\n    if (showNotifications && stage === 'complete') {\r\n      addNotification({\r\n        type: 'success',\r\n        message: t('transformation.file.success', { progress: Math.round(progress) }),\r\n        duration: 3000\r\n      });\r\n    }\r\n  }, [onProgress, showNotifications, t]);\r\n\r\n  const handleError = useCallback((error: TransformationError) => {\r\n    setErrors(prev => [...prev, error]);\r\n    onError?.(error);\r\n\r\n    if (showNotifications) {\r\n      addNotification({\r\n        type: 'error',\r\n        message: t('transformation.file.error', {\r\n          error: error.message\r\n        }),\r\n        duration: 5000,\r\n        action: { label: t('transformation.retry'), onClick: () => {} }\r\n      });\r\n    }\r\n  }, [onError, showNotifications, t]);\r\n\r\n  const transformFile = useCallback(async (file: File, transformationOptions: TransformationOptions): Promise<TransformationResult> => {\r\n    if (!vectorTransformerRef.current) {\r\n      throw new TransformationError(\r\n        'Transformation engine not initialized',\r\n        'ENGINE_NOT_INITIALIZED'\r\n      );\r\n    }\r\n\r\n    const fileId = `transform-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    const finalOptions = { ...defaultOptions, ...transformationOptions };\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      setIsTransforming(true);\r\n      reportProgress(fileId, 'parsing', 10, t('transformation.parsing.file'));\r\n\r\n      // Validate options\r\n      const validation = validateTransformationOptions(finalOptions);\r\n      if (!validation.isValid) {\r\n        throw new TransformationError(\r\n          validation.errors.map(e => e.message).join(', '),\r\n          'VALIDATION_FAILED'\r\n        );\r\n      }\r\n\r\n      // Show warnings\r\n      if (validation.warnings.length > 0 && showNotifications) {\r\n        validation.warnings.forEach(warning => {\r\n          addNotification({\r\n            type: 'warning',\r\n            message: warning.message,\r\n            duration: 4000,\r\n            ...(warning.suggestion && {\r\n              action: { label: t('transformation.suggestion'), onClick: () => {} }\r\n            })\r\n          });\r\n        });\r\n      }\r\n\r\n      // Read file content\r\n      reportProgress(fileId, 'parsing', 25, t('transformation.reading.file'));\r\n      const fileContent = await readFileContent(file, finalOptions.sourceFormat);\r\n\r\n      // Transform data\r\n      reportProgress(fileId, 'transforming', 50, t('transformation.transforming.data'));\r\n      const transformedData = await vectorTransformerRef.current.transform(fileContent, finalOptions);\r\n\r\n      // Generate output\r\n      reportProgress(fileId, 'converting', 75, t('transformation.generating.output'));\r\n      const transformedBlob = await generateOutputBlob(transformedData, finalOptions.targetFormat);\r\n\r\n      reportProgress(fileId, 'complete', 100, t('transformation.completed'));\r\n\r\n      // Calculate statistics (simplified)\r\n      const statistics = vectorTransformerRef.current.calculateStatistics(\r\n        transformedData as Parameters<typeof vectorTransformerRef.current.calculateStatistics>[0]\r\n      );\r\n\r\n      const result: TransformationResult = {\r\n        originalFile: file,\r\n        transformedBlob,\r\n        originalFormat: finalOptions.sourceFormat,\r\n        targetFormat: finalOptions.targetFormat,\r\n        originalSize: file.size,\r\n        transformedSize: transformedBlob.size,\r\n        metadata: {\r\n          processingTime: performance.now() - startTime,\r\n          transformationsApplied: [\r\n            finalOptions.sourceCRS && finalOptions.targetCRS ? 'coordinate-transform' : '',\r\n            finalOptions.transformationParams ? 'geometric-transform' : '',\r\n            finalOptions.qualitySettings?.optimizeGeometry ? 'geometry-optimization' : ''\r\n          ].filter(Boolean),\r\n          qualitySettings: finalOptions.qualitySettings || {},\r\n          ...(finalOptions.sourceCRS && finalOptions.targetCRS && {\r\n            coordinateSystemInfo: {\r\n              source: finalOptions.sourceCRS,\r\n              target: finalOptions.targetCRS,\r\n              accuracy: 0.5 // Simplified accuracy\r\n            }\r\n          }),\r\n          geometryStatistics: statistics\r\n        },\r\n        ...(finalOptions.sourceCRS && finalOptions.targetCRS && {\r\n          coordinateInfo: {\r\n            sourceCRS: finalOptions.sourceCRS,\r\n            targetCRS: finalOptions.targetCRS,\r\n            transformationAccuracy: 0.5,\r\n            transformedPoints: statistics.vertexCount\r\n          }\r\n        })\r\n      };\r\n\r\n      setResults(prev => [...prev, result]);\r\n      return result;\r\n\r\n    } catch (error) {\r\n      const transformationError = error instanceof TransformationError\r\n        ? error\r\n        : new TransformationError(\r\n            error instanceof Error ? error.message : 'Unknown transformation error',\r\n            'TRANSFORMATION_FAILED',\r\n            fileId\r\n          );\r\n\r\n      handleError(transformationError);\r\n      throw transformationError;\r\n\r\n    } finally {\r\n      setIsTransforming(false);\r\n      setProgress(0);\r\n    }\r\n  }, [defaultOptions, reportProgress, handleError, showNotifications, t]);\r\n\r\n  const transformFiles = useCallback(async (files: File[], batchOptions: BatchTransformationOptions): Promise<BatchTransformationResult> => {\r\n    const startTime = performance.now();\r\n    const batchResults: TransformationResult[] = [];\r\n    const batchErrors: TransformationError[] = [];\r\n\r\n    const {\r\n      maxConcurrentFiles: batchMaxConcurrent = maxConcurrentFiles,\r\n      stopOnError = false,\r\n      onFileComplete,\r\n      onFileError,\r\n      ...transformationOptions\r\n    } = batchOptions;\r\n\r\n    try {\r\n      setIsTransforming(true);\r\n      abortControllerRef.current = new AbortController();\r\n\r\n      // Process files in chunks\r\n      for (let i = 0; i < files.length; i += batchMaxConcurrent) {\r\n        if (abortControllerRef.current.signal.aborted) {\r\n          break;\r\n        }\r\n\r\n        const chunk = files.slice(i, i + batchMaxConcurrent);\r\n        const overallProgress = ((i + chunk.length) / files.length) * 100;\r\n        setProgress(overallProgress);\r\n\r\n        const chunkPromises = chunk.map(async (file) => {\r\n          try {\r\n            const result = await transformFile(file, transformationOptions);\r\n            batchResults.push(result);\r\n            onFileComplete?.(result);\r\n            return result;\r\n          } catch (error) {\r\n            const transformationError = error instanceof TransformationError ? error :\r\n              new TransformationError(\r\n                error instanceof Error ? error.message : 'Unknown error',\r\n                'FILE_TRANSFORMATION_FAILED'\r\n              );\r\n\r\n            batchErrors.push(transformationError);\r\n            onFileError?.(transformationError);\r\n\r\n            if (stopOnError) {\r\n              throw transformationError;\r\n            }\r\n            return null;\r\n          }\r\n        });\r\n\r\n        await Promise.all(chunkPromises);\r\n      }\r\n\r\n      const batchResult: BatchTransformationResult = {\r\n        results: batchResults,\r\n        errors: batchErrors,\r\n        totalProcessingTime: performance.now() - startTime,\r\n        successCount: batchResults.length,\r\n        errorCount: batchErrors.length\r\n      };\r\n\r\n      onComplete?.(batchResults);\r\n\r\n      if (showNotifications) {\r\n        addNotification({\r\n          type: 'success',\r\n          message: t('transformation.batch.complete', {\r\n            successful: batchResults.length,\r\n            total: files.length\r\n          }),\r\n          duration: 5000\r\n        });\r\n      }\r\n\r\n      return batchResult;\r\n\r\n    } finally {\r\n      setIsTransforming(false);\r\n      setProgress(0);\r\n      abortControllerRef.current = null;\r\n    }\r\n  }, [transformFile, maxConcurrentFiles, onComplete, showNotifications, t]);\r\n\r\n  const cancelTransformation = useCallback(() => {\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n      setIsTransforming(false);\r\n      setProgress(0);\r\n\r\n      if (showNotifications) {\r\n        addNotification({\r\n          type: 'info',\r\n          message: t('transformation.cancelled')\r\n        });\r\n      }\r\n    }\r\n  }, [showNotifications, t]);\r\n\r\n  const clearResults = useCallback(() => {\r\n    setResults([]);\r\n    setErrors([]);\r\n    setProgress(0);\r\n  }, []);\r\n\r\n  const validateOptions = useCallback((options: TransformationOptions): TransformationValidationResult => {\r\n    return validateTransformationOptions(options);\r\n  }, []);\r\n\r\n  const getCompatibility = useCallback(async (\r\n    sourceFormat: SupportedFormat,\r\n    targetFormat: SupportedFormat\r\n  ) => {\r\n    const formatCompatibility = getFormatCompatibility(sourceFormat, targetFormat);\r\n    return {\r\n      compatible: formatCompatibility.sourceSupported && formatCompatibility.targetSupported,\r\n      dataLossRisk: formatCompatibility.dataLossRisk,\r\n      limitations: formatCompatibility.limitations\r\n    };\r\n  }, []);\r\n\r\n  const detectFileFormat = useCallback(async (file: File): Promise<{\r\n    detectedFormat: SupportedFormat | 'unknown';\r\n    confidence: number;\r\n  }> => {\r\n    const extension = file.name.split('.').pop()?.toLowerCase();\r\n    const mimeType = file.type;\r\n\r\n    // Simple format detection βασισμένο σε extension και MIME type\r\n    const formatMap: Record<string, SupportedFormat> = {\r\n      'json': 'geojson',\r\n      'geojson': 'geojson',\r\n      'kml': 'kml',\r\n      'gpx': 'gpx',\r\n      'svg': 'svg',\r\n      'dxf': 'dxf',\r\n      'dwg': 'dwg',\r\n      'tiff': 'tiff',\r\n      'tif': 'tiff',\r\n      'png': 'png',\r\n      'jpg': 'jpeg',\r\n      'jpeg': 'jpeg',\r\n      'webp': 'webp',\r\n      'pdf': 'pdf'\r\n    };\r\n\r\n    const detectedFormat = extension ? formatMap[extension] : undefined;\r\n\r\n    if (detectedFormat) {\r\n      return {\r\n        detectedFormat,\r\n        confidence: mimeType.includes(extension || '') ? 0.9 : 0.7\r\n      };\r\n    }\r\n\r\n    return {\r\n      detectedFormat: 'unknown',\r\n      confidence: 0\r\n    };\r\n  }, []);\r\n\r\n  const estimateTransformation = useCallback(async (\r\n    file: File,\r\n    options: TransformationOptions\r\n  ): Promise<{\r\n    estimatedSize: number;\r\n    estimatedTime: number;\r\n    warnings: string[];\r\n  }> => {\r\n    const warnings: string[] = [];\r\n\r\n    // Simple estimation logic\r\n    let sizeMultiplier = 1.0;\r\n    let timePerMB = 2000; // 2 seconds per MB base time\r\n\r\n    // Format-specific adjustments\r\n    if (options.sourceFormat === 'dxf' && options.targetFormat === 'geojson') {\r\n      sizeMultiplier = 0.8; // GeoJSON usually smaller than DXF\r\n      timePerMB = 3000; // DXF parsing is slower\r\n    } else if (options.sourceFormat === 'svg' && options.targetFormat === 'geojson') {\r\n      sizeMultiplier = 1.2; // GeoJSON might be larger\r\n      timePerMB = 1500; // SVG parsing is faster\r\n    }\r\n\r\n    // Coordinate transformation adds time\r\n    if (options.sourceCRS && options.targetCRS) {\r\n      timePerMB *= 1.5;\r\n      warnings.push(t('transformation.warning.coordinate.transform.time'));\r\n    }\r\n\r\n    // Quality optimization adds time but reduces size\r\n    if (options.qualitySettings?.optimizeGeometry) {\r\n      timePerMB *= 1.3;\r\n      sizeMultiplier *= 0.9;\r\n      warnings.push(t('transformation.warning.optimization.time'));\r\n    }\r\n\r\n    const fileSizeMB = file.size / (1024 * 1024);\r\n    const estimatedSize = Math.round(file.size * sizeMultiplier);\r\n    const estimatedTime = Math.round(fileSizeMB * timePerMB);\r\n\r\n    return {\r\n      estimatedSize,\r\n      estimatedTime,\r\n      warnings\r\n    };\r\n  }, [t]);\r\n\r\n  return {\r\n    // State\r\n    isTransforming,\r\n    progress,\r\n    results,\r\n    errors,\r\n\r\n    // Actions\r\n    transformFile,\r\n    transformFiles,\r\n    cancelTransformation,\r\n    clearResults,\r\n\r\n    // Validation & utilities\r\n    validateOptions,\r\n    getCompatibility,\r\n    detectFileFormat,\r\n    estimateTransformation\r\n  };\r\n}\r\n\r\n// Helper functions\r\nasync function readFileContent(file: File, format: SupportedFormat): Promise<unknown> {\r\n  if (format === 'geojson' || format === 'kml' || format === 'gpx' || format === 'svg') {\r\n    return file.text();\r\n  } else {\r\n    return file.arrayBuffer();\r\n  }\r\n}\r\n\r\nasync function generateOutputBlob(data: unknown, format: SupportedFormat): Promise<Blob> {\r\n  if (typeof data === 'string') {\r\n    return new Blob([data], { type: getFormatMimeType(format) });\r\n  } else if (data instanceof ArrayBuffer) {\r\n    return new Blob([data], { type: getFormatMimeType(format) });\r\n  } else {\r\n    const jsonString = JSON.stringify(data, null, 2);\r\n    return new Blob([jsonString], { type: getFormatMimeType(format) });\r\n  }\r\n}\r\n\r\nfunction getFormatMimeType(format: SupportedFormat): string {\r\n  const mimeTypes: Record<SupportedFormat, string> = {\r\n    'geojson': 'application/geo+json',\r\n    'kml': 'application/vnd.google-earth.kml+xml',\r\n    'gpx': 'application/gpx+xml',\r\n    'svg': 'image/svg+xml',\r\n    'dxf': 'application/dxf',\r\n    'dwg': 'application/dwg',\r\n    'shapefile': 'application/x-shapefile',\r\n    'tiff': 'image/tiff',\r\n    'geotiff': 'image/tiff',\r\n    'png': 'image/png',\r\n    'jpeg': 'image/jpeg',\r\n    'webp': 'image/webp',\r\n    'pdf': 'application/pdf',\r\n    'autocad': 'application/dwg',\r\n    'microstation': 'application/dgn'\r\n  };\r\n\r\n  return mimeTypes[format] || 'application/octet-stream';\r\n}","// Core transformation types\r\nexport interface TransformationOptions {\r\n  sourceFormat: SupportedFormat;\r\n  targetFormat: SupportedFormat;\r\n  sourceCRS?: string; // Coordinate Reference System\r\n  targetCRS?: string;\r\n  transformationParams?: TransformationParams;\r\n  qualitySettings?: QualitySettings;\r\n  customOptions?: Record<string, unknown>;\r\n}\r\n\r\nexport type SupportedFormat =\r\n  // Vector formats\r\n  | 'dxf' | 'dwg' | 'svg' | 'geojson' | 'kml' | 'gpx' | 'shapefile'\r\n  // Raster formats\r\n  | 'tiff' | 'geotiff' | 'png' | 'jpeg' | 'webp'\r\n  // CAD formats\r\n  | 'autocad' | 'microstation'\r\n  // Document formats\r\n  | 'pdf';\r\n\r\nexport interface TransformationParams {\r\n  // Coordinate transformation\r\n  coordinateTransform?: CoordinateTransform;\r\n\r\n  // Geometric transformations\r\n  scale?: { x: number; y: number; z?: number };\r\n  rotation?: number; // degrees\r\n  translation?: { x: number; y: number; z?: number };\r\n\r\n  // Unit conversion\r\n  sourceUnits?: 'meters' | 'feet' | 'inches' | 'millimeters' | 'centimeters';\r\n  targetUnits?: 'meters' | 'feet' | 'inches' | 'millimeters' | 'centimeters';\r\n\r\n  // Precision settings\r\n  precision?: number;\r\n  tolerance?: number;\r\n}\r\n\r\nexport interface CoordinateTransform {\r\n  sourceEPSG: string;\r\n  targetEPSG: string;\r\n  transformationMethod?: 'proj4' | 'custom';\r\n  datumTransform?: DatumTransform;\r\n}\r\n\r\nexport interface DatumTransform {\r\n  name: string;\r\n  parameters: number[];\r\n  accuracy: number;\r\n}\r\n\r\nexport interface QualitySettings {\r\n  preserveMetadata?: boolean;\r\n  optimizeGeometry?: boolean;\r\n  simplificationTolerance?: number;\r\n  compressionLevel?: number;\r\n  colorDepth?: 8 | 16 | 24 | 32;\r\n}\r\n\r\nexport interface TransformationResult {\r\n  originalFile: File;\r\n  transformedBlob: Blob;\r\n  originalFormat: SupportedFormat;\r\n  targetFormat: SupportedFormat;\r\n  originalSize: number;\r\n  transformedSize: number;\r\n  metadata: TransformationMetadata;\r\n  coordinateInfo?: CoordinateInfo;\r\n}\r\n\r\nexport interface TransformationMetadata {\r\n  processingTime: number;\r\n  transformationsApplied: string[];\r\n  qualitySettings: QualitySettings;\r\n  coordinateSystemInfo?: {\r\n    source: string;\r\n    target: string;\r\n    accuracy: number;\r\n  };\r\n  geometryStatistics?: GeometryStatistics;\r\n}\r\n\r\nexport interface GeometryStatistics {\r\n  entityCount: number;\r\n  vertexCount: number;\r\n  boundingBox: BoundingBox;\r\n  layerCount?: number;\r\n  complexityScore: number;\r\n}\r\n\r\nexport interface BoundingBox {\r\n  minX: number;\r\n  minY: number;\r\n  maxX: number;\r\n  maxY: number;\r\n  minZ?: number;\r\n  maxZ?: number;\r\n}\r\n\r\nexport interface CoordinateInfo {\r\n  sourceCRS: string;\r\n  targetCRS: string;\r\n  transformationAccuracy: number;\r\n  transformedPoints: number;\r\n}\r\n\r\n// Batch transformation\r\nexport interface BatchTransformationOptions extends TransformationOptions {\r\n  maxConcurrentFiles?: number;\r\n  stopOnError?: boolean;\r\n  onFileComplete?: (result: TransformationResult) => void;\r\n  onFileError?: (error: TransformationError) => void;\r\n}\r\n\r\nexport interface BatchTransformationResult {\r\n  results: TransformationResult[];\r\n  errors: TransformationError[];\r\n  totalProcessingTime: number;\r\n  successCount: number;\r\n  errorCount: number;\r\n}\r\n\r\n// Progress tracking\r\nexport interface TransformationProgress {\r\n  fileId: string;\r\n  stage: 'parsing' | 'transforming' | 'converting' | 'optimizing' | 'complete';\r\n  progress: number;\r\n  message: string;\r\n  estimatedTimeRemaining?: number;\r\n  currentOperation?: string;\r\n}\r\n\r\n// Validation\r\nexport interface TransformationValidationResult {\r\n  isValid: boolean;\r\n  errors: TransformationValidationError[];\r\n  warnings: TransformationValidationWarning[];\r\n  compatibility: FormatCompatibility;\r\n}\r\n\r\nexport interface TransformationValidationError {\r\n  code: string;\r\n  message: string;\r\n  severity: 'error' | 'warning';\r\n  field?: string;\r\n}\r\n\r\nexport interface TransformationValidationWarning {\r\n  code: string;\r\n  message: string;\r\n  suggestion?: string;\r\n  impact: 'high' | 'medium' | 'low';\r\n}\r\n\r\nexport interface FormatCompatibility {\r\n  sourceSupported: boolean;\r\n  targetSupported: boolean;\r\n  dataLossRisk: 'none' | 'low' | 'medium' | 'high';\r\n  recommendedAlternatives?: SupportedFormat[];\r\n  limitations: string[];\r\n}\r\n\r\n// Error handling\r\nexport class TransformationError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public code: string,\r\n    public fileId?: string,\r\n    public stage?: TransformationProgress['stage'],\r\n    public originalError?: Error\r\n  ) {\r\n    super(message);\r\n    this.name = 'TransformationError';\r\n  }\r\n}\r\n\r\nexport class UnsupportedTransformationError extends TransformationError {\r\n  constructor(sourceFormat: string, targetFormat: string) {\r\n    super(\r\n      `Transformation from ${sourceFormat} to ${targetFormat} is not supported`,\r\n      'UNSUPPORTED_TRANSFORMATION'\r\n    );\r\n  }\r\n}\r\n\r\nexport class CoordinateTransformationError extends TransformationError {\r\n  constructor(sourceCRS: string, targetCRS: string, reason: string) {\r\n    super(\r\n      `Coordinate transformation failed from ${sourceCRS} to ${targetCRS}: ${reason}`,\r\n      'COORDINATE_TRANSFORMATION_FAILED'\r\n    );\r\n  }\r\n}\r\n\r\n// Configuration\r\nexport interface TransformationConfig {\r\n  defaultOptions: TransformationOptions;\r\n  supportedFormats: Record<SupportedFormat, FormatConfig>;\r\n  coordinateSystems: Record<string, CRSDefinition>;\r\n  maxFileSize: number;\r\n  maxConcurrentTransformations: number;\r\n  tempDirectory?: string;\r\n}\r\n\r\nexport interface FormatConfig {\r\n  extension: string;\r\n  mimeType: string;\r\n  category: 'vector' | 'raster' | 'cad' | 'document';\r\n  supportedFeatures: string[];\r\n  limitations: string[];\r\n  transformationCapabilities: {\r\n    canBeSource: boolean;\r\n    canBeTarget: boolean;\r\n    supportedTransformations: SupportedFormat[];\r\n  };\r\n}\r\n\r\nexport interface CRSDefinition {\r\n  epsg: string;\r\n  name: string;\r\n  proj4Definition: string;\r\n  units: string;\r\n  authority: string;\r\n  bbox?: BoundingBox;\r\n}\r\n\r\n// Events and callbacks\r\nexport interface TransformationEvent {\r\n  type: 'transformation:started' | 'transformation:progress' | 'transformation:completed' | 'transformation:failed';\r\n  fileId: string;\r\n  data?: unknown;\r\n}\r\n\r\nexport type TransformationCallback = (event: TransformationEvent) => void;\r\n\r\n// Specific transformer interfaces\r\nexport interface VectorTransformer {\r\n  name: string;\r\n  supportedFormats: SupportedFormat[];\r\n  transform(\r\n    data: unknown,\r\n    options: TransformationOptions\r\n  ): Promise<unknown>;\r\n}\r\n\r\nexport interface RasterTransformer {\r\n  name: string;\r\n  supportedFormats: SupportedFormat[];\r\n  transform(\r\n    imageData: ImageData | ArrayBuffer,\r\n    options: TransformationOptions\r\n  ): Promise<ArrayBuffer>;\r\n}\r\n\r\nexport interface CADTransformer {\r\n  name: string;\r\n  supportedFormats: SupportedFormat[];\r\n  transform(\r\n    cadData: unknown,\r\n    options: TransformationOptions\r\n  ): Promise<unknown>;\r\n}\r\n\r\n// Worker types (για background processing)\r\nexport interface TransformationWorkerMessage {\r\n  id: string;\r\n  type: 'transform' | 'batch-transform' | 'cancel';\r\n  payload: {\r\n    file?: ArrayBuffer;\r\n    options?: TransformationOptions;\r\n    files?: ArrayBuffer[];\r\n    batchOptions?: BatchTransformationOptions;\r\n  };\r\n}\r\n\r\nexport interface TransformationWorkerResponse {\r\n  id: string;\r\n  type: 'success' | 'error' | 'progress';\r\n  payload: {\r\n    result?: TransformationResult;\r\n    error?: string;\r\n    progress?: TransformationProgress;\r\n  };\r\n}","import proj4 from 'proj4';\r\nimport {\r\n  CoordinateTransform,\r\n  CoordinateTransformationError,\r\n  BoundingBox\r\n} from '../types';\r\n\r\n// Common Greek coordinate systems που χρησιμοποιούνται στο Layera\r\nconst GREEK_CRS_DEFINITIONS = {\r\n  // ΕΓΣΑ87 - Ελληνικό Γεωδαιτικό Σύστημα Αναφοράς 1987\r\n  'EPSG:2100': '+proj=tmerc +lat_0=0 +lon_0=24 +k=0.9996 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=-199.87,74.79,246.62,0,0,0,0 +units=m +no_defs',\r\n\r\n  // WGS84 - World Geodetic System 1984 (GPS)\r\n  'EPSG:4326': '+proj=longlat +datum=WGS84 +no_defs',\r\n\r\n  // Web Mercator (Google Maps, OpenStreetMap)\r\n  'EPSG:3857': '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs',\r\n\r\n  // Greek Grid (παλιό σύστημα)\r\n  'EPSG:2154': '+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',\r\n\r\n  // UTM Zone 34N (για βόρεια Ελλάδα)\r\n  'EPSG:32634': '+proj=utm +zone=34 +datum=WGS84 +units=m +no_defs',\r\n\r\n  // UTM Zone 35N (για ανατολική Ελλάδα)\r\n  'EPSG:32635': '+proj=utm +zone=35 +datum=WGS84 +units=m +no_defs'\r\n} as const;\r\n\r\n/**\r\n * Enhanced coordinate transformation utility\r\n * Βασισμένο σε patterns από OLD_geo-canvas για χειρισμό GIS data\r\n */\r\nexport class CoordinateTransformer {\r\n  private projCache: Map<string, proj4.Converter> = new Map();\r\n  private initializationPromise: Promise<void>;\r\n\r\n  constructor() {\r\n    this.initializationPromise = this.initializeProjections();\r\n  }\r\n\r\n  /**\r\n   * Initializes commonly used projections\r\n   */\r\n  private async initializeProjections(): Promise<void> {\r\n    try {\r\n      // Register Greek coordinate systems\r\n      Object.entries(GREEK_CRS_DEFINITIONS).forEach(([epsg, definition]) => {\r\n        proj4.defs(epsg, definition);\r\n      });\r\n\r\n      // Precompile common transformations\r\n      const commonTransformations = [\r\n        ['EPSG:4326', 'EPSG:2100'], // WGS84 to EGSA87\r\n        ['EPSG:2100', 'EPSG:4326'], // EGSA87 to WGS84\r\n        ['EPSG:4326', 'EPSG:3857'], // WGS84 to Web Mercator\r\n        ['EPSG:3857', 'EPSG:4326'], // Web Mercator to WGS84\r\n        ['EPSG:2100', 'EPSG:3857']  // EGSA87 to Web Mercator\r\n      ];\r\n\r\n      commonTransformations.forEach(([source, target]) => {\r\n        const key = `${source}->${target}`;\r\n        if (source && target) {\r\n          try {\r\n            const converter = proj4(source, target);\r\n            this.projCache.set(key, converter);\r\n          } catch (conversionError) {\r\n            console.warn(`Failed to initialize transformation ${key}:`, conversionError);\r\n          }\r\n        }\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Failed to initialize coordinate projections:', error);\r\n      throw new CoordinateTransformationError(\r\n        'unknown',\r\n        'unknown',\r\n        `Initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transforms a single coordinate point\r\n   */\r\n  async transformPoint(\r\n    x: number,\r\n    y: number,\r\n    transform: CoordinateTransform,\r\n    z?: number\r\n  ): Promise<{ x: number; y: number; z?: number }> {\r\n    await this.initializationPromise;\r\n\r\n    try {\r\n      const converter = this.getConverter(transform.sourceEPSG, transform.targetEPSG);\r\n      const input = z !== undefined ? [x, y, z] : [x, y];\r\n      const result = converter.forward(input);\r\n\r\n      if (result[0] === undefined || result[1] === undefined) {\r\n        throw new CoordinateTransformationError(\r\n          transform.sourceEPSG,\r\n          transform.targetEPSG,\r\n          'Invalid coordinate transformation result'\r\n        );\r\n      }\r\n\r\n      return {\r\n        x: result[0],\r\n        y: result[1],\r\n        ...(z !== undefined && result[2] !== undefined && { z: result[2] })\r\n      };\r\n\r\n    } catch (error) {\r\n      throw new CoordinateTransformationError(\r\n        transform.sourceEPSG,\r\n        transform.targetEPSG,\r\n        error instanceof Error ? error.message : 'Point transformation failed'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transforms an array of coordinate points\r\n   */\r\n  async transformPoints(\r\n    points: Array<{ x: number; y: number; z?: number }>,\r\n    transform: CoordinateTransform\r\n  ): Promise<Array<{ x: number; y: number; z?: number }>> {\r\n    await this.initializationPromise;\r\n\r\n    const results: Array<{ x: number; y: number; z?: number }> = [];\r\n\r\n    try {\r\n      const converter = this.getConverter(transform.sourceEPSG, transform.targetEPSG);\r\n\r\n      for (const point of points) {\r\n        const input = point.z !== undefined ? [point.x, point.y, point.z] : [point.x, point.y];\r\n        const result = converter.forward(input);\r\n\r\n        if (result[0] === undefined || result[1] === undefined) {\r\n          throw new CoordinateTransformationError(\r\n            transform.sourceEPSG,\r\n            transform.targetEPSG,\r\n            `Invalid coordinate transformation result for point ${JSON.stringify(point)}`\r\n          );\r\n        }\r\n\r\n        results.push({\r\n          x: result[0],\r\n          y: result[1],\r\n          ...(point.z !== undefined && result[2] !== undefined && { z: result[2] })\r\n        });\r\n      }\r\n\r\n      return results;\r\n\r\n    } catch (error) {\r\n      throw new CoordinateTransformationError(\r\n        transform.sourceEPSG,\r\n        transform.targetEPSG,\r\n        `Batch transformation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transforms a bounding box\r\n   */\r\n  async transformBoundingBox(\r\n    bbox: BoundingBox,\r\n    transform: CoordinateTransform\r\n  ): Promise<BoundingBox> {\r\n    await this.initializationPromise;\r\n\r\n    try {\r\n      // Transform corner points\r\n      const corners = [\r\n        { x: bbox.minX, y: bbox.minY },\r\n        { x: bbox.maxX, y: bbox.minY },\r\n        { x: bbox.maxX, y: bbox.maxY },\r\n        { x: bbox.minX, y: bbox.maxY }\r\n      ];\r\n\r\n      const transformedCorners = await this.transformPoints(corners, transform);\r\n\r\n      // Calculate new bounding box\r\n      const xs = transformedCorners.map(p => p.x);\r\n      const ys = transformedCorners.map(p => p.y);\r\n\r\n      const result: BoundingBox = {\r\n        minX: Math.min(...xs),\r\n        minY: Math.min(...ys),\r\n        maxX: Math.max(...xs),\r\n        maxY: Math.max(...ys)\r\n      };\r\n\r\n      // Handle Z coordinates if present\r\n      if (bbox.minZ !== undefined && bbox.maxZ !== undefined) {\r\n        const zCorners = [\r\n          { x: bbox.minX, y: bbox.minY, z: bbox.minZ },\r\n          { x: bbox.maxX, y: bbox.maxY, z: bbox.maxZ }\r\n        ];\r\n\r\n        const transformedZCorners = await this.transformPoints(zCorners, transform);\r\n        const zs = transformedZCorners.map(p => p.z!).filter(z => z !== undefined);\r\n\r\n        if (zs.length > 0) {\r\n          result.minZ = Math.min(...zs);\r\n          result.maxZ = Math.max(...zs);\r\n        }\r\n      }\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      throw new CoordinateTransformationError(\r\n        transform.sourceEPSG,\r\n        transform.targetEPSG,\r\n        `Bounding box transformation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or creates a proj4 converter for the given transformation\r\n   */\r\n  private getConverter(sourceEPSG: string, targetEPSG: string): proj4.Converter {\r\n    const key = `${sourceEPSG}->${targetEPSG}`;\r\n\r\n    if (this.projCache.has(key)) {\r\n      return this.projCache.get(key)!;\r\n    }\r\n\r\n    try {\r\n      const converter = proj4(sourceEPSG, targetEPSG);\r\n      this.projCache.set(key, converter);\r\n      return converter;\r\n\r\n    } catch (error) {\r\n      throw new CoordinateTransformationError(\r\n        sourceEPSG,\r\n        targetEPSG,\r\n        `Failed to create projection converter: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates coordinate transformation parameters\r\n   */\r\n  async validateTransformation(transform: CoordinateTransform): Promise<{\r\n    isValid: boolean;\r\n    error?: string;\r\n    accuracy?: number;\r\n  }> {\r\n    await this.initializationPromise;\r\n\r\n    try {\r\n      // Test transformation με γνωστό σημείο\r\n      const testPoint = { x: 24.0, y: 38.0 }; // Κέντρο Αθήνας περίπου\r\n\r\n      if (transform.sourceEPSG === 'EPSG:4326') {\r\n        await this.transformPoint(testPoint.x, testPoint.y, transform);\r\n      } else {\r\n        // Use a test point σε meters για projected systems\r\n        await this.transformPoint(500000, 4200000, transform);\r\n      }\r\n\r\n      return {\r\n        isValid: true,\r\n        accuracy: this.getTransformationAccuracy(transform.sourceEPSG, transform.targetEPSG)\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        isValid: false,\r\n        error: error instanceof Error ? error.message : 'Unknown validation error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the estimated accuracy for a coordinate transformation\r\n   */\r\n  private getTransformationAccuracy(sourceEPSG: string, targetEPSG: string): number {\r\n    // Simplified accuracy estimation βασισμένο σε γνωστές transformations\r\n    const accuracyMatrix: Record<string, Record<string, number>> = {\r\n      'EPSG:4326': {\r\n        'EPSG:2100': 0.5,  // WGS84 to EGSA87: ~0.5m accuracy\r\n        'EPSG:3857': 0.1,  // WGS84 to Web Mercator: ~0.1m accuracy\r\n        'EPSG:32634': 0.3, // WGS84 to UTM34N: ~0.3m accuracy\r\n        'EPSG:32635': 0.3  // WGS84 to UTM35N: ~0.3m accuracy\r\n      },\r\n      'EPSG:2100': {\r\n        'EPSG:4326': 0.5,  // EGSA87 to WGS84: ~0.5m accuracy\r\n        'EPSG:3857': 0.6   // EGSA87 to Web Mercator: ~0.6m accuracy\r\n      }\r\n    };\r\n\r\n    return accuracyMatrix[sourceEPSG]?.[targetEPSG] || 1.0; // Default 1m accuracy\r\n  }\r\n\r\n  /**\r\n   * Gets information about a coordinate system\r\n   */\r\n  getCoordinateSystemInfo(epsg: string): {\r\n    name: string;\r\n    units: string;\r\n    type: 'geographic' | 'projected';\r\n    description: string;\r\n  } {\r\n    const info: Record<string, {\r\n      name: string;\r\n      units: string;\r\n      type: 'geographic' | 'projected';\r\n      description: string;\r\n    }> = {\r\n      'EPSG:4326': {\r\n        name: 'WGS84',\r\n        units: 'degrees',\r\n        type: 'geographic',\r\n        description: 'World Geodetic System 1984 - GPS coordinates'\r\n      },\r\n      'EPSG:2100': {\r\n        name: 'ΕΓΣΑ87',\r\n        units: 'meters',\r\n        type: 'projected',\r\n        description: 'Ελληνικό Γεωδαιτικό Σύστημα Αναφοράς 1987'\r\n      },\r\n      'EPSG:3857': {\r\n        name: 'Web Mercator',\r\n        units: 'meters',\r\n        type: 'projected',\r\n        description: 'Web Mercator - Google Maps, OpenStreetMap'\r\n      },\r\n      'EPSG:32634': {\r\n        name: 'UTM Zone 34N',\r\n        units: 'meters',\r\n        type: 'projected',\r\n        description: 'Universal Transverse Mercator Zone 34 North'\r\n      }\r\n    };\r\n\r\n    return info[epsg] || {\r\n      name: epsg,\r\n      units: 'unknown',\r\n      type: 'geographic',\r\n      description: 'Unknown coordinate system'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detects the likely coordinate system από sample coordinates\r\n   */\r\n  detectCoordinateSystem(\r\n    samplePoints: Array<{ x: number; y: number }>\r\n  ): {\r\n    likelyEPSG: string;\r\n    confidence: number;\r\n    reasoning: string;\r\n  } {\r\n    if (samplePoints.length === 0) {\r\n      return {\r\n        likelyEPSG: 'EPSG:4326',\r\n        confidence: 0,\r\n        reasoning: 'No sample points provided'\r\n      };\r\n    }\r\n\r\n    const xs = samplePoints.map(p => p.x);\r\n    const ys = samplePoints.map(p => p.y);\r\n\r\n    const minX = Math.min(...xs);\r\n    const maxX = Math.max(...xs);\r\n    const minY = Math.min(...ys);\r\n    const maxY = Math.max(...ys);\r\n\r\n    // Check for geographic coordinates (lat/lon)\r\n    if (minX >= -180 && maxX <= 180 && minY >= -90 && maxY <= 90) {\r\n      // Check if coordinates are in Greece area\r\n      if (minX >= 19 && maxX <= 30 && minY >= 34 && maxY <= 42) {\r\n        return {\r\n          likelyEPSG: 'EPSG:4326',\r\n          confidence: 0.9,\r\n          reasoning: 'Coordinates within Greece geographic bounds (WGS84)'\r\n        };\r\n      }\r\n\r\n      return {\r\n        likelyEPSG: 'EPSG:4326',\r\n        confidence: 0.8,\r\n        reasoning: 'Coordinates within geographic bounds (lat/lon)'\r\n      };\r\n    }\r\n\r\n    // Check for EGSA87 (Greek Grid)\r\n    if (minX >= 100000 && maxX <= 900000 && minY >= 3800000 && maxY <= 4700000) {\r\n      return {\r\n        likelyEPSG: 'EPSG:2100',\r\n        confidence: 0.9,\r\n        reasoning: 'Coordinates within EGSA87 bounds (Greek Grid)'\r\n      };\r\n    }\r\n\r\n    // Check for Web Mercator\r\n    if (Math.abs(minX) <= 20037508 && Math.abs(maxX) <= 20037508 &&\r\n        Math.abs(minY) <= 20037508 && Math.abs(maxY) <= 20037508) {\r\n      return {\r\n        likelyEPSG: 'EPSG:3857',\r\n        confidence: 0.7,\r\n        reasoning: 'Coordinates within Web Mercator bounds'\r\n      };\r\n    }\r\n\r\n    // Default fallback\r\n    return {\r\n      likelyEPSG: 'EPSG:4326',\r\n      confidence: 0.3,\r\n      reasoning: 'Could not determine coordinate system, defaulting to WGS84'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  destroy(): void {\r\n    this.projCache.clear();\r\n  }\r\n}","import {\r\n  VectorTransformer,\r\n  TransformationOptions,\r\n  SupportedFormat,\r\n  TransformationError,\r\n  GeometryStatistics\r\n} from '../types';\r\nimport { CoordinateTransformer } from '../utils/coordinateTransformer';\r\n\r\n/**\r\n * Enhanced vector data transformer\r\n * Βασισμένο σε patterns από OLD_geo-canvas για GeoJSON και DXF processing\r\n */\r\nexport class LayeraVectorTransformer implements VectorTransformer {\r\n  name = 'LayeraVectorTransformer';\r\n  supportedFormats: SupportedFormat[] = ['geojson', 'kml', 'gpx', 'svg', 'dxf'];\r\n\r\n  private coordinateTransformer: CoordinateTransformer;\r\n\r\n  constructor() {\r\n    this.coordinateTransformer = new CoordinateTransformer();\r\n  }\r\n\r\n  /**\r\n   * Main transformation method\r\n   */\r\n  async transform(\r\n    data: unknown,\r\n    options: TransformationOptions\r\n  ): Promise<unknown> {\r\n    try {\r\n      // Validate input data\r\n      this.validateInputData(data, options.sourceFormat);\r\n\r\n      // Parse source format\r\n      const parsedData = await this.parseSourceFormat(data, options.sourceFormat);\r\n\r\n      // Apply transformations\r\n      const transformedData = await this.applyTransformations(parsedData, options);\r\n\r\n      // Convert to target format\r\n      const result = await this.convertToTargetFormat(transformedData, options.targetFormat);\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      throw new TransformationError(\r\n        `Vector transformation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        'VECTOR_TRANSFORMATION_FAILED',\r\n        undefined,\r\n        'transforming',\r\n        error instanceof Error ? error : undefined\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates input data\r\n   */\r\n  private validateInputData(data: unknown, format: SupportedFormat): void {\r\n    if (!data) {\r\n      throw new TransformationError(\r\n        'No input data provided',\r\n        'NO_INPUT_DATA'\r\n      );\r\n    }\r\n\r\n    if (!this.supportedFormats.includes(format)) {\r\n      throw new TransformationError(\r\n        `Unsupported source format: ${format}`,\r\n        'UNSUPPORTED_SOURCE_FORMAT'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses source format data\r\n   */\r\n  private async parseSourceFormat(\r\n    data: unknown,\r\n    format: SupportedFormat\r\n  ): Promise<VectorData> {\r\n    switch (format) {\r\n      case 'geojson':\r\n        return this.parseGeoJSON(data);\r\n      case 'kml':\r\n        return this.parseKML(data);\r\n      case 'gpx':\r\n        return this.parseGPX(data);\r\n      case 'svg':\r\n        return this.parseSVG(data);\r\n      case 'dxf':\r\n        return this.parseDXF(data);\r\n      default:\r\n        throw new TransformationError(\r\n          `Parser not implemented for format: ${format}`,\r\n          'PARSER_NOT_IMPLEMENTED'\r\n        );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies coordinate and geometric transformations\r\n   */\r\n  private async applyTransformations(\r\n    vectorData: VectorData,\r\n    options: TransformationOptions\r\n  ): Promise<VectorData> {\r\n    let transformedData = { ...vectorData };\r\n\r\n    // Apply coordinate transformation\r\n    if (options.sourceCRS && options.targetCRS) {\r\n      transformedData = await this.applyCoordinateTransformation(\r\n        transformedData,\r\n        options.sourceCRS,\r\n        options.targetCRS\r\n      );\r\n    }\r\n\r\n    // Apply geometric transformations\r\n    if (options.transformationParams) {\r\n      transformedData = this.applyGeometricTransformations(\r\n        transformedData,\r\n        options.transformationParams\r\n      );\r\n    }\r\n\r\n    // Apply quality optimizations\r\n    if (options.qualitySettings?.optimizeGeometry) {\r\n      transformedData = this.optimizeGeometry(\r\n        transformedData,\r\n        options.qualitySettings.simplificationTolerance || 0.1\r\n      );\r\n    }\r\n\r\n    return transformedData;\r\n  }\r\n\r\n  /**\r\n   * Converts transformed data to target format\r\n   */\r\n  private async convertToTargetFormat(\r\n    vectorData: VectorData,\r\n    format: SupportedFormat\r\n  ): Promise<unknown> {\r\n    switch (format) {\r\n      case 'geojson':\r\n        return this.toGeoJSON(vectorData);\r\n      case 'kml':\r\n        return this.toKML(vectorData);\r\n      case 'gpx':\r\n        return this.toGPX(vectorData);\r\n      case 'svg':\r\n        return this.toSVG(vectorData);\r\n      case 'dxf':\r\n        return this.toDXF(vectorData);\r\n      default:\r\n        throw new TransformationError(\r\n          `Converter not implemented for format: ${format}`,\r\n          'CONVERTER_NOT_IMPLEMENTED'\r\n        );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies coordinate transformation to all geometries\r\n   */\r\n  private async applyCoordinateTransformation(\r\n    vectorData: VectorData,\r\n    sourceCRS: string,\r\n    targetCRS: string\r\n  ): Promise<VectorData> {\r\n    const transformedFeatures: VectorFeature[] = [];\r\n\r\n    for (const feature of vectorData.features) {\r\n      const transformedGeometry = await this.transformGeometry(\r\n        feature.geometry,\r\n        sourceCRS,\r\n        targetCRS\r\n      );\r\n\r\n      transformedFeatures.push({\r\n        ...feature,\r\n        geometry: transformedGeometry\r\n      });\r\n    }\r\n\r\n    return {\r\n      ...vectorData,\r\n      features: transformedFeatures,\r\n      crs: targetCRS\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Transforms geometry coordinates\r\n   */\r\n  private async transformGeometry(\r\n    geometry: VectorGeometry,\r\n    sourceCRS: string,\r\n    targetCRS: string\r\n  ): Promise<VectorGeometry> {\r\n    const transform = {\r\n      sourceEPSG: sourceCRS,\r\n      targetEPSG: targetCRS\r\n    };\r\n\r\n    switch (geometry.type) {\r\n      case 'Point':\r\n        if (!Array.isArray(geometry.coordinates) || geometry.coordinates.length < 2) {\r\n          throw new TransformationError('Invalid Point coordinates', 'INVALID_GEOMETRY');\r\n        }\r\n        const [x, y, z] = geometry.coordinates as number[];\r\n        const point = await this.coordinateTransformer.transformPoint(\r\n          x ?? 0,\r\n          y ?? 0,\r\n          transform,\r\n          z\r\n        );\r\n        return {\r\n          type: 'Point',\r\n          coordinates: point.z !== undefined ? [point.x, point.y, point.z] : [point.x, point.y]\r\n        };\r\n\r\n      case 'LineString':\r\n        if (!Array.isArray(geometry.coordinates)) {\r\n          throw new TransformationError('Invalid LineString coordinates', 'INVALID_GEOMETRY');\r\n        }\r\n        const linePoints = (geometry.coordinates as number[][]).map(coord => ({\r\n          x: coord[0] ?? 0,\r\n          y: coord[1] ?? 0,\r\n          ...(coord[2] !== undefined && { z: coord[2] })\r\n        }));\r\n        const transformedLinePoints = await this.coordinateTransformer.transformPoints(\r\n          linePoints,\r\n          transform\r\n        );\r\n        return {\r\n          type: 'LineString',\r\n          coordinates: transformedLinePoints.map(p =>\r\n            p.z !== undefined ? [p.x, p.y, p.z] : [p.x, p.y]\r\n          )\r\n        };\r\n\r\n      case 'Polygon':\r\n        if (!Array.isArray(geometry.coordinates)) {\r\n          throw new TransformationError('Invalid Polygon coordinates', 'INVALID_GEOMETRY');\r\n        }\r\n        const transformedRings: number[][][] = [];\r\n        for (const ring of geometry.coordinates as number[][][]) {\r\n          const ringPoints = ring.map(coord => ({\r\n            x: coord[0] ?? 0,\r\n            y: coord[1] ?? 0,\r\n            ...(coord[2] !== undefined && { z: coord[2] })\r\n          }));\r\n          const transformedRingPoints = await this.coordinateTransformer.transformPoints(\r\n            ringPoints,\r\n            transform\r\n          );\r\n          transformedRings.push(\r\n            transformedRingPoints.map(p =>\r\n              p.z !== undefined ? [p.x, p.y, p.z] : [p.x, p.y]\r\n            )\r\n          );\r\n        }\r\n        return {\r\n          type: 'Polygon',\r\n          coordinates: transformedRings\r\n        };\r\n\r\n      default:\r\n        throw new TransformationError(\r\n          `Unsupported geometry type: ${geometry.type}`,\r\n          'UNSUPPORTED_GEOMETRY_TYPE'\r\n        );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * GeoJSON parser\r\n   */\r\n  private parseGeoJSON(data: unknown): VectorData {\r\n    try {\r\n      const geoJson = typeof data === 'string' ? JSON.parse(data) : data as Record<string, unknown>;\r\n\r\n      if (!geoJson || typeof geoJson !== 'object') {\r\n        throw new Error('Invalid GeoJSON data');\r\n      }\r\n\r\n      const features: VectorFeature[] = [];\r\n\r\n      if (geoJson.type === 'FeatureCollection' && Array.isArray(geoJson.features)) {\r\n        for (const feature of geoJson.features) {\r\n          if (feature.geometry && feature.geometry.type && feature.geometry.coordinates) {\r\n            features.push({\r\n              type: 'Feature',\r\n              geometry: feature.geometry as VectorGeometry,\r\n              properties: feature.properties || {}\r\n            });\r\n          }\r\n        }\r\n      } else if (geoJson.type === 'Feature' && geoJson.geometry) {\r\n        features.push({\r\n          type: 'Feature',\r\n          geometry: geoJson.geometry as VectorGeometry,\r\n          properties: geoJson.properties || {}\r\n        });\r\n      }\r\n\r\n      return {\r\n        type: 'FeatureCollection',\r\n        features,\r\n        crs: geoJson.crs?.properties?.name || 'EPSG:4326'\r\n      };\r\n\r\n    } catch (error) {\r\n      throw new TransformationError(\r\n        `Failed to parse GeoJSON: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        'GEOJSON_PARSE_ERROR'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple SVG parser (για basic shapes)\r\n   */\r\n  private parseSVG(data: unknown): VectorData {\r\n    try {\r\n      const svgContent = typeof data === 'string' ? data : String(data);\r\n      const features: VectorFeature[] = [];\r\n\r\n      // Simple regex-based parsing για basic SVG elements\r\n      const pathRegex = /<path[^>]*d=\"([^\"]*)\"[^>]*>/g;\r\n      const circleRegex = /<circle[^>]*cx=\"([^\"]*)\"[^>]*cy=\"([^\"]*)\"[^>]*r=\"([^\"]*)\"[^>]*>/g;\r\n\r\n      // Parse paths (simplified)\r\n      let match;\r\n      while ((match = pathRegex.exec(svgContent)) !== null) {\r\n        const pathData = match[1];\r\n        if (pathData) {\r\n          const geometry = this.parseSimpleSVGPath(pathData);\r\n          if (geometry) {\r\n            features.push({\r\n              type: 'Feature',\r\n              geometry,\r\n              properties: { type: 'path', pathData }\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      // Parse circles\r\n      while ((match = circleRegex.exec(svgContent)) !== null) {\r\n        const cxStr = match[1];\r\n        const cyStr = match[2];\r\n        const rStr = match[3];\r\n\r\n        if (cxStr && cyStr && rStr) {\r\n          const cx = parseFloat(cxStr);\r\n          const cy = parseFloat(cyStr);\r\n          const r = parseFloat(rStr);\r\n\r\n          features.push({\r\n            type: 'Feature',\r\n            geometry: {\r\n              type: 'Point',\r\n              coordinates: [cx, cy]\r\n            },\r\n            properties: { type: 'circle', radius: r }\r\n          });\r\n        }\r\n      }\r\n\r\n      return {\r\n        type: 'FeatureCollection',\r\n        features,\r\n        crs: 'SVG' // SVG coordinate system\r\n      };\r\n\r\n    } catch (error) {\r\n      throw new TransformationError(\r\n        `Failed to parse SVG: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        'SVG_PARSE_ERROR'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simplified SVG path parser\r\n   */\r\n  private parseSimpleSVGPath(pathData: string): VectorGeometry | null {\r\n    try {\r\n      // Very basic path parsing - handles only M (move) and L (line) commands\r\n      const commands = pathData.match(/[ML]\\s*[\\d.,\\s-]+/g);\r\n      if (!commands || commands.length === 0) return null;\r\n\r\n      const coordinates: number[][] = [];\r\n\r\n      for (const command of commands) {\r\n        const type = command.charAt(0);\r\n        const coords = command.slice(1).trim().split(/[\\s,]+/).map(parseFloat);\r\n\r\n        if (type === 'M' || type === 'L') {\r\n          for (let i = 0; i < coords.length; i += 2) {\r\n            if (i + 1 < coords.length) {\r\n              const x = coords[i];\r\n              const y = coords[i + 1];\r\n              if (x !== undefined && y !== undefined && !isNaN(x) && !isNaN(y)) {\r\n                coordinates.push([x, y]);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (coordinates.length === 1 && coordinates[0]) {\r\n        return {\r\n          type: 'Point',\r\n          coordinates: coordinates[0]\r\n        };\r\n      } else if (coordinates.length > 1) {\r\n        return {\r\n          type: 'LineString',\r\n          coordinates\r\n        };\r\n      }\r\n\r\n      return null;\r\n\r\n    } catch (error) {\r\n      console.warn('Failed to parse SVG path:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Placeholder methods για άλλα formats - θα υλοποιηθούν στο επόμενο στάδιο\r\n  private parseKML(_data: unknown): VectorData {\r\n    throw new TransformationError('KML parser not yet implemented', 'KML_PARSER_NOT_IMPLEMENTED');\r\n  }\r\n\r\n  private parseGPX(_data: unknown): VectorData {\r\n    throw new TransformationError('GPX parser not yet implemented', 'GPX_PARSER_NOT_IMPLEMENTED');\r\n  }\r\n\r\n  private parseDXF(_data: unknown): VectorData {\r\n    // Θα συνδεθεί με το @layera/cad-processing package\r\n    throw new TransformationError('DXF parser will be implemented in @layera/cad-processing', 'DXF_PARSER_EXTERNAL');\r\n  }\r\n\r\n  private toKML(_vectorData: VectorData): string {\r\n    throw new TransformationError('KML converter not yet implemented', 'KML_CONVERTER_NOT_IMPLEMENTED');\r\n  }\r\n\r\n  private toGPX(_vectorData: VectorData): string {\r\n    throw new TransformationError('GPX converter not yet implemented', 'GPX_CONVERTER_NOT_IMPLEMENTED');\r\n  }\r\n\r\n  private toSVG(_vectorData: VectorData): string {\r\n    throw new TransformationError('SVG converter not yet implemented', 'SVG_CONVERTER_NOT_IMPLEMENTED');\r\n  }\r\n\r\n  private toDXF(_vectorData: VectorData): string {\r\n    throw new TransformationError('DXF converter will be implemented in @layera/cad-processing', 'DXF_CONVERTER_EXTERNAL');\r\n  }\r\n\r\n  /**\r\n   * Converts vector data to GeoJSON\r\n   */\r\n  private toGeoJSON(vectorData: VectorData): unknown {\r\n    return {\r\n      type: 'FeatureCollection',\r\n      features: vectorData.features,\r\n      crs: vectorData.crs ? {\r\n        type: 'name',\r\n        properties: { name: vectorData.crs }\r\n      } : undefined\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Applies geometric transformations (scale, rotation, translation)\r\n   */\r\n  private applyGeometricTransformations(\r\n    vectorData: VectorData,\r\n    _params: NonNullable<TransformationOptions['transformationParams']>\r\n  ): VectorData {\r\n    // Implementation για geometric transformations\r\n    // Προς το παρόν επιστρέφει τα δεδομένα αμετάβλητα\r\n    console.warn('Geometric transformations not yet implemented');\r\n    return vectorData;\r\n  }\r\n\r\n  /**\r\n   * Optimizes geometry (simplification, etc.)\r\n   */\r\n  private optimizeGeometry(\r\n    vectorData: VectorData,\r\n    _tolerance: number\r\n  ): VectorData {\r\n    // Implementation για geometry optimization\r\n    // Προς το παρόν επιστρέφει τα δεδομένα αμετάβλητα\r\n    console.warn('Geometry optimization not yet implemented');\r\n    return vectorData;\r\n  }\r\n\r\n  /**\r\n   * Calculates geometry statistics\r\n   */\r\n  calculateStatistics(vectorData: VectorData): GeometryStatistics {\r\n    let entityCount = 0;\r\n    let vertexCount = 0;\r\n    let minX = Infinity;\r\n    let minY = Infinity;\r\n    let maxX = -Infinity;\r\n    let maxY = -Infinity;\r\n\r\n    for (const feature of vectorData.features) {\r\n      entityCount++;\r\n\r\n      const coords = this.extractCoordinates(feature.geometry);\r\n      vertexCount += coords.length;\r\n\r\n      for (const coord of coords) {\r\n        if (coord.length >= 2 && typeof coord[0] === 'number' && typeof coord[1] === 'number') {\r\n          minX = Math.min(minX, coord[0]);\r\n          minY = Math.min(minY, coord[1]);\r\n          maxX = Math.max(maxX, coord[0]);\r\n          maxY = Math.max(maxY, coord[1]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      entityCount,\r\n      vertexCount,\r\n      boundingBox: {\r\n        minX: minX === Infinity ? 0 : minX,\r\n        minY: minY === Infinity ? 0 : minY,\r\n        maxX: maxX === -Infinity ? 0 : maxX,\r\n        maxY: maxY === -Infinity ? 0 : maxY\r\n      },\r\n      complexityScore: entityCount * 10 + vertexCount\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extracts all coordinates from a geometry\r\n   */\r\n  private extractCoordinates(geometry: VectorGeometry): number[][] {\r\n    switch (geometry.type) {\r\n      case 'Point':\r\n        if (Array.isArray(geometry.coordinates) && typeof geometry.coordinates[0] === 'number') {\r\n          return [geometry.coordinates as number[]];\r\n        }\r\n        return [];\r\n      case 'LineString':\r\n        if (Array.isArray(geometry.coordinates)) {\r\n          return geometry.coordinates as number[][];\r\n        }\r\n        return [];\r\n      case 'Polygon':\r\n        if (Array.isArray(geometry.coordinates)) {\r\n          return (geometry.coordinates as number[][][]).flat();\r\n        }\r\n        return [];\r\n      default:\r\n        return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  destroy(): void {\r\n    this.coordinateTransformer.destroy();\r\n  }\r\n}\r\n\r\n// Internal types για vector data\r\ninterface VectorData {\r\n  type: 'FeatureCollection';\r\n  features: VectorFeature[];\r\n  crs?: string;\r\n}\r\n\r\ninterface VectorFeature {\r\n  type: 'Feature';\r\n  geometry: VectorGeometry;\r\n  properties: Record<string, unknown>;\r\n}\r\n\r\ninterface VectorGeometry {\r\n  type: 'Point' | 'LineString' | 'Polygon';\r\n  coordinates: number[] | number[][] | number[][][];\r\n}","import {\r\n  TransformationOptions,\r\n  TransformationValidationResult,\r\n  TransformationValidationError,\r\n  TransformationValidationWarning,\r\n  SupportedFormat,\r\n  FormatCompatibility\r\n} from '../types';\r\n\r\nconst SUPPORTED_FORMATS: SupportedFormat[] = [\r\n  'dxf', 'dwg', 'svg', 'geojson', 'kml', 'gpx', 'shapefile',\r\n  'tiff', 'geotiff', 'png', 'jpeg', 'webp', 'pdf', 'autocad', 'microstation'\r\n];\r\n\r\n// Format compatibility matrix\r\nconst FORMAT_COMPATIBILITY: Record<SupportedFormat, {\r\n  canTransformTo: SupportedFormat[];\r\n  dataLossRisk: Record<SupportedFormat, 'none' | 'low' | 'medium' | 'high'>;\r\n  limitations: Record<SupportedFormat, string[]>;\r\n}> = {\r\n  'geojson': {\r\n    canTransformTo: ['kml', 'gpx', 'svg', 'shapefile'],\r\n    dataLossRisk: {\r\n      'kml': 'low',\r\n      'gpx': 'medium',\r\n      'svg': 'medium',\r\n      'shapefile': 'low'\r\n    },\r\n    limitations: {\r\n      'gpx': ['Only point and line geometries supported'],\r\n      'svg': ['Complex properties may be lost', 'Coordinate precision may be reduced']\r\n    }\r\n  },\r\n  'dxf': {\r\n    canTransformTo: ['geojson', 'svg', 'dwg'],\r\n    dataLossRisk: {\r\n      'geojson': 'medium',\r\n      'svg': 'low',\r\n      'dwg': 'low'\r\n    },\r\n    limitations: {\r\n      'geojson': ['CAD-specific entities may be lost', 'Layer information simplified'],\r\n      'svg': ['3D information lost', 'Text styling may change']\r\n    }\r\n  },\r\n  'svg': {\r\n    canTransformTo: ['geojson', 'dxf', 'png', 'jpeg', 'webp'],\r\n    dataLossRisk: {\r\n      'geojson': 'high',\r\n      'dxf': 'high',\r\n      'png': 'none',\r\n      'jpeg': 'none',\r\n      'webp': 'none'\r\n    },\r\n    limitations: {\r\n      'geojson': ['SVG styling lost', 'Complex paths may be simplified'],\r\n      'dxf': ['Vector precision may be reduced', 'Styling information lost']\r\n    }\r\n  },\r\n  'kml': {\r\n    canTransformTo: ['geojson', 'gpx'],\r\n    dataLossRisk: {\r\n      'geojson': 'low',\r\n      'gpx': 'medium'\r\n    },\r\n    limitations: {\r\n      'gpx': ['Only track and waypoint data preserved']\r\n    }\r\n  },\r\n  'gpx': {\r\n    canTransformTo: ['geojson', 'kml'],\r\n    dataLossRisk: {\r\n      'geojson': 'low',\r\n      'kml': 'low'\r\n    },\r\n    limitations: {}\r\n  },\r\n  'dwg': {\r\n    canTransformTo: ['dxf', 'geojson', 'svg'],\r\n    dataLossRisk: {\r\n      'dxf': 'low',\r\n      'geojson': 'high',\r\n      'svg': 'medium'\r\n    },\r\n    limitations: {\r\n      'geojson': ['Complex CAD entities lost', 'Proprietary features lost'],\r\n      'svg': ['3D information lost', 'Complex entities simplified']\r\n    }\r\n  },\r\n  'shapefile': {\r\n    canTransformTo: ['geojson', 'kml'],\r\n    dataLossRisk: {\r\n      'geojson': 'none',\r\n      'kml': 'low'\r\n    },\r\n    limitations: {}\r\n  },\r\n  'tiff': {\r\n    canTransformTo: ['png', 'jpeg', 'webp', 'geotiff'],\r\n    dataLossRisk: {\r\n      'png': 'none',\r\n      'jpeg': 'low',\r\n      'webp': 'low',\r\n      'geotiff': 'none'\r\n    },\r\n    limitations: {\r\n      'jpeg': ['Transparency lost if present']\r\n    }\r\n  },\r\n  'geotiff': {\r\n    canTransformTo: ['tiff', 'png', 'jpeg', 'webp'],\r\n    dataLossRisk: {\r\n      'tiff': 'low',\r\n      'png': 'medium',\r\n      'jpeg': 'medium',\r\n      'webp': 'medium'\r\n    },\r\n    limitations: {\r\n      'tiff': ['Geo-referencing information lost'],\r\n      'png': ['Geo-referencing information lost'],\r\n      'jpeg': ['Geo-referencing information lost', 'Transparency lost'],\r\n      'webp': ['Geo-referencing information lost']\r\n    }\r\n  },\r\n  'png': {\r\n    canTransformTo: ['jpeg', 'webp', 'tiff'],\r\n    dataLossRisk: {\r\n      'jpeg': 'low',\r\n      'webp': 'none',\r\n      'tiff': 'none'\r\n    },\r\n    limitations: {\r\n      'jpeg': ['Transparency lost']\r\n    }\r\n  },\r\n  'jpeg': {\r\n    canTransformTo: ['png', 'webp', 'tiff'],\r\n    dataLossRisk: {\r\n      'png': 'none',\r\n      'webp': 'none',\r\n      'tiff': 'none'\r\n    },\r\n    limitations: {}\r\n  },\r\n  'webp': {\r\n    canTransformTo: ['png', 'jpeg', 'tiff'],\r\n    dataLossRisk: {\r\n      'png': 'none',\r\n      'jpeg': 'low',\r\n      'tiff': 'none'\r\n    },\r\n    limitations: {\r\n      'jpeg': ['Transparency lost if present']\r\n    }\r\n  },\r\n  'pdf': {\r\n    canTransformTo: ['svg', 'png', 'jpeg'],\r\n    dataLossRisk: {\r\n      'svg': 'high',\r\n      'png': 'medium',\r\n      'jpeg': 'medium'\r\n    },\r\n    limitations: {\r\n      'svg': ['Complex PDF features lost', 'Text may become paths'],\r\n      'png': ['Vector information lost', 'Text becomes raster'],\r\n      'jpeg': ['Vector information lost', 'Text becomes raster', 'Transparency lost']\r\n    }\r\n  },\r\n  'autocad': {\r\n    canTransformTo: ['dxf', 'dwg'],\r\n    dataLossRisk: {\r\n      'dxf': 'low',\r\n      'dwg': 'none'\r\n    },\r\n    limitations: {}\r\n  },\r\n  'microstation': {\r\n    canTransformTo: ['dxf', 'dwg'],\r\n    dataLossRisk: {\r\n      'dxf': 'medium',\r\n      'dwg': 'medium'\r\n    },\r\n    limitations: {\r\n      'dxf': ['MicroStation-specific features lost'],\r\n      'dwg': ['Some MicroStation features may not translate']\r\n    }\r\n  }\r\n};\r\n\r\n// Common coordinate systems με validation\r\nconst COMMON_CRS = [\r\n  'EPSG:4326', 'EPSG:3857', 'EPSG:2100', 'EPSG:32634', 'EPSG:32635'\r\n];\r\n\r\n/**\r\n * Validates transformation options\r\n */\r\nexport function validateTransformationOptions(\r\n  options: TransformationOptions\r\n): TransformationValidationResult {\r\n  const errors: TransformationValidationError[] = [];\r\n  const warnings: TransformationValidationWarning[] = [];\r\n\r\n  // Validate source format\r\n  if (!SUPPORTED_FORMATS.includes(options.sourceFormat)) {\r\n    errors.push({\r\n      code: 'UNSUPPORTED_SOURCE_FORMAT',\r\n      message: `Μη υποστηριζόμενη πηγαία μορφή: ${options.sourceFormat}`,\r\n      severity: 'error',\r\n      field: 'sourceFormat'\r\n    });\r\n  }\r\n\r\n  // Validate target format\r\n  if (!SUPPORTED_FORMATS.includes(options.targetFormat)) {\r\n    errors.push({\r\n      code: 'UNSUPPORTED_TARGET_FORMAT',\r\n      message: `Μη υποστηριζόμενη μορφή στόχου: ${options.targetFormat}`,\r\n      severity: 'error',\r\n      field: 'targetFormat'\r\n    });\r\n  }\r\n\r\n  // Check format compatibility\r\n  const compatibility = getFormatCompatibility(options.sourceFormat, options.targetFormat);\r\n  if (!compatibility.compatible) {\r\n    errors.push({\r\n      code: 'INCOMPATIBLE_FORMATS',\r\n      message: `Η μετατροπή από ${options.sourceFormat} σε ${options.targetFormat} δεν υποστηρίζεται`,\r\n      severity: 'error'\r\n    });\r\n  } else if (compatibility.dataLossRisk === 'high') {\r\n    warnings.push({\r\n      code: 'HIGH_DATA_LOSS_RISK',\r\n      message: 'Υψηλός κίνδυνος απώλειας δεδομένων κατά τη μετατροπή',\r\n      suggestion: `Σκεφτείτε εναλλακτικές μορφές: ${compatibility.recommendedAlternatives?.join(', ')}`,\r\n      impact: 'high'\r\n    });\r\n  } else if (compatibility.dataLossRisk === 'medium') {\r\n    warnings.push({\r\n      code: 'MEDIUM_DATA_LOSS_RISK',\r\n      message: 'Μέτριος κίνδυνος απώλειας δεδομένων',\r\n      suggestion: 'Ελέγξτε το αποτέλεσμα προσεκτικά',\r\n      impact: 'medium'\r\n    });\r\n  }\r\n\r\n  // Validate coordinate systems\r\n  if (options.sourceCRS && !isValidCRS(options.sourceCRS)) {\r\n    warnings.push({\r\n      code: 'UNKNOWN_SOURCE_CRS',\r\n      message: `Άγνωστο σύστημα συντεταγμένων πηγής: ${options.sourceCRS}`,\r\n      suggestion: 'Βεβαιωθείτε ότι το EPSG code είναι σωστό',\r\n      impact: 'medium'\r\n    });\r\n  }\r\n\r\n  if (options.targetCRS && !isValidCRS(options.targetCRS)) {\r\n    warnings.push({\r\n      code: 'UNKNOWN_TARGET_CRS',\r\n      message: `Άγνωστο σύστημα συντεταγμένων στόχου: ${options.targetCRS}`,\r\n      suggestion: 'Βεβαιωθείτε ότι το EPSG code είναι σωστό',\r\n      impact: 'medium'\r\n    });\r\n  }\r\n\r\n  // Validate transformation parameters\r\n  if (options.transformationParams) {\r\n    const params = options.transformationParams;\r\n\r\n    if (params.scale) {\r\n      if (params.scale.x <= 0 || params.scale.y <= 0) {\r\n        errors.push({\r\n          code: 'INVALID_SCALE',\r\n          message: 'Η κλίμακα πρέπει να είναι θετικός αριθμός',\r\n          severity: 'error',\r\n          field: 'transformationParams.scale'\r\n        });\r\n      }\r\n\r\n      if (params.scale.x > 1000 || params.scale.y > 1000) {\r\n        warnings.push({\r\n          code: 'LARGE_SCALE',\r\n          message: 'Πολύ μεγάλη κλίμακα μπορεί να προκαλέσει προβλήματα',\r\n          suggestion: 'Χρησιμοποιήστε κλίμακα κάτω από 1000',\r\n          impact: 'medium'\r\n        });\r\n      }\r\n    }\r\n\r\n    if (params.rotation !== undefined) {\r\n      if (Math.abs(params.rotation) > 360) {\r\n        warnings.push({\r\n          code: 'LARGE_ROTATION',\r\n          message: 'Περιστροφή μεγαλύτερη από 360° θα κανονικοποιηθεί',\r\n          impact: 'low'\r\n        });\r\n      }\r\n    }\r\n\r\n    if (params.precision !== undefined && params.precision < 0) {\r\n      errors.push({\r\n        code: 'INVALID_PRECISION',\r\n        message: 'Η ακρίβεια πρέπει να είναι μη-αρνητικός αριθμός',\r\n        severity: 'error',\r\n        field: 'transformationParams.precision'\r\n      });\r\n    }\r\n  }\r\n\r\n  // Validate quality settings\r\n  if (options.qualitySettings) {\r\n    const quality = options.qualitySettings;\r\n\r\n    if (quality.simplificationTolerance !== undefined && quality.simplificationTolerance < 0) {\r\n      errors.push({\r\n        code: 'INVALID_TOLERANCE',\r\n        message: 'Η ανοχή απλοποίησης πρέπει να είναι μη-αρνητική',\r\n        severity: 'error',\r\n        field: 'qualitySettings.simplificationTolerance'\r\n      });\r\n    }\r\n\r\n    if (quality.compressionLevel !== undefined) {\r\n      if (quality.compressionLevel < 0 || quality.compressionLevel > 100) {\r\n        errors.push({\r\n          code: 'INVALID_COMPRESSION',\r\n          message: 'Το επίπεδο συμπίεσης πρέπει να είναι μεταξύ 0-100',\r\n          severity: 'error',\r\n          field: 'qualitySettings.compressionLevel'\r\n        });\r\n      }\r\n    }\r\n\r\n    if (quality.colorDepth && ![8, 16, 24, 32].includes(quality.colorDepth)) {\r\n      errors.push({\r\n        code: 'INVALID_COLOR_DEPTH',\r\n        message: 'Το βάθος χρώματος πρέπει να είναι 8, 16, 24 ή 32',\r\n        severity: 'error',\r\n        field: 'qualitySettings.colorDepth'\r\n      });\r\n    }\r\n  }\r\n\r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n    compatibility\r\n  };\r\n}\r\n\r\n/**\r\n * Gets format compatibility information\r\n */\r\nexport function getFormatCompatibility(\r\n  sourceFormat: SupportedFormat,\r\n  targetFormat: SupportedFormat\r\n): FormatCompatibility {\r\n  const sourceConfig = FORMAT_COMPATIBILITY[sourceFormat];\r\n\r\n  if (!sourceConfig) {\r\n    return {\r\n      sourceSupported: false,\r\n      targetSupported: false,\r\n      dataLossRisk: 'high',\r\n      recommendedAlternatives: [],\r\n      limitations: [`Μη υποστηριζόμενη πηγαία μορφή: ${sourceFormat}`]\r\n    };\r\n  }\r\n\r\n  const compatible = sourceConfig.canTransformTo.includes(targetFormat);\r\n  const dataLossRisk = Object.prototype.hasOwnProperty.call(sourceConfig.dataLossRisk, targetFormat)\r\n    ? sourceConfig.dataLossRisk[targetFormat]!\r\n    : 'high';\r\n  const limitations = Object.prototype.hasOwnProperty.call(sourceConfig.limitations, targetFormat)\r\n    ? sourceConfig.limitations[targetFormat]!\r\n    : [];\r\n\r\n  // Get recommended alternatives if not compatible\r\n  const recommendedAlternatives = compatible ? [] : sourceConfig.canTransformTo.slice(0, 3);\r\n\r\n  return {\r\n    sourceSupported: true,\r\n    targetSupported: SUPPORTED_FORMATS.includes(targetFormat),\r\n    dataLossRisk,\r\n    recommendedAlternatives,\r\n    limitations,\r\n    compatible\r\n  };\r\n}\r\n\r\n/**\r\n * Checks if a CRS is valid/known\r\n */\r\nfunction isValidCRS(crs: string): boolean {\r\n  // Check common formats\r\n  if (COMMON_CRS.includes(crs)) {\r\n    return true;\r\n  }\r\n\r\n  // Check EPSG format\r\n  if (/^EPSG:\\d+$/.test(crs)) {\r\n    return true;\r\n  }\r\n\r\n  // Check PROJ4 string format\r\n  if (crs.startsWith('+proj=')) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Gets format category\r\n */\r\nexport function getFormatCategory(format: SupportedFormat): 'vector' | 'raster' | 'cad' | 'document' {\r\n  const categories: Record<SupportedFormat, 'vector' | 'raster' | 'cad' | 'document'> = {\r\n    'geojson': 'vector',\r\n    'kml': 'vector',\r\n    'gpx': 'vector',\r\n    'shapefile': 'vector',\r\n    'svg': 'vector',\r\n    'dxf': 'cad',\r\n    'dwg': 'cad',\r\n    'autocad': 'cad',\r\n    'microstation': 'cad',\r\n    'tiff': 'raster',\r\n    'geotiff': 'raster',\r\n    'png': 'raster',\r\n    'jpeg': 'raster',\r\n    'webp': 'raster',\r\n    'pdf': 'document'\r\n  };\r\n\r\n  return Object.prototype.hasOwnProperty.call(categories, format)\r\n    ? categories[format]!\r\n    : 'document';\r\n}\r\n\r\n/**\r\n * Validates batch transformation options\r\n */\r\nexport function validateBatchTransformation(\r\n  files: File[],\r\n  options: TransformationOptions\r\n): TransformationValidationResult {\r\n  const errors: TransformationValidationError[] = [];\r\n  const warnings: TransformationValidationWarning[] = [];\r\n\r\n  // Check file count\r\n  if (files.length === 0) {\r\n    errors.push({\r\n      code: 'NO_FILES',\r\n      message: 'Δεν επιλέχθηκαν αρχεία για μετατροπή',\r\n      severity: 'error'\r\n    });\r\n  }\r\n\r\n  if (files.length > 20) {\r\n    warnings.push({\r\n      code: 'MANY_FILES',\r\n      message: 'Μεγάλος αριθμός αρχείων μπορεί να επηρεάσει την απόδοση',\r\n      suggestion: 'Σκεφτείτε να επεξεργαστείτε τα αρχεία σε μικρότερες ομάδες',\r\n      impact: 'medium'\r\n    });\r\n  }\r\n\r\n  // Check total size\r\n  const totalSize = files.reduce((sum, file) => sum + file.size, 0);\r\n  if (totalSize > 1024 * 1024 * 1024) { // > 1GB\r\n    warnings.push({\r\n      code: 'LARGE_BATCH',\r\n      message: 'Μεγάλο συνολικό μέγεθος αρχείων - η επεξεργασία μπορεί να πάρει αρκετό χρόνο',\r\n      suggestion: 'Επεξεργαστείτε τα αρχεία σε μικρότερες ομάδες για καλύτερη απόδοση',\r\n      impact: 'high'\r\n    });\r\n  }\r\n\r\n  // Check format consistency\r\n  const extensions = files.map(file => file.name.split('.').pop()?.toLowerCase()).filter(Boolean);\r\n  const uniqueExtensions = [...new Set(extensions)];\r\n\r\n  if (uniqueExtensions.length > 1) {\r\n    warnings.push({\r\n      code: 'MIXED_FORMATS',\r\n      message: 'Ανάμεικτες μορφές αρχείων στη δέσμη',\r\n      suggestion: 'Βεβαιωθείτε ότι όλα τα αρχεία έχουν την ίδια πηγαία μορφή',\r\n      impact: 'medium'\r\n    });\r\n  }\r\n\r\n  // Validate individual options\r\n  const optionsValidation = validateTransformationOptions(options);\r\n  errors.push(...optionsValidation.errors);\r\n  warnings.push(...optionsValidation.warnings);\r\n\r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n    compatibility: optionsValidation.compatibility\r\n  };\r\n}\r\n\r\n/**\r\n * Estimates transformation complexity\r\n */\r\nexport function estimateTransformationComplexity(\r\n  sourceFormat: SupportedFormat,\r\n  targetFormat: SupportedFormat,\r\n  options: TransformationOptions\r\n): {\r\n  complexity: 'low' | 'medium' | 'high';\r\n  factors: string[];\r\n  estimatedTime: number; // milliseconds per MB\r\n} {\r\n  const factors: string[] = [];\r\n  let complexity: 'low' | 'medium' | 'high' = 'low';\r\n  let timePerMB = 1000; // Base: 1 second per MB\r\n\r\n  // Format complexity\r\n  const sourceCategory = getFormatCategory(sourceFormat);\r\n  const targetCategory = getFormatCategory(targetFormat);\r\n\r\n  if (sourceCategory === 'cad' || targetCategory === 'cad') {\r\n    complexity = 'high';\r\n    timePerMB = 5000;\r\n    factors.push('CAD format processing');\r\n  } else if (sourceCategory !== targetCategory) {\r\n    complexity = 'medium';\r\n    timePerMB = 2000;\r\n    factors.push('Cross-category transformation');\r\n  }\r\n\r\n  // Coordinate transformation\r\n  if (options.sourceCRS && options.targetCRS && options.sourceCRS !== options.targetCRS) {\r\n    if (complexity === 'low') complexity = 'medium';\r\n    timePerMB *= 1.5;\r\n    factors.push('Coordinate system transformation');\r\n  }\r\n\r\n  // Geometric transformations\r\n  if (options.transformationParams) {\r\n    if (complexity === 'low') complexity = 'medium';\r\n    timePerMB *= 1.3;\r\n    factors.push('Geometric transformations');\r\n  }\r\n\r\n  // Quality optimizations\r\n  if (options.qualitySettings?.optimizeGeometry) {\r\n    if (complexity === 'low') complexity = 'medium';\r\n    timePerMB *= 1.4;\r\n    factors.push('Geometry optimization');\r\n  }\r\n\r\n  if (options.qualitySettings?.simplificationTolerance !== undefined) {\r\n    timePerMB *= 1.2;\r\n    factors.push('Geometry simplification');\r\n  }\r\n\r\n  return {\r\n    complexity,\r\n    factors,\r\n    estimatedTime: Math.round(timePerMB)\r\n  };\r\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,mBAAyD;AACzD,2BAAiC;AACjC,kBAAqC;;;ACkK9B,IAAM,sBAAN,cAAkC,MAAM;AAAA,EAC7C,YACE,SACO,MACA,QACA,OACA,eACP;AACA,UAAM,OAAO;AALN;AACA;AACA;AACA;AAGP,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,iCAAN,cAA6C,oBAAoB;AAAA,EACtE,YAAY,cAAsB,cAAsB;AACtD;AAAA,MACE,uBAAuB,YAAY,OAAO,YAAY;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,gCAAN,cAA4C,oBAAoB;AAAA,EACrE,YAAY,WAAmB,WAAmB,QAAgB;AAChE;AAAA,MACE,yCAAyC,SAAS,OAAO,SAAS,KAAK,MAAM;AAAA,MAC7E;AAAA,IACF;AAAA,EACF;AACF;;;ACjMA,mBAAkB;AAQlB,IAAM,wBAAwB;AAAA;AAAA,EAE5B,aAAa;AAAA;AAAA,EAGb,aAAa;AAAA;AAAA,EAGb,aAAa;AAAA;AAAA,EAGb,aAAa;AAAA;AAAA,EAGb,cAAc;AAAA;AAAA,EAGd,cAAc;AAChB;AAMO,IAAM,wBAAN,MAA4B;AAAA,EAIjC,cAAc;AAHd,wBAAQ,aAA0C,oBAAI,IAAI;AAC1D,wBAAQ;AAGN,SAAK,wBAAwB,KAAK,sBAAsB;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,wBAAuC;AACnD,QAAI;AAEF,aAAO,QAAQ,qBAAqB,EAAE,QAAQ,CAAC,CAAC,MAAM,UAAU,MAAM;AACpE,qBAAAA,QAAM,KAAK,MAAM,UAAU;AAAA,MAC7B,CAAC;AAGD,YAAM,wBAAwB;AAAA,QAC5B,CAAC,aAAa,WAAW;AAAA;AAAA,QACzB,CAAC,aAAa,WAAW;AAAA;AAAA,QACzB,CAAC,aAAa,WAAW;AAAA;AAAA,QACzB,CAAC,aAAa,WAAW;AAAA;AAAA,QACzB,CAAC,aAAa,WAAW;AAAA;AAAA,MAC3B;AAEA,4BAAsB,QAAQ,CAAC,CAAC,QAAQ,MAAM,MAAM;AAClD,cAAM,MAAM,GAAG,MAAM,KAAK,MAAM;AAChC,YAAI,UAAU,QAAQ;AACpB,cAAI;AACF,kBAAM,gBAAY,aAAAA,SAAM,QAAQ,MAAM;AACtC,iBAAK,UAAU,IAAI,KAAK,SAAS;AAAA,UACnC,SAAS,iBAAiB;AACxB,oBAAQ,KAAK,uCAAuC,GAAG,KAAK,eAAe;AAAA,UAC7E;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,cAAQ,MAAM,gDAAgD,KAAK;AACnE,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA,0BAA0B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,MACpF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eACJ,GACA,GACA,WACA,GAC+C;AAC/C,UAAM,KAAK;AAEX,QAAI;AACF,YAAM,YAAY,KAAK,aAAa,UAAU,YAAY,UAAU,UAAU;AAC9E,YAAM,QAAQ,MAAM,SAAY,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC;AACjD,YAAM,SAAS,UAAU,QAAQ,KAAK;AAEtC,UAAI,OAAO,CAAC,MAAM,UAAa,OAAO,CAAC,MAAM,QAAW;AACtD,cAAM,IAAI;AAAA,UACR,UAAU;AAAA,UACV,UAAU;AAAA,UACV;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,QACL,GAAG,OAAO,CAAC;AAAA,QACX,GAAG,OAAO,CAAC;AAAA,QACX,GAAI,MAAM,UAAa,OAAO,CAAC,MAAM,UAAa,EAAE,GAAG,OAAO,CAAC,EAAE;AAAA,MACnE;AAAA,IAEF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,UAAU;AAAA,QACV,UAAU;AAAA,QACV,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAC3C;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBACJ,QACA,WACsD;AACtD,UAAM,KAAK;AAEX,UAAM,UAAuD,CAAC;AAE9D,QAAI;AACF,YAAM,YAAY,KAAK,aAAa,UAAU,YAAY,UAAU,UAAU;AAE9E,iBAAW,SAAS,QAAQ;AAC1B,cAAM,QAAQ,MAAM,MAAM,SAAY,CAAC,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACrF,cAAM,SAAS,UAAU,QAAQ,KAAK;AAEtC,YAAI,OAAO,CAAC,MAAM,UAAa,OAAO,CAAC,MAAM,QAAW;AACtD,gBAAM,IAAI;AAAA,YACR,UAAU;AAAA,YACV,UAAU;AAAA,YACV,sDAAsD,KAAK,UAAU,KAAK,CAAC;AAAA,UAC7E;AAAA,QACF;AAEA,gBAAQ,KAAK;AAAA,UACX,GAAG,OAAO,CAAC;AAAA,UACX,GAAG,OAAO,CAAC;AAAA,UACX,GAAI,MAAM,MAAM,UAAa,OAAO,CAAC,MAAM,UAAa,EAAE,GAAG,OAAO,CAAC,EAAE;AAAA,QACzE,CAAC;AAAA,MACH;AAEA,aAAO;AAAA,IAET,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,UAAU;AAAA,QACV,UAAU;AAAA,QACV,gCAAgC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,MAC1F;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBACJ,MACA,WACsB;AACtB,UAAM,KAAK;AAEX,QAAI;AAEF,YAAM,UAAU;AAAA,QACd,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK;AAAA,QAC7B,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK;AAAA,QAC7B,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK;AAAA,QAC7B,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK;AAAA,MAC/B;AAEA,YAAM,qBAAqB,MAAM,KAAK,gBAAgB,SAAS,SAAS;AAGxE,YAAM,KAAK,mBAAmB,IAAI,OAAK,EAAE,CAAC;AAC1C,YAAM,KAAK,mBAAmB,IAAI,OAAK,EAAE,CAAC;AAE1C,YAAM,SAAsB;AAAA,QAC1B,MAAM,KAAK,IAAI,GAAG,EAAE;AAAA,QACpB,MAAM,KAAK,IAAI,GAAG,EAAE;AAAA,QACpB,MAAM,KAAK,IAAI,GAAG,EAAE;AAAA,QACpB,MAAM,KAAK,IAAI,GAAG,EAAE;AAAA,MACtB;AAGA,UAAI,KAAK,SAAS,UAAa,KAAK,SAAS,QAAW;AACtD,cAAM,WAAW;AAAA,UACf,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK;AAAA,UAC3C,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK;AAAA,QAC7C;AAEA,cAAM,sBAAsB,MAAM,KAAK,gBAAgB,UAAU,SAAS;AAC1E,cAAM,KAAK,oBAAoB,IAAI,OAAK,EAAE,CAAE,EAAE,OAAO,OAAK,MAAM,MAAS;AAEzE,YAAI,GAAG,SAAS,GAAG;AACjB,iBAAO,OAAO,KAAK,IAAI,GAAG,EAAE;AAC5B,iBAAO,OAAO,KAAK,IAAI,GAAG,EAAE;AAAA,QAC9B;AAAA,MACF;AAEA,aAAO;AAAA,IAET,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,UAAU;AAAA,QACV,UAAU;AAAA,QACV,uCAAuC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,MACjG;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAa,YAAoB,YAAqC;AAC5E,UAAM,MAAM,GAAG,UAAU,KAAK,UAAU;AAExC,QAAI,KAAK,UAAU,IAAI,GAAG,GAAG;AAC3B,aAAO,KAAK,UAAU,IAAI,GAAG;AAAA,IAC/B;AAEA,QAAI;AACF,YAAM,gBAAY,aAAAA,SAAM,YAAY,UAAU;AAC9C,WAAK,UAAU,IAAI,KAAK,SAAS;AACjC,aAAO;AAAA,IAET,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA,0CAA0C,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,MACpG;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB,WAI1B;AACD,UAAM,KAAK;AAEX,QAAI;AAEF,YAAM,YAAY,EAAE,GAAG,IAAM,GAAG,GAAK;AAErC,UAAI,UAAU,eAAe,aAAa;AACxC,cAAM,KAAK,eAAe,UAAU,GAAG,UAAU,GAAG,SAAS;AAAA,MAC/D,OAAO;AAEL,cAAM,KAAK,eAAe,KAAQ,MAAS,SAAS;AAAA,MACtD;AAEA,aAAO;AAAA,QACL,SAAS;AAAA,QACT,UAAU,KAAK,0BAA0B,UAAU,YAAY,UAAU,UAAU;AAAA,MACrF;AAAA,IAEF,SAAS,OAAO;AACd,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,0BAA0B,YAAoB,YAA4B;AAEhF,UAAM,iBAAyD;AAAA,MAC7D,aAAa;AAAA,QACX,aAAa;AAAA;AAAA,QACb,aAAa;AAAA;AAAA,QACb,cAAc;AAAA;AAAA,QACd,cAAc;AAAA;AAAA,MAChB;AAAA,MACA,aAAa;AAAA,QACX,aAAa;AAAA;AAAA,QACb,aAAa;AAAA;AAAA,MACf;AAAA,IACF;AAEA,WAAO,eAAe,UAAU,IAAI,UAAU,KAAK;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKA,wBAAwB,MAKtB;AACA,UAAM,OAKD;AAAA,MACH,aAAa;AAAA,QACX,MAAM;AAAA,QACN,OAAO;AAAA,QACP,MAAM;AAAA,QACN,aAAa;AAAA,MACf;AAAA,MACA,aAAa;AAAA,QACX,MAAM;AAAA,QACN,OAAO;AAAA,QACP,MAAM;AAAA,QACN,aAAa;AAAA,MACf;AAAA,MACA,aAAa;AAAA,QACX,MAAM;AAAA,QACN,OAAO;AAAA,QACP,MAAM;AAAA,QACN,aAAa;AAAA,MACf;AAAA,MACA,cAAc;AAAA,QACZ,MAAM;AAAA,QACN,OAAO;AAAA,QACP,MAAM;AAAA,QACN,aAAa;AAAA,MACf;AAAA,IACF;AAEA,WAAO,KAAK,IAAI,KAAK;AAAA,MACnB,MAAM;AAAA,MACN,OAAO;AAAA,MACP,MAAM;AAAA,MACN,aAAa;AAAA,IACf;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,uBACE,cAKA;AACA,QAAI,aAAa,WAAW,GAAG;AAC7B,aAAO;AAAA,QACL,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,WAAW;AAAA,MACb;AAAA,IACF;AAEA,UAAM,KAAK,aAAa,IAAI,OAAK,EAAE,CAAC;AACpC,UAAM,KAAK,aAAa,IAAI,OAAK,EAAE,CAAC;AAEpC,UAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAC3B,UAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAC3B,UAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAC3B,UAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAG3B,QAAI,QAAQ,QAAQ,QAAQ,OAAO,QAAQ,OAAO,QAAQ,IAAI;AAE5D,UAAI,QAAQ,MAAM,QAAQ,MAAM,QAAQ,MAAM,QAAQ,IAAI;AACxD,eAAO;AAAA,UACL,YAAY;AAAA,UACZ,YAAY;AAAA,UACZ,WAAW;AAAA,QACb;AAAA,MACF;AAEA,aAAO;AAAA,QACL,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,WAAW;AAAA,MACb;AAAA,IACF;AAGA,QAAI,QAAQ,OAAU,QAAQ,OAAU,QAAQ,QAAW,QAAQ,MAAS;AAC1E,aAAO;AAAA,QACL,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,WAAW;AAAA,MACb;AAAA,IACF;AAGA,QAAI,KAAK,IAAI,IAAI,KAAK,YAAY,KAAK,IAAI,IAAI,KAAK,YAChD,KAAK,IAAI,IAAI,KAAK,YAAY,KAAK,IAAI,IAAI,KAAK,UAAU;AAC5D,aAAO;AAAA,QACL,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,WAAW;AAAA,MACb;AAAA,IACF;AAGA,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ,WAAW;AAAA,IACb;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,UAAgB;AACd,SAAK,UAAU,MAAM;AAAA,EACvB;AACF;;;AC9ZO,IAAM,0BAAN,MAA2D;AAAA,EAMhE,cAAc;AALd,gCAAO;AACP,4CAAsC,CAAC,WAAW,OAAO,OAAO,OAAO,KAAK;AAE5E,wBAAQ;AAGN,SAAK,wBAAwB,IAAI,sBAAsB;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UACJ,MACA,SACkB;AAClB,QAAI;AAEF,WAAK,kBAAkB,MAAM,QAAQ,YAAY;AAGjD,YAAM,aAAa,MAAM,KAAK,kBAAkB,MAAM,QAAQ,YAAY;AAG1E,YAAM,kBAAkB,MAAM,KAAK,qBAAqB,YAAY,OAAO;AAG3E,YAAM,SAAS,MAAM,KAAK,sBAAsB,iBAAiB,QAAQ,YAAY;AAErF,aAAO;AAAA,IAET,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,iCAAiC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACzF;AAAA,QACA;AAAA,QACA;AAAA,QACA,iBAAiB,QAAQ,QAAQ;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,MAAe,QAA+B;AACtE,QAAI,CAAC,MAAM;AACT,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,iBAAiB,SAAS,MAAM,GAAG;AAC3C,YAAM,IAAI;AAAA,QACR,8BAA8B,MAAM;AAAA,QACpC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,kBACZ,MACA,QACqB;AACrB,YAAQ,QAAQ;AAAA,MACd,KAAK;AACH,eAAO,KAAK,aAAa,IAAI;AAAA,MAC/B,KAAK;AACH,eAAO,KAAK,SAAS,IAAI;AAAA,MAC3B,KAAK;AACH,eAAO,KAAK,SAAS,IAAI;AAAA,MAC3B,KAAK;AACH,eAAO,KAAK,SAAS,IAAI;AAAA,MAC3B,KAAK;AACH,eAAO,KAAK,SAAS,IAAI;AAAA,MAC3B;AACE,cAAM,IAAI;AAAA,UACR,sCAAsC,MAAM;AAAA,UAC5C;AAAA,QACF;AAAA,IACJ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,qBACZ,YACA,SACqB;AACrB,QAAI,kBAAkB,EAAE,GAAG,WAAW;AAGtC,QAAI,QAAQ,aAAa,QAAQ,WAAW;AAC1C,wBAAkB,MAAM,KAAK;AAAA,QAC3B;AAAA,QACA,QAAQ;AAAA,QACR,QAAQ;AAAA,MACV;AAAA,IACF;AAGA,QAAI,QAAQ,sBAAsB;AAChC,wBAAkB,KAAK;AAAA,QACrB;AAAA,QACA,QAAQ;AAAA,MACV;AAAA,IACF;AAGA,QAAI,QAAQ,iBAAiB,kBAAkB;AAC7C,wBAAkB,KAAK;AAAA,QACrB;AAAA,QACA,QAAQ,gBAAgB,2BAA2B;AAAA,MACrD;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,sBACZ,YACA,QACkB;AAClB,YAAQ,QAAQ;AAAA,MACd,KAAK;AACH,eAAO,KAAK,UAAU,UAAU;AAAA,MAClC,KAAK;AACH,eAAO,KAAK,MAAM,UAAU;AAAA,MAC9B,KAAK;AACH,eAAO,KAAK,MAAM,UAAU;AAAA,MAC9B,KAAK;AACH,eAAO,KAAK,MAAM,UAAU;AAAA,MAC9B,KAAK;AACH,eAAO,KAAK,MAAM,UAAU;AAAA,MAC9B;AACE,cAAM,IAAI;AAAA,UACR,yCAAyC,MAAM;AAAA,UAC/C;AAAA,QACF;AAAA,IACJ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,8BACZ,YACA,WACA,WACqB;AACrB,UAAM,sBAAuC,CAAC;AAE9C,eAAW,WAAW,WAAW,UAAU;AACzC,YAAM,sBAAsB,MAAM,KAAK;AAAA,QACrC,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,MACF;AAEA,0BAAoB,KAAK;AAAA,QACvB,GAAG;AAAA,QACH,UAAU;AAAA,MACZ,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,UAAU;AAAA,MACV,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,kBACZ,UACA,WACA,WACyB;AACzB,UAAM,YAAY;AAAA,MAChB,YAAY;AAAA,MACZ,YAAY;AAAA,IACd;AAEA,YAAQ,SAAS,MAAM;AAAA,MACrB,KAAK;AACH,YAAI,CAAC,MAAM,QAAQ,SAAS,WAAW,KAAK,SAAS,YAAY,SAAS,GAAG;AAC3E,gBAAM,IAAI,oBAAoB,6BAA6B,kBAAkB;AAAA,QAC/E;AACA,cAAM,CAAC,GAAG,GAAG,CAAC,IAAI,SAAS;AAC3B,cAAM,QAAQ,MAAM,KAAK,sBAAsB;AAAA,UAC7C,KAAK;AAAA,UACL,KAAK;AAAA,UACL;AAAA,UACA;AAAA,QACF;AACA,eAAO;AAAA,UACL,MAAM;AAAA,UACN,aAAa,MAAM,MAAM,SAAY,CAAC,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,QACtF;AAAA,MAEF,KAAK;AACH,YAAI,CAAC,MAAM,QAAQ,SAAS,WAAW,GAAG;AACxC,gBAAM,IAAI,oBAAoB,kCAAkC,kBAAkB;AAAA,QACpF;AACA,cAAM,aAAc,SAAS,YAA2B,IAAI,YAAU;AAAA,UACpE,GAAG,MAAM,CAAC,KAAK;AAAA,UACf,GAAG,MAAM,CAAC,KAAK;AAAA,UACf,GAAI,MAAM,CAAC,MAAM,UAAa,EAAE,GAAG,MAAM,CAAC,EAAE;AAAA,QAC9C,EAAE;AACF,cAAM,wBAAwB,MAAM,KAAK,sBAAsB;AAAA,UAC7D;AAAA,UACA;AAAA,QACF;AACA,eAAO;AAAA,UACL,MAAM;AAAA,UACN,aAAa,sBAAsB;AAAA,YAAI,OACrC,EAAE,MAAM,SAAY,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;AAAA,UACjD;AAAA,QACF;AAAA,MAEF,KAAK;AACH,YAAI,CAAC,MAAM,QAAQ,SAAS,WAAW,GAAG;AACxC,gBAAM,IAAI,oBAAoB,+BAA+B,kBAAkB;AAAA,QACjF;AACA,cAAM,mBAAiC,CAAC;AACxC,mBAAW,QAAQ,SAAS,aAA6B;AACvD,gBAAM,aAAa,KAAK,IAAI,YAAU;AAAA,YACpC,GAAG,MAAM,CAAC,KAAK;AAAA,YACf,GAAG,MAAM,CAAC,KAAK;AAAA,YACf,GAAI,MAAM,CAAC,MAAM,UAAa,EAAE,GAAG,MAAM,CAAC,EAAE;AAAA,UAC9C,EAAE;AACF,gBAAM,wBAAwB,MAAM,KAAK,sBAAsB;AAAA,YAC7D;AAAA,YACA;AAAA,UACF;AACA,2BAAiB;AAAA,YACf,sBAAsB;AAAA,cAAI,OACxB,EAAE,MAAM,SAAY,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;AAAA,YACjD;AAAA,UACF;AAAA,QACF;AACA,eAAO;AAAA,UACL,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,MAEF;AACE,cAAM,IAAI;AAAA,UACR,8BAA8B,SAAS,IAAI;AAAA,UAC3C;AAAA,QACF;AAAA,IACJ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAa,MAA2B;AAC9C,QAAI;AACF,YAAM,UAAU,OAAO,SAAS,WAAW,KAAK,MAAM,IAAI,IAAI;AAE9D,UAAI,CAAC,WAAW,OAAO,YAAY,UAAU;AAC3C,cAAM,IAAI,MAAM,sBAAsB;AAAA,MACxC;AAEA,YAAM,WAA4B,CAAC;AAEnC,UAAI,QAAQ,SAAS,uBAAuB,MAAM,QAAQ,QAAQ,QAAQ,GAAG;AAC3E,mBAAW,WAAW,QAAQ,UAAU;AACtC,cAAI,QAAQ,YAAY,QAAQ,SAAS,QAAQ,QAAQ,SAAS,aAAa;AAC7E,qBAAS,KAAK;AAAA,cACZ,MAAM;AAAA,cACN,UAAU,QAAQ;AAAA,cAClB,YAAY,QAAQ,cAAc,CAAC;AAAA,YACrC,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF,WAAW,QAAQ,SAAS,aAAa,QAAQ,UAAU;AACzD,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,UAAU,QAAQ;AAAA,UAClB,YAAY,QAAQ,cAAc,CAAC;AAAA,QACrC,CAAC;AAAA,MACH;AAEA,aAAO;AAAA,QACL,MAAM;AAAA,QACN;AAAA,QACA,KAAK,QAAQ,KAAK,YAAY,QAAQ;AAAA,MACxC;AAAA,IAEF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,4BAA4B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACpF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,SAAS,MAA2B;AAC1C,QAAI;AACF,YAAM,aAAa,OAAO,SAAS,WAAW,OAAO,OAAO,IAAI;AAChE,YAAM,WAA4B,CAAC;AAGnC,YAAM,YAAY;AAClB,YAAM,cAAc;AAGpB,UAAI;AACJ,cAAQ,QAAQ,UAAU,KAAK,UAAU,OAAO,MAAM;AACpD,cAAM,WAAW,MAAM,CAAC;AACxB,YAAI,UAAU;AACZ,gBAAM,WAAW,KAAK,mBAAmB,QAAQ;AACjD,cAAI,UAAU;AACZ,qBAAS,KAAK;AAAA,cACZ,MAAM;AAAA,cACN;AAAA,cACA,YAAY,EAAE,MAAM,QAAQ,SAAS;AAAA,YACvC,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAGA,cAAQ,QAAQ,YAAY,KAAK,UAAU,OAAO,MAAM;AACtD,cAAM,QAAQ,MAAM,CAAC;AACrB,cAAM,QAAQ,MAAM,CAAC;AACrB,cAAM,OAAO,MAAM,CAAC;AAEpB,YAAI,SAAS,SAAS,MAAM;AAC1B,gBAAM,KAAK,WAAW,KAAK;AAC3B,gBAAM,KAAK,WAAW,KAAK;AAC3B,gBAAM,IAAI,WAAW,IAAI;AAEzB,mBAAS,KAAK;AAAA,YACZ,MAAM;AAAA,YACN,UAAU;AAAA,cACR,MAAM;AAAA,cACN,aAAa,CAAC,IAAI,EAAE;AAAA,YACtB;AAAA,YACA,YAAY,EAAE,MAAM,UAAU,QAAQ,EAAE;AAAA,UAC1C,CAAC;AAAA,QACH;AAAA,MACF;AAEA,aAAO;AAAA,QACL,MAAM;AAAA,QACN;AAAA,QACA,KAAK;AAAA;AAAA,MACP;AAAA,IAEF,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,wBAAwB,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QAChF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAmB,UAAyC;AAClE,QAAI;AAEF,YAAM,WAAW,SAAS,MAAM,oBAAoB;AACpD,UAAI,CAAC,YAAY,SAAS,WAAW,EAAG,QAAO;AAE/C,YAAM,cAA0B,CAAC;AAEjC,iBAAW,WAAW,UAAU;AAC9B,cAAM,OAAO,QAAQ,OAAO,CAAC;AAC7B,cAAM,SAAS,QAAQ,MAAM,CAAC,EAAE,KAAK,EAAE,MAAM,QAAQ,EAAE,IAAI,UAAU;AAErE,YAAI,SAAS,OAAO,SAAS,KAAK;AAChC,mBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACzC,gBAAI,IAAI,IAAI,OAAO,QAAQ;AACzB,oBAAM,IAAI,OAAO,CAAC;AAClB,oBAAM,IAAI,OAAO,IAAI,CAAC;AACtB,kBAAI,MAAM,UAAa,MAAM,UAAa,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG;AAChE,4BAAY,KAAK,CAAC,GAAG,CAAC,CAAC;AAAA,cACzB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,UAAI,YAAY,WAAW,KAAK,YAAY,CAAC,GAAG;AAC9C,eAAO;AAAA,UACL,MAAM;AAAA,UACN,aAAa,YAAY,CAAC;AAAA,QAC5B;AAAA,MACF,WAAW,YAAY,SAAS,GAAG;AACjC,eAAO;AAAA,UACL,MAAM;AAAA,UACN;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IAET,SAAS,OAAO;AACd,cAAQ,KAAK,6BAA6B,KAAK;AAC/C,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA,EAGQ,SAAS,OAA4B;AAC3C,UAAM,IAAI,oBAAoB,kCAAkC,4BAA4B;AAAA,EAC9F;AAAA,EAEQ,SAAS,OAA4B;AAC3C,UAAM,IAAI,oBAAoB,kCAAkC,4BAA4B;AAAA,EAC9F;AAAA,EAEQ,SAAS,OAA4B;AAE3C,UAAM,IAAI,oBAAoB,4DAA4D,qBAAqB;AAAA,EACjH;AAAA,EAEQ,MAAM,aAAiC;AAC7C,UAAM,IAAI,oBAAoB,qCAAqC,+BAA+B;AAAA,EACpG;AAAA,EAEQ,MAAM,aAAiC;AAC7C,UAAM,IAAI,oBAAoB,qCAAqC,+BAA+B;AAAA,EACpG;AAAA,EAEQ,MAAM,aAAiC;AAC7C,UAAM,IAAI,oBAAoB,qCAAqC,+BAA+B;AAAA,EACpG;AAAA,EAEQ,MAAM,aAAiC;AAC7C,UAAM,IAAI,oBAAoB,+DAA+D,wBAAwB;AAAA,EACvH;AAAA;AAAA;AAAA;AAAA,EAKQ,UAAU,YAAiC;AACjD,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU,WAAW;AAAA,MACrB,KAAK,WAAW,MAAM;AAAA,QACpB,MAAM;AAAA,QACN,YAAY,EAAE,MAAM,WAAW,IAAI;AAAA,MACrC,IAAI;AAAA,IACN;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,8BACN,YACA,SACY;AAGZ,YAAQ,KAAK,+CAA+C;AAC5D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,iBACN,YACA,YACY;AAGZ,YAAQ,KAAK,2CAA2C;AACxD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,oBAAoB,YAA4C;AAC9D,QAAI,cAAc;AAClB,QAAI,cAAc;AAClB,QAAI,OAAO;AACX,QAAI,OAAO;AACX,QAAI,OAAO;AACX,QAAI,OAAO;AAEX,eAAW,WAAW,WAAW,UAAU;AACzC;AAEA,YAAM,SAAS,KAAK,mBAAmB,QAAQ,QAAQ;AACvD,qBAAe,OAAO;AAEtB,iBAAW,SAAS,QAAQ;AAC1B,YAAI,MAAM,UAAU,KAAK,OAAO,MAAM,CAAC,MAAM,YAAY,OAAO,MAAM,CAAC,MAAM,UAAU;AACrF,iBAAO,KAAK,IAAI,MAAM,MAAM,CAAC,CAAC;AAC9B,iBAAO,KAAK,IAAI,MAAM,MAAM,CAAC,CAAC;AAC9B,iBAAO,KAAK,IAAI,MAAM,MAAM,CAAC,CAAC;AAC9B,iBAAO,KAAK,IAAI,MAAM,MAAM,CAAC,CAAC;AAAA,QAChC;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,aAAa;AAAA,QACX,MAAM,SAAS,WAAW,IAAI;AAAA,QAC9B,MAAM,SAAS,WAAW,IAAI;AAAA,QAC9B,MAAM,SAAS,YAAY,IAAI;AAAA,QAC/B,MAAM,SAAS,YAAY,IAAI;AAAA,MACjC;AAAA,MACA,iBAAiB,cAAc,KAAK;AAAA,IACtC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAmB,UAAsC;AAC/D,YAAQ,SAAS,MAAM;AAAA,MACrB,KAAK;AACH,YAAI,MAAM,QAAQ,SAAS,WAAW,KAAK,OAAO,SAAS,YAAY,CAAC,MAAM,UAAU;AACtF,iBAAO,CAAC,SAAS,WAAuB;AAAA,QAC1C;AACA,eAAO,CAAC;AAAA,MACV,KAAK;AACH,YAAI,MAAM,QAAQ,SAAS,WAAW,GAAG;AACvC,iBAAO,SAAS;AAAA,QAClB;AACA,eAAO,CAAC;AAAA,MACV,KAAK;AACH,YAAI,MAAM,QAAQ,SAAS,WAAW,GAAG;AACvC,iBAAQ,SAAS,YAA6B,KAAK;AAAA,QACrD;AACA,eAAO,CAAC;AAAA,MACV;AACE,eAAO,CAAC;AAAA,IACZ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,UAAgB;AACd,SAAK,sBAAsB,QAAQ;AAAA,EACrC;AACF;;;ACvjBA,IAAM,oBAAuC;AAAA,EAC3C;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAW;AAAA,EAAO;AAAA,EAAO;AAAA,EAC9C;AAAA,EAAQ;AAAA,EAAW;AAAA,EAAO;AAAA,EAAQ;AAAA,EAAQ;AAAA,EAAO;AAAA,EAAW;AAC9D;AAGA,IAAM,uBAID;AAAA,EACH,WAAW;AAAA,IACT,gBAAgB,CAAC,OAAO,OAAO,OAAO,WAAW;AAAA,IACjD,cAAc;AAAA,MACZ,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,aAAa;AAAA,IACf;AAAA,IACA,aAAa;AAAA,MACX,OAAO,CAAC,0CAA0C;AAAA,MAClD,OAAO,CAAC,kCAAkC,qCAAqC;AAAA,IACjF;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL,gBAAgB,CAAC,WAAW,OAAO,KAAK;AAAA,IACxC,cAAc;AAAA,MACZ,WAAW;AAAA,MACX,OAAO;AAAA,MACP,OAAO;AAAA,IACT;AAAA,IACA,aAAa;AAAA,MACX,WAAW,CAAC,qCAAqC,8BAA8B;AAAA,MAC/E,OAAO,CAAC,uBAAuB,yBAAyB;AAAA,IAC1D;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL,gBAAgB,CAAC,WAAW,OAAO,OAAO,QAAQ,MAAM;AAAA,IACxD,cAAc;AAAA,MACZ,WAAW;AAAA,MACX,OAAO;AAAA,MACP,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAAA,IACA,aAAa;AAAA,MACX,WAAW,CAAC,oBAAoB,iCAAiC;AAAA,MACjE,OAAO,CAAC,mCAAmC,0BAA0B;AAAA,IACvE;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL,gBAAgB,CAAC,WAAW,KAAK;AAAA,IACjC,cAAc;AAAA,MACZ,WAAW;AAAA,MACX,OAAO;AAAA,IACT;AAAA,IACA,aAAa;AAAA,MACX,OAAO,CAAC,wCAAwC;AAAA,IAClD;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL,gBAAgB,CAAC,WAAW,KAAK;AAAA,IACjC,cAAc;AAAA,MACZ,WAAW;AAAA,MACX,OAAO;AAAA,IACT;AAAA,IACA,aAAa,CAAC;AAAA,EAChB;AAAA,EACA,OAAO;AAAA,IACL,gBAAgB,CAAC,OAAO,WAAW,KAAK;AAAA,IACxC,cAAc;AAAA,MACZ,OAAO;AAAA,MACP,WAAW;AAAA,MACX,OAAO;AAAA,IACT;AAAA,IACA,aAAa;AAAA,MACX,WAAW,CAAC,6BAA6B,2BAA2B;AAAA,MACpE,OAAO,CAAC,uBAAuB,6BAA6B;AAAA,IAC9D;AAAA,EACF;AAAA,EACA,aAAa;AAAA,IACX,gBAAgB,CAAC,WAAW,KAAK;AAAA,IACjC,cAAc;AAAA,MACZ,WAAW;AAAA,MACX,OAAO;AAAA,IACT;AAAA,IACA,aAAa,CAAC;AAAA,EAChB;AAAA,EACA,QAAQ;AAAA,IACN,gBAAgB,CAAC,OAAO,QAAQ,QAAQ,SAAS;AAAA,IACjD,cAAc;AAAA,MACZ,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,WAAW;AAAA,IACb;AAAA,IACA,aAAa;AAAA,MACX,QAAQ,CAAC,8BAA8B;AAAA,IACzC;AAAA,EACF;AAAA,EACA,WAAW;AAAA,IACT,gBAAgB,CAAC,QAAQ,OAAO,QAAQ,MAAM;AAAA,IAC9C,cAAc;AAAA,MACZ,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAAA,IACA,aAAa;AAAA,MACX,QAAQ,CAAC,kCAAkC;AAAA,MAC3C,OAAO,CAAC,kCAAkC;AAAA,MAC1C,QAAQ,CAAC,oCAAoC,mBAAmB;AAAA,MAChE,QAAQ,CAAC,kCAAkC;AAAA,IAC7C;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL,gBAAgB,CAAC,QAAQ,QAAQ,MAAM;AAAA,IACvC,cAAc;AAAA,MACZ,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAAA,IACA,aAAa;AAAA,MACX,QAAQ,CAAC,mBAAmB;AAAA,IAC9B;AAAA,EACF;AAAA,EACA,QAAQ;AAAA,IACN,gBAAgB,CAAC,OAAO,QAAQ,MAAM;AAAA,IACtC,cAAc;AAAA,MACZ,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAAA,IACA,aAAa,CAAC;AAAA,EAChB;AAAA,EACA,QAAQ;AAAA,IACN,gBAAgB,CAAC,OAAO,QAAQ,MAAM;AAAA,IACtC,cAAc;AAAA,MACZ,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAAA,IACA,aAAa;AAAA,MACX,QAAQ,CAAC,8BAA8B;AAAA,IACzC;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL,gBAAgB,CAAC,OAAO,OAAO,MAAM;AAAA,IACrC,cAAc;AAAA,MACZ,OAAO;AAAA,MACP,OAAO;AAAA,MACP,QAAQ;AAAA,IACV;AAAA,IACA,aAAa;AAAA,MACX,OAAO,CAAC,6BAA6B,uBAAuB;AAAA,MAC5D,OAAO,CAAC,2BAA2B,qBAAqB;AAAA,MACxD,QAAQ,CAAC,2BAA2B,uBAAuB,mBAAmB;AAAA,IAChF;AAAA,EACF;AAAA,EACA,WAAW;AAAA,IACT,gBAAgB,CAAC,OAAO,KAAK;AAAA,IAC7B,cAAc;AAAA,MACZ,OAAO;AAAA,MACP,OAAO;AAAA,IACT;AAAA,IACA,aAAa,CAAC;AAAA,EAChB;AAAA,EACA,gBAAgB;AAAA,IACd,gBAAgB,CAAC,OAAO,KAAK;AAAA,IAC7B,cAAc;AAAA,MACZ,OAAO;AAAA,MACP,OAAO;AAAA,IACT;AAAA,IACA,aAAa;AAAA,MACX,OAAO,CAAC,qCAAqC;AAAA,MAC7C,OAAO,CAAC,8CAA8C;AAAA,IACxD;AAAA,EACF;AACF;AAGA,IAAM,aAAa;AAAA,EACjB;AAAA,EAAa;AAAA,EAAa;AAAA,EAAa;AAAA,EAAc;AACvD;AAKO,SAAS,8BACd,SACgC;AAChC,QAAM,SAA0C,CAAC;AACjD,QAAM,WAA8C,CAAC;AAGrD,MAAI,CAAC,kBAAkB,SAAS,QAAQ,YAAY,GAAG;AACrD,WAAO,KAAK;AAAA,MACV,MAAM;AAAA,MACN,SAAS,0KAAmC,QAAQ,YAAY;AAAA,MAChE,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AAGA,MAAI,CAAC,kBAAkB,SAAS,QAAQ,YAAY,GAAG;AACrD,WAAO,KAAK;AAAA,MACV,MAAM;AAAA,MACN,SAAS,0KAAmC,QAAQ,YAAY;AAAA,MAChE,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AAGA,QAAM,gBAAgB,uBAAuB,QAAQ,cAAc,QAAQ,YAAY;AACvF,MAAI,CAAC,cAAc,YAAY;AAC7B,WAAO,KAAK;AAAA,MACV,MAAM;AAAA,MACN,SAAS,oFAAmB,QAAQ,YAAY,iBAAO,QAAQ,YAAY;AAAA,MAC3E,UAAU;AAAA,IACZ,CAAC;AAAA,EACH,WAAW,cAAc,iBAAiB,QAAQ;AAChD,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,SAAS;AAAA,MACT,YAAY,yKAAkC,cAAc,yBAAyB,KAAK,IAAI,CAAC;AAAA,MAC/F,QAAQ;AAAA,IACV,CAAC;AAAA,EACH,WAAW,cAAc,iBAAiB,UAAU;AAClD,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAGA,MAAI,QAAQ,aAAa,CAAC,WAAW,QAAQ,SAAS,GAAG;AACvD,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,SAAS,wMAAwC,QAAQ,SAAS;AAAA,MAClE,YAAY;AAAA,MACZ,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAEA,MAAI,QAAQ,aAAa,CAAC,WAAW,QAAQ,SAAS,GAAG;AACvD,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,SAAS,8MAAyC,QAAQ,SAAS;AAAA,MACnE,YAAY;AAAA,MACZ,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAGA,MAAI,QAAQ,sBAAsB;AAChC,UAAM,SAAS,QAAQ;AAEvB,QAAI,OAAO,OAAO;AAChB,UAAI,OAAO,MAAM,KAAK,KAAK,OAAO,MAAM,KAAK,GAAG;AAC9C,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,SAAS;AAAA,UACT,UAAU;AAAA,UACV,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAEA,UAAI,OAAO,MAAM,IAAI,OAAQ,OAAO,MAAM,IAAI,KAAM;AAClD,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SAAS;AAAA,UACT,YAAY;AAAA,UACZ,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,OAAO,aAAa,QAAW;AACjC,UAAI,KAAK,IAAI,OAAO,QAAQ,IAAI,KAAK;AACnC,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SAAS;AAAA,UACT,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,OAAO,cAAc,UAAa,OAAO,YAAY,GAAG;AAC1D,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,QACV,OAAO;AAAA,MACT,CAAC;AAAA,IACH;AAAA,EACF;AAGA,MAAI,QAAQ,iBAAiB;AAC3B,UAAM,UAAU,QAAQ;AAExB,QAAI,QAAQ,4BAA4B,UAAa,QAAQ,0BAA0B,GAAG;AACxF,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,QACV,OAAO;AAAA,MACT,CAAC;AAAA,IACH;AAEA,QAAI,QAAQ,qBAAqB,QAAW;AAC1C,UAAI,QAAQ,mBAAmB,KAAK,QAAQ,mBAAmB,KAAK;AAClE,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,SAAS;AAAA,UACT,UAAU;AAAA,UACV,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,QAAQ,cAAc,CAAC,CAAC,GAAG,IAAI,IAAI,EAAE,EAAE,SAAS,QAAQ,UAAU,GAAG;AACvE,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,QACV,OAAO;AAAA,MACT,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AAAA,IACL,SAAS,OAAO,WAAW;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAKO,SAAS,uBACd,cACA,cACqB;AACrB,QAAM,eAAe,qBAAqB,YAAY;AAEtD,MAAI,CAAC,cAAc;AACjB,WAAO;AAAA,MACL,iBAAiB;AAAA,MACjB,iBAAiB;AAAA,MACjB,cAAc;AAAA,MACd,yBAAyB,CAAC;AAAA,MAC1B,aAAa,CAAC,0KAAmC,YAAY,EAAE;AAAA,IACjE;AAAA,EACF;AAEA,QAAM,aAAa,aAAa,eAAe,SAAS,YAAY;AACpE,QAAM,eAAe,OAAO,UAAU,eAAe,KAAK,aAAa,cAAc,YAAY,IAC7F,aAAa,aAAa,YAAY,IACtC;AACJ,QAAM,cAAc,OAAO,UAAU,eAAe,KAAK,aAAa,aAAa,YAAY,IAC3F,aAAa,YAAY,YAAY,IACrC,CAAC;AAGL,QAAM,0BAA0B,aAAa,CAAC,IAAI,aAAa,eAAe,MAAM,GAAG,CAAC;AAExF,SAAO;AAAA,IACL,iBAAiB;AAAA,IACjB,iBAAiB,kBAAkB,SAAS,YAAY;AAAA,IACxD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAKA,SAAS,WAAW,KAAsB;AAExC,MAAI,WAAW,SAAS,GAAG,GAAG;AAC5B,WAAO;AAAA,EACT;AAGA,MAAI,aAAa,KAAK,GAAG,GAAG;AAC1B,WAAO;AAAA,EACT;AAGA,MAAI,IAAI,WAAW,QAAQ,GAAG;AAC5B,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAKO,SAAS,kBAAkB,QAAmE;AACnG,QAAM,aAAgF;AAAA,IACpF,WAAW;AAAA,IACX,OAAO;AAAA,IACP,OAAO;AAAA,IACP,aAAa;AAAA,IACb,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,WAAW;AAAA,IACX,gBAAgB;AAAA,IAChB,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AAEA,SAAO,OAAO,UAAU,eAAe,KAAK,YAAY,MAAM,IAC1D,WAAW,MAAM,IACjB;AACN;AAKO,SAAS,4BACd,OACA,SACgC;AAChC,QAAM,SAA0C,CAAC;AACjD,QAAM,WAA8C,CAAC;AAGrD,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,KAAK;AAAA,MACV,MAAM;AAAA,MACN,SAAS;AAAA,MACT,UAAU;AAAA,IACZ,CAAC;AAAA,EACH;AAEA,MAAI,MAAM,SAAS,IAAI;AACrB,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAGA,QAAM,YAAY,MAAM,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,MAAM,CAAC;AAChE,MAAI,YAAY,OAAO,OAAO,MAAM;AAClC,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAGA,QAAM,aAAa,MAAM,IAAI,UAAQ,KAAK,KAAK,MAAM,GAAG,EAAE,IAAI,GAAG,YAAY,CAAC,EAAE,OAAO,OAAO;AAC9F,QAAM,mBAAmB,CAAC,GAAG,IAAI,IAAI,UAAU,CAAC;AAEhD,MAAI,iBAAiB,SAAS,GAAG;AAC/B,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAGA,QAAM,oBAAoB,8BAA8B,OAAO;AAC/D,SAAO,KAAK,GAAG,kBAAkB,MAAM;AACvC,WAAS,KAAK,GAAG,kBAAkB,QAAQ;AAE3C,SAAO;AAAA,IACL,SAAS,OAAO,WAAW;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,eAAe,kBAAkB;AAAA,EACnC;AACF;AAKO,SAAS,iCACd,cACA,cACA,SAKA;AACA,QAAM,UAAoB,CAAC;AAC3B,MAAI,aAAwC;AAC5C,MAAI,YAAY;AAGhB,QAAM,iBAAiB,kBAAkB,YAAY;AACrD,QAAM,iBAAiB,kBAAkB,YAAY;AAErD,MAAI,mBAAmB,SAAS,mBAAmB,OAAO;AACxD,iBAAa;AACb,gBAAY;AACZ,YAAQ,KAAK,uBAAuB;AAAA,EACtC,WAAW,mBAAmB,gBAAgB;AAC5C,iBAAa;AACb,gBAAY;AACZ,YAAQ,KAAK,+BAA+B;AAAA,EAC9C;AAGA,MAAI,QAAQ,aAAa,QAAQ,aAAa,QAAQ,cAAc,QAAQ,WAAW;AACrF,QAAI,eAAe,MAAO,cAAa;AACvC,iBAAa;AACb,YAAQ,KAAK,kCAAkC;AAAA,EACjD;AAGA,MAAI,QAAQ,sBAAsB;AAChC,QAAI,eAAe,MAAO,cAAa;AACvC,iBAAa;AACb,YAAQ,KAAK,2BAA2B;AAAA,EAC1C;AAGA,MAAI,QAAQ,iBAAiB,kBAAkB;AAC7C,QAAI,eAAe,MAAO,cAAa;AACvC,iBAAa;AACb,YAAQ,KAAK,uBAAuB;AAAA,EACtC;AAEA,MAAI,QAAQ,iBAAiB,4BAA4B,QAAW;AAClE,iBAAa;AACb,YAAQ,KAAK,yBAAyB;AAAA,EACxC;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,eAAe,KAAK,MAAM,SAAS;AAAA,EACrC;AACF;;;AJ/fO,SAAS,sBACd,UAAwC,CAAC,GACZ;AAC7B,QAAM,EAAE,EAAE,QAAI,kCAAqB;AACnC,QAAM,EAAE,gBAAgB,QAAI,uCAAiB;AAC7C,QAAM,CAAC,gBAAgB,iBAAiB,QAAI,uBAAS,KAAK;AAC1D,QAAM,CAAC,UAAU,WAAW,QAAI,uBAAS,CAAC;AAC1C,QAAM,CAAC,SAAS,UAAU,QAAI,uBAAiC,CAAC,CAAC;AACjE,QAAM,CAAC,QAAQ,SAAS,QAAI,uBAAgC,CAAC,CAAC;AAE9D,QAAM,2BAAuB,qBAAuC,IAAI;AACxE,QAAM,yBAAqB,qBAA+B,IAAI;AAE9D,QAAM;AAAA,IACJ,iBAAiB,CAAC;AAAA,IAClB,qBAAqB;AAAA,IACrB,oBAAoB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AAGJ,8BAAU,MAAM;AACd,QAAI;AACF,2BAAqB,UAAU,IAAI,wBAAwB;AAAA,IAC7D,SAAS,OAAO;AACd,cAAQ,MAAM,gDAAgD,KAAK;AACnE,UAAI,mBAAmB;AACrB,wBAAgB;AAAA,UACd,MAAM;AAAA,UACN,SAAS,EAAE,kCAAkC;AAAA,QAC/C,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,MAAM;AACX,UAAI,qBAAqB,SAAS;AAChC,6BAAqB,QAAQ,QAAQ;AAAA,MACvC;AAAA,IACF;AAAA,EACF,GAAG,CAAC,mBAAmB,CAAC,CAAC;AAEzB,QAAM,qBAAiB,0BAAY,CACjC,QACA,OACAC,WACA,SACA,qBACG;AACH,UAAM,eAAuC;AAAA,MAC3C;AAAA,MACA;AAAA,MACA,UAAAA;AAAA,MACA;AAAA,MACA,GAAI,oBAAoB,EAAE,iBAAiB;AAAA,IAC7C;AAEA,gBAAYA,SAAQ;AACpB,iBAAa,YAAY;AAEzB,QAAI,qBAAqB,UAAU,YAAY;AAC7C,sBAAgB;AAAA,QACd,MAAM;AAAA,QACN,SAAS,EAAE,+BAA+B,EAAE,UAAU,KAAK,MAAMA,SAAQ,EAAE,CAAC;AAAA,QAC5E,UAAU;AAAA,MACZ,CAAC;AAAA,IACH;AAAA,EACF,GAAG,CAAC,YAAY,mBAAmB,CAAC,CAAC;AAErC,QAAM,kBAAc,0BAAY,CAAC,UAA+B;AAC9D,cAAU,UAAQ,CAAC,GAAG,MAAM,KAAK,CAAC;AAClC,cAAU,KAAK;AAEf,QAAI,mBAAmB;AACrB,sBAAgB;AAAA,QACd,MAAM;AAAA,QACN,SAAS,EAAE,6BAA6B;AAAA,UACtC,OAAO,MAAM;AAAA,QACf,CAAC;AAAA,QACD,UAAU;AAAA,QACV,QAAQ,EAAE,OAAO,EAAE,sBAAsB,GAAG,SAAS,MAAM;AAAA,QAAC,EAAE;AAAA,MAChE,CAAC;AAAA,IACH;AAAA,EACF,GAAG,CAAC,SAAS,mBAAmB,CAAC,CAAC;AAElC,QAAM,oBAAgB,0BAAY,OAAO,MAAY,0BAAgF;AACnI,QAAI,CAAC,qBAAqB,SAAS;AACjC,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,UAAM,SAAS,aAAa,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AACjF,UAAM,eAAe,EAAE,GAAG,gBAAgB,GAAG,sBAAsB;AACnE,UAAM,YAAY,YAAY,IAAI;AAElC,QAAI;AACF,wBAAkB,IAAI;AACtB,qBAAe,QAAQ,WAAW,IAAI,EAAE,6BAA6B,CAAC;AAGtE,YAAM,aAAa,8BAA8B,YAAY;AAC7D,UAAI,CAAC,WAAW,SAAS;AACvB,cAAM,IAAI;AAAA,UACR,WAAW,OAAO,IAAI,OAAK,EAAE,OAAO,EAAE,KAAK,IAAI;AAAA,UAC/C;AAAA,QACF;AAAA,MACF;AAGA,UAAI,WAAW,SAAS,SAAS,KAAK,mBAAmB;AACvD,mBAAW,SAAS,QAAQ,aAAW;AACrC,0BAAgB;AAAA,YACd,MAAM;AAAA,YACN,SAAS,QAAQ;AAAA,YACjB,UAAU;AAAA,YACV,GAAI,QAAQ,cAAc;AAAA,cACxB,QAAQ,EAAE,OAAO,EAAE,2BAA2B,GAAG,SAAS,MAAM;AAAA,cAAC,EAAE;AAAA,YACrE;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAGA,qBAAe,QAAQ,WAAW,IAAI,EAAE,6BAA6B,CAAC;AACtE,YAAM,cAAc,MAAM,gBAAgB,MAAM,aAAa,YAAY;AAGzE,qBAAe,QAAQ,gBAAgB,IAAI,EAAE,kCAAkC,CAAC;AAChF,YAAM,kBAAkB,MAAM,qBAAqB,QAAQ,UAAU,aAAa,YAAY;AAG9F,qBAAe,QAAQ,cAAc,IAAI,EAAE,kCAAkC,CAAC;AAC9E,YAAM,kBAAkB,MAAM,mBAAmB,iBAAiB,aAAa,YAAY;AAE3F,qBAAe,QAAQ,YAAY,KAAK,EAAE,0BAA0B,CAAC;AAGrE,YAAM,aAAa,qBAAqB,QAAQ;AAAA,QAC9C;AAAA,MACF;AAEA,YAAM,SAA+B;AAAA,QACnC,cAAc;AAAA,QACd;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B,cAAc,aAAa;AAAA,QAC3B,cAAc,KAAK;AAAA,QACnB,iBAAiB,gBAAgB;AAAA,QACjC,UAAU;AAAA,UACR,gBAAgB,YAAY,IAAI,IAAI;AAAA,UACpC,wBAAwB;AAAA,YACtB,aAAa,aAAa,aAAa,YAAY,yBAAyB;AAAA,YAC5E,aAAa,uBAAuB,wBAAwB;AAAA,YAC5D,aAAa,iBAAiB,mBAAmB,0BAA0B;AAAA,UAC7E,EAAE,OAAO,OAAO;AAAA,UAChB,iBAAiB,aAAa,mBAAmB,CAAC;AAAA,UAClD,GAAI,aAAa,aAAa,aAAa,aAAa;AAAA,YACtD,sBAAsB;AAAA,cACpB,QAAQ,aAAa;AAAA,cACrB,QAAQ,aAAa;AAAA,cACrB,UAAU;AAAA;AAAA,YACZ;AAAA,UACF;AAAA,UACA,oBAAoB;AAAA,QACtB;AAAA,QACA,GAAI,aAAa,aAAa,aAAa,aAAa;AAAA,UACtD,gBAAgB;AAAA,YACd,WAAW,aAAa;AAAA,YACxB,WAAW,aAAa;AAAA,YACxB,wBAAwB;AAAA,YACxB,mBAAmB,WAAW;AAAA,UAChC;AAAA,QACF;AAAA,MACF;AAEA,iBAAW,UAAQ,CAAC,GAAG,MAAM,MAAM,CAAC;AACpC,aAAO;AAAA,IAET,SAAS,OAAO;AACd,YAAM,sBAAsB,iBAAiB,sBACzC,QACA,IAAI;AAAA,QACF,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC;AAAA,QACA;AAAA,MACF;AAEJ,kBAAY,mBAAmB;AAC/B,YAAM;AAAA,IAER,UAAE;AACA,wBAAkB,KAAK;AACvB,kBAAY,CAAC;AAAA,IACf;AAAA,EACF,GAAG,CAAC,gBAAgB,gBAAgB,aAAa,mBAAmB,CAAC,CAAC;AAEtE,QAAM,qBAAiB,0BAAY,OAAO,OAAe,iBAAiF;AACxI,UAAM,YAAY,YAAY,IAAI;AAClC,UAAM,eAAuC,CAAC;AAC9C,UAAM,cAAqC,CAAC;AAE5C,UAAM;AAAA,MACJ,oBAAoB,qBAAqB;AAAA,MACzC,cAAc;AAAA,MACd;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACL,IAAI;AAEJ,QAAI;AACF,wBAAkB,IAAI;AACtB,yBAAmB,UAAU,IAAI,gBAAgB;AAGjD,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,oBAAoB;AACzD,YAAI,mBAAmB,QAAQ,OAAO,SAAS;AAC7C;AAAA,QACF;AAEA,cAAM,QAAQ,MAAM,MAAM,GAAG,IAAI,kBAAkB;AACnD,cAAM,mBAAoB,IAAI,MAAM,UAAU,MAAM,SAAU;AAC9D,oBAAY,eAAe;AAE3B,cAAM,gBAAgB,MAAM,IAAI,OAAO,SAAS;AAC9C,cAAI;AACF,kBAAM,SAAS,MAAM,cAAc,MAAM,qBAAqB;AAC9D,yBAAa,KAAK,MAAM;AACxB,6BAAiB,MAAM;AACvB,mBAAO;AAAA,UACT,SAAS,OAAO;AACd,kBAAM,sBAAsB,iBAAiB,sBAAsB,QACjE,IAAI;AAAA,cACF,iBAAiB,QAAQ,MAAM,UAAU;AAAA,cACzC;AAAA,YACF;AAEF,wBAAY,KAAK,mBAAmB;AACpC,0BAAc,mBAAmB;AAEjC,gBAAI,aAAa;AACf,oBAAM;AAAA,YACR;AACA,mBAAO;AAAA,UACT;AAAA,QACF,CAAC;AAED,cAAM,QAAQ,IAAI,aAAa;AAAA,MACjC;AAEA,YAAM,cAAyC;AAAA,QAC7C,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,qBAAqB,YAAY,IAAI,IAAI;AAAA,QACzC,cAAc,aAAa;AAAA,QAC3B,YAAY,YAAY;AAAA,MAC1B;AAEA,mBAAa,YAAY;AAEzB,UAAI,mBAAmB;AACrB,wBAAgB;AAAA,UACd,MAAM;AAAA,UACN,SAAS,EAAE,iCAAiC;AAAA,YAC1C,YAAY,aAAa;AAAA,YACzB,OAAO,MAAM;AAAA,UACf,CAAC;AAAA,UACD,UAAU;AAAA,QACZ,CAAC;AAAA,MACH;AAEA,aAAO;AAAA,IAET,UAAE;AACA,wBAAkB,KAAK;AACvB,kBAAY,CAAC;AACb,yBAAmB,UAAU;AAAA,IAC/B;AAAA,EACF,GAAG,CAAC,eAAe,oBAAoB,YAAY,mBAAmB,CAAC,CAAC;AAExE,QAAM,2BAAuB,0BAAY,MAAM;AAC7C,QAAI,mBAAmB,SAAS;AAC9B,yBAAmB,QAAQ,MAAM;AACjC,wBAAkB,KAAK;AACvB,kBAAY,CAAC;AAEb,UAAI,mBAAmB;AACrB,wBAAgB;AAAA,UACd,MAAM;AAAA,UACN,SAAS,EAAE,0BAA0B;AAAA,QACvC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,GAAG,CAAC,mBAAmB,CAAC,CAAC;AAEzB,QAAM,mBAAe,0BAAY,MAAM;AACrC,eAAW,CAAC,CAAC;AACb,cAAU,CAAC,CAAC;AACZ,gBAAY,CAAC;AAAA,EACf,GAAG,CAAC,CAAC;AAEL,QAAM,sBAAkB,0BAAY,CAACC,aAAmE;AACtG,WAAO,8BAA8BA,QAAO;AAAA,EAC9C,GAAG,CAAC,CAAC;AAEL,QAAM,uBAAmB,0BAAY,OACnC,cACA,iBACG;AACH,UAAM,sBAAsB,uBAAuB,cAAc,YAAY;AAC7E,WAAO;AAAA,MACL,YAAY,oBAAoB,mBAAmB,oBAAoB;AAAA,MACvE,cAAc,oBAAoB;AAAA,MAClC,aAAa,oBAAoB;AAAA,IACnC;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAM,uBAAmB,0BAAY,OAAO,SAGtC;AACJ,UAAM,YAAY,KAAK,KAAK,MAAM,GAAG,EAAE,IAAI,GAAG,YAAY;AAC1D,UAAM,WAAW,KAAK;AAGtB,UAAM,YAA6C;AAAA,MACjD,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAEA,UAAM,iBAAiB,YAAY,UAAU,SAAS,IAAI;AAE1D,QAAI,gBAAgB;AAClB,aAAO;AAAA,QACL;AAAA,QACA,YAAY,SAAS,SAAS,aAAa,EAAE,IAAI,MAAM;AAAA,MACzD;AAAA,IACF;AAEA,WAAO;AAAA,MACL,gBAAgB;AAAA,MAChB,YAAY;AAAA,IACd;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAM,6BAAyB,0BAAY,OACzC,MACAA,aAKI;AACJ,UAAM,WAAqB,CAAC;AAG5B,QAAI,iBAAiB;AACrB,QAAI,YAAY;AAGhB,QAAIA,SAAQ,iBAAiB,SAASA,SAAQ,iBAAiB,WAAW;AACxE,uBAAiB;AACjB,kBAAY;AAAA,IACd,WAAWA,SAAQ,iBAAiB,SAASA,SAAQ,iBAAiB,WAAW;AAC/E,uBAAiB;AACjB,kBAAY;AAAA,IACd;AAGA,QAAIA,SAAQ,aAAaA,SAAQ,WAAW;AAC1C,mBAAa;AACb,eAAS,KAAK,EAAE,kDAAkD,CAAC;AAAA,IACrE;AAGA,QAAIA,SAAQ,iBAAiB,kBAAkB;AAC7C,mBAAa;AACb,wBAAkB;AAClB,eAAS,KAAK,EAAE,0CAA0C,CAAC;AAAA,IAC7D;AAEA,UAAM,aAAa,KAAK,QAAQ,OAAO;AACvC,UAAM,gBAAgB,KAAK,MAAM,KAAK,OAAO,cAAc;AAC3D,UAAM,gBAAgB,KAAK,MAAM,aAAa,SAAS;AAEvD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC,CAAC;AAEN,SAAO;AAAA;AAAA,IAEL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAGA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAGA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAGA,eAAe,gBAAgB,MAAY,QAA2C;AACpF,MAAI,WAAW,aAAa,WAAW,SAAS,WAAW,SAAS,WAAW,OAAO;AACpF,WAAO,KAAK,KAAK;AAAA,EACnB,OAAO;AACL,WAAO,KAAK,YAAY;AAAA,EAC1B;AACF;AAEA,eAAe,mBAAmB,MAAe,QAAwC;AACvF,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO,IAAI,KAAK,CAAC,IAAI,GAAG,EAAE,MAAM,kBAAkB,MAAM,EAAE,CAAC;AAAA,EAC7D,WAAW,gBAAgB,aAAa;AACtC,WAAO,IAAI,KAAK,CAAC,IAAI,GAAG,EAAE,MAAM,kBAAkB,MAAM,EAAE,CAAC;AAAA,EAC7D,OAAO;AACL,UAAM,aAAa,KAAK,UAAU,MAAM,MAAM,CAAC;AAC/C,WAAO,IAAI,KAAK,CAAC,UAAU,GAAG,EAAE,MAAM,kBAAkB,MAAM,EAAE,CAAC;AAAA,EACnE;AACF;AAEA,SAAS,kBAAkB,QAAiC;AAC1D,QAAM,YAA6C;AAAA,IACjD,WAAW;AAAA,IACX,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,aAAa;AAAA,IACb,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,WAAW;AAAA,IACX,gBAAgB;AAAA,EAClB;AAEA,SAAO,UAAU,MAAM,KAAK;AAC9B;","names":["proj4","progress","options"]}