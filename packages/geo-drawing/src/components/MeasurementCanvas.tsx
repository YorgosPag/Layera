import React, { useCallback, useEffect } from 'react';
import { Polygon, Polyline, CircleMarker, useMapEvents } from 'react-leaflet';
import L from 'leaflet';
import { useTheme } from '@layera/theme-switcher';
import { useMeasurement } from '../hooks/useMeasurement';
import { useGeometrySnap } from '../hooks/useGeometrySnap';
import type { MeasurementMode, CanvasInteractionEvent } from '../types';

interface MeasurementCanvasProps {\n  mode: MeasurementMode;\n  enableSnapping?: boolean;\n  onMeasurementChange?: (result: any) => void;\n  className?: string;\n}\n\n/**\n * Interactive measurement canvas component\n * Ενσωματώνει το measurement logic με snap-to-geometry functionality\n */\nexport const MeasurementCanvas: React.FC<MeasurementCanvasProps> = ({\n  mode,\n  enableSnapping = true,\n  onMeasurementChange,\n  className\n}) => {\n  const { theme } = useTheme();\n  const {\n    points,\n    state,\n    addPoint,\n    finishMeasurement,\n    cancelMeasurement,\n    changeMeasurementMode,\n    currentResult\n  } = useMeasurement();\n\n  const {\n    getSnappedPoint,\n    isSnappingEffective\n  } = useGeometrySnap(enableSnapping);\n\n  // Sync external mode changes\n  useEffect(() => {\n    changeMeasurementMode(mode);\n  }, [mode, changeMeasurementMode]);\n\n  // Notify parent of measurement changes\n  useEffect(() => {\n    if (currentResult && onMeasurementChange) {\n      onMeasurementChange(currentResult);\n    }\n  }, [currentResult, onMeasurementChange]);\n\n  // Handle map interactions\n  const mapEvents = useMapEvents({\n    click: useCallback((e: L.LeafletMouseEvent) => {\n      if (state === 'finished') return;\n\n      let latlng = e.latlng;\n      let snapped = false;\n      let snapResult;\n\n      // Apply snapping if enabled\n      if (enableSnapping && isSnappingEffective) {\n        const result = getSnappedPoint(e.latlng);\n        if (result.isSnapped && result.snappedLatLng) {\n          latlng = result.snappedLatLng;\n          snapped = true;\n          snapResult = {\n            snapPoint: result.snapPoint!,\n            snapType: result.snapType as 'vertex' | 'edge'\n          };\n        }\n      }\n\n      // Create interaction event\n      const interactionEvent: CanvasInteractionEvent = {\n        type: 'click',\n        latlng,\n        originalEvent: e.originalEvent,\n        snapped,\n        snapResult\n      };\n\n      addPoint(latlng);\n    }, [state, enableSnapping, isSnappingEffective, getSnappedPoint, addPoint]),\n\n    dblclick: useCallback((e: L.LeafletMouseEvent) => {\n      e.originalEvent.preventDefault();\n      e.originalEvent.stopPropagation();\n      \n      if (state === 'drawing' && mode !== 'point') {\n        finishMeasurement();\n      }\n    }, [state, mode, finishMeasurement]),\n\n    keydown: useCallback((e: L.LeafletKeyboardEvent) => {\n      if (e.originalEvent.key === 'Escape' && state === 'drawing') {\n        cancelMeasurement();\n      }\n    }, [state, cancelMeasurement])\n  });\n\n  // Get theme-aware colors\n  const getColors = useCallback(() => {\n    const isDark = theme === 'dark';\n    return {\n      line: isDark ? '#60a5fa' : '#3b82f6',\n      fill: isDark ? 'rgba(96, 165, 250, 0.2)' : 'rgba(59, 130, 246, 0.2)',\n      point: isDark ? '#f59e0b' : '#d97706',\n      pointBorder: isDark ? '#1f2937' : '#ffffff'\n    };\n  }, [theme]);\n\n  const colors = getColors();\n\n  // Render measurement geometry\n  const renderGeometry = () => {\n    if (points.length === 0) return null;\n\n    const latlngs = points.map(p => p.latlng);\n\n    return (\n      <>\n        {/* Render points */}\n        {points.map((point, index) => (\n          <CircleMarker\n            key={point.id}\n            center={point.latlng}\n            radius={6}\n            pathOptions={{\n              color: colors.pointBorder,\n              fillColor: colors.point,\n              fillOpacity: 1,\n              weight: 2\n            }}\n          />\n        ))}\n\n        {/* Render lines for distance mode or area outline */}\n        {((mode === 'distance' || mode === 'area') && latlngs.length >= 2) && (\n          <Polyline\n            positions={latlngs}\n            pathOptions={{\n              color: colors.line,\n              weight: 3,\n              opacity: 0.8,\n              dashArray: state === 'drawing' ? '5, 5' : undefined\n            }}\n          />\n        )}\n\n        {/* Render polygon fill for area mode */}\n        {(mode === 'area' && latlngs.length >= 3 && state === 'finished') && (\n          <Polygon\n            positions={latlngs}\n            pathOptions={{\n              color: colors.line,\n              fillColor: colors.fill,\n              fillOpacity: 0.3,\n              weight: 2\n            }}\n          />\n        )}\n      </>\n    );\n  };\n\n  return (\n    <div className={className}>\n      {renderGeometry()}\n    </div>\n  );\n};