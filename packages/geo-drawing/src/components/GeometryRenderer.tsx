import React, { useMemo } from 'react';\nimport { Polygon, Polyline, CircleMarker, Popup } from 'react-leaflet';\nimport L from 'leaflet';\nimport { useTheme } from '@layera/theme-switcher';\nimport { Typography } from '@layera/typography';\nimport { useTranslation } from 'react-i18next';\nimport type { MeasurementResult, OSMBuildingFeature } from '../types';\nimport { extractOSMGeometry } from '../utils/geometry';\nimport { useMeasurementFormatter } from '../utils/formatters';\n\ninterface GeometryRendererProps {\n  measurements?: MeasurementResult[];\n  osmFeatures?: OSMBuildingFeature[];\n  showOSMBuildings?: boolean;\n  showMeasurements?: boolean;\n  onMeasurementClick?: (measurement: MeasurementResult) => void;\n  onBuildingClick?: (feature: OSMBuildingFeature) => void;\n}\n\n/**\n * Renders various geometric elements on the map\n * Υποστηρίζει measurement results και OSM building outlines\n */\nexport const GeometryRenderer: React.FC<GeometryRendererProps> = ({\n  measurements = [],\n  osmFeatures = [],\n  showOSMBuildings = true,\n  showMeasurements = true,\n  onMeasurementClick,\n  onBuildingClick\n}) => {\n  const { theme } = useTheme();\n  const { t } = useTranslation();\n  const { formatDistanceWithLabels, formatAreaWithLabels } = useMeasurementFormatter();\n\n  // Get theme-aware colors\n  const colors = useMemo(() => {\n    const isDark = theme === 'dark';\n    return {\n      // Measurement colors\n      measurementLine: isDark ? '#10b981' : '#059669',\n      measurementFill: isDark ? 'rgba(16, 185, 129, 0.2)' : 'rgba(5, 150, 105, 0.2)',\n      measurementPoint: isDark ? '#f59e0b' : '#d97706',\n      \n      // OSM building colors\n      buildingLine: isDark ? '#6b7280' : '#9ca3af',\n      buildingFill: isDark ? 'rgba(107, 114, 128, 0.1)' : 'rgba(156, 163, 175, 0.1)',\n      buildingHover: isDark ? '#374151' : '#d1d5db',\n      \n      // Border colors\n      border: isDark ? '#1f2937' : '#ffffff'\n    };\n  }, [theme]);\n\n  // Render OSM building outlines\n  const renderOSMBuildings = () => {\n    if (!showOSMBuildings || osmFeatures.length === 0) return null;\n\n    return osmFeatures.map((feature, index) => {\n      const polygons = extractOSMGeometry(feature);\n      \n      return polygons.map((polygon, polygonIndex) => {\n        const key = `building-${index}-${polygonIndex}`;\n        \n        return (\n          <Polygon\n            key={key}\n            positions={polygon}\n            pathOptions={{\n              color: colors.buildingLine,\n              fillColor: colors.buildingFill,\n              fillOpacity: 0.1,\n              weight: 1,\n              opacity: 0.6\n            }}\n            eventHandlers={{\n              click: () => onBuildingClick?.(feature),\n              mouseover: (e) => {\n                e.target.setStyle({\n                  fillColor: colors.buildingHover,\n                  fillOpacity: 0.3\n                });\n              },\n              mouseout: (e) => {\n                e.target.setStyle({\n                  fillColor: colors.buildingFill,\n                  fillOpacity: 0.1\n                });\n              }\n            }}\n          >\n            {feature.properties.name && (\n              <Popup>\n                <div>\n                  <Typography variant=\"subtitle\" className=\"font-semibold\">\n                    {feature.properties.name}\n                  </Typography>\n                  {feature.properties.building && (\n                    <Typography variant=\"caption\" className=\"text-gray-600\">\n                      {t('geo-drawing.building-type')}: {feature.properties.building}\n                    </Typography>\n                  )}\n                  {feature.properties['addr:street'] && (\n                    <Typography variant=\"caption\" className=\"text-gray-600\">\n                      {feature.properties['addr:street']} {feature.properties['addr:housenumber']}\n                    </Typography>\n                  )}\n                </div>\n              </Popup>\n            )}\n          </Polygon>\n        );\n      });\n    });\n  };\n\n  // Render measurement results\n  const renderMeasurements = () => {\n    if (!showMeasurements || measurements.length === 0) return null;\n\n    return measurements.map((measurement) => {\n      const latlngs = measurement.points.map(p => p.latlng);\n      const key = `measurement-${measurement.timestamp}`;\n\n      return (\n        <React.Fragment key={key}>\n          {/* Render measurement points */}\n          {measurement.points.map((point, index) => (\n            <CircleMarker\n              key={`${key}-point-${index}`}\n              center={point.latlng}\n              radius={5}\n              pathOptions={{\n                color: colors.border,\n                fillColor: colors.measurementPoint,\n                fillOpacity: 1,\n                weight: 2\n              }}\n              eventHandlers={{\n                click: () => onMeasurementClick?.(measurement)\n              }}\n            >\n              <Popup>\n                <div>\n                  <Typography variant=\"subtitle\" className=\"font-semibold\">\n                    {t('geo-drawing.point-info', { index: index + 1 })}\n                  </Typography>\n                  <Typography variant=\"caption\">\n                    {point.latlng.lat.toFixed(6)}, {point.latlng.lng.toFixed(6)}\n                  </Typography>\n                </div>\n              </Popup>\n            </CircleMarker>\n          ))}\n\n          {/* Render lines for distance/area measurements */}\n          {((measurement.type === 'distance' || measurement.type === 'area') && latlngs.length >= 2) && (\n            <Polyline\n              positions={latlngs}\n              pathOptions={{\n                color: colors.measurementLine,\n                weight: 3,\n                opacity: 0.8\n              }}\n              eventHandlers={{\n                click: () => onMeasurementClick?.(measurement)\n              }}\n            >\n              <Popup>\n                <div>\n                  <Typography variant=\"subtitle\" className=\"font-semibold\">\n                    {t(`geo-drawing.modes.${measurement.type}`)}\n                  </Typography>\n                  <Typography variant=\"body\">\n                    {measurement.displayValue}\n                  </Typography>\n                  <Typography variant=\"caption\" className=\"text-gray-600\">\n                    {new Date(measurement.timestamp).toLocaleString()}\n                  </Typography>\n                </div>\n              </Popup>\n            </Polyline>\n          )}\n\n          {/* Render polygon fill for area measurements */}\n          {(measurement.type === 'area' && latlngs.length >= 3) && (\n            <Polygon\n              positions={latlngs}\n              pathOptions={{\n                color: colors.measurementLine,\n                fillColor: colors.measurementFill,\n                fillOpacity: 0.3,\n                weight: 2\n              }}\n              eventHandlers={{\n                click: () => onMeasurementClick?.(measurement)\n              }}\n            >\n              <Popup>\n                <div>\n                  <Typography variant=\"subtitle\" className=\"font-semibold\">\n                    {t('geo-drawing.area-measurement')}\n                  </Typography>\n                  <Typography variant=\"body\">\n                    {measurement.area && formatAreaWithLabels(measurement.area)}\n                  </Typography>\n                  <Typography variant=\"caption\" className=\"text-gray-600\">\n                    {t('geo-drawing.points-count', { count: measurement.points.length })}\n                  </Typography>\n                </div>\n              </Popup>\n            </Polygon>\n          )}\n        </React.Fragment>\n      );\n    });\n  };\n\n  return (\n    <>\n      {renderOSMBuildings()}\n      {renderMeasurements()}\n    </>\n  );\n};