{"version":3,"sources":["../src/hooks/useMeasurement.ts","../src/utils/calculations.ts","../src/utils/formatters.ts","../src/hooks/useGeometrySnap.ts","../src/services/osmService.ts","../src/utils/geometry.ts","../src/components/MeasurementControls.tsx","../src/components/MeasurementCanvas.tsx","../src/components/GeometryRenderer.tsx","../src/index.ts"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\nimport L from 'leaflet';\nimport { useLayeraTranslation } from '@layera/i18n';\nimport type { MeasurementMode, MeasurementPoint, MeasurementResult, DrawingState } from '../types';\nimport { calculateDistance, calculateProjectedArea } from '../utils/calculations';\nimport { useMeasurementFormatter } from '../utils/formatters';\nimport { useNotifications } from '@layera/notifications';\n\n/**\n * Core measurement hook για το geo-drawing system\n * Μεταφέρθηκε και βελτιώθηκε από OLD_geo-canvas\n */\nexport const useMeasurement = () => {\n  const { t } = useLayeraTranslation();\n  const { addNotification } = useNotifications();\n  const { formatDistanceWithLabels, formatAreaWithLabels } = useMeasurementFormatter();\n\n  const [mode, setMode] = useState<MeasurementMode>('distance');\n  const [state, setState] = useState<DrawingState>('idle');\n  const [points, setPoints] = useState<MeasurementPoint[]>([]);\n  const [currentResult, setCurrentResult] = useState<MeasurementResult | null>(null);\n  const [results, setResults] = useState<MeasurementResult[]>([]);\n\n  const pointIdCounter = useRef(0);\n\n  /**\n   * Adds a new measurement point\n   */\n  const addPoint = useCallback((latlng: L.LatLng) => {\n    const newPoint: MeasurementPoint = {\n      id: `point-${pointIdCounter.current++}`,\n      latlng,\n      index: points.length\n    };\n\n    const updatedPoints = [...points, newPoint];\n    setPoints(updatedPoints);\n\n    // Start drawing state on first point\n    if (points.length === 0) {\n      setState('drawing');\n    }\n\n    // Calculate current measurement\n    let distance = 0;\n    let area = 0;\n    let displayValue = '';\n\n    if (mode === 'distance' && updatedPoints.length >= 2) {\n      const latlngs = updatedPoints.map(p => p.latlng);\n      distance = calculateDistance(latlngs);\n      displayValue = formatDistanceWithLabels(distance);\n    } else if (mode === 'area' && updatedPoints.length >= 3) {\n      const latlngs = updatedPoints.map(p => p.latlng);\n      area = calculateProjectedArea(latlngs);\n      displayValue = formatAreaWithLabels(area);\n    } else if (mode === 'point') {\n      displayValue = `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;\n    }\n\n    const result: MeasurementResult = {\n      type: mode,\n      points: updatedPoints,\n      ...(mode === 'distance' && distance !== undefined && { distance }),\n      ...(mode === 'area' && area !== undefined && { area }),\n      displayValue,\n      timestamp: Date.now()\n    };\n\n    setCurrentResult(result);\n  }, [points, mode, formatDistanceWithLabels, formatAreaWithLabels]);\n\n  /**\n   * Finishes the current measurement\n   */\n  const finishMeasurement = useCallback(() => {\n    if (!currentResult) return;\n\n    // Validation based on mode\n    if (mode === 'distance' && points.length < 2) {\n      addNotification({\n        type: 'error',\n        message: t('geo-drawing.errors.minimum-points-distance')\n      });\n      return;\n    }\n\n    if (mode === 'area' && points.length < 3) {\n      addNotification({\n        type: 'error',\n        message: t('geo-drawing.errors.minimum-points-area')\n      });\n      return;\n    }\n\n    setResults(prev => [...prev, currentResult]);\n    setState('finished');\n\n    addNotification({\n      type: 'success',\n      message: t('geo-drawing.measurement-completed', {\n        type: t(`geo-drawing.modes.${mode}`),\n        value: currentResult.displayValue\n      })\n    });\n  }, [currentResult, mode, points.length, addNotification, t]);\n\n  /**\n   * Cancels the current measurement\n   */\n  const cancelMeasurement = useCallback(() => {\n    setPoints([]);\n    setCurrentResult(null);\n    setState('idle');\n  }, []);\n\n  /**\n   * Resets all measurements\n   */\n  const resetAll = useCallback(() => {\n    setPoints([]);\n    setCurrentResult(null);\n    setResults([]);\n    setState('idle');\n    pointIdCounter.current = 0;\n  }, []);\n\n  /**\n   * Changes measurement mode\n   */\n  const changeMeasurementMode = useCallback((newMode: MeasurementMode) => {\n    if (state === 'drawing') {\n      // Ask user confirmation if currently drawing\n      if (window.confirm(t('geo-drawing.confirm-mode-change'))) {\n        cancelMeasurement();\n        setMode(newMode);\n      }\n    } else {\n      setMode(newMode);\n    }\n  }, [state, cancelMeasurement, t]);\n\n  /**\n   * Removes the last point\n   */\n  const removeLastPoint = useCallback(() => {\n    if (points.length === 0) return;\n\n    const updatedPoints = points.slice(0, -1);\n    setPoints(updatedPoints);\n\n    if (updatedPoints.length === 0) {\n      setState('idle');\n      setCurrentResult(null);\n    } else {\n      // Recalculate measurement\n      let distance = 0;\n      let area = 0;\n      let displayValue = '';\n\n      if (mode === 'distance' && updatedPoints.length >= 2) {\n        const latlngs = updatedPoints.map(p => p.latlng);\n        distance = calculateDistance(latlngs);\n        displayValue = formatDistanceWithLabels(distance);\n      } else if (mode === 'area' && updatedPoints.length >= 3) {\n        const latlngs = updatedPoints.map(p => p.latlng);\n        area = calculateProjectedArea(latlngs);\n        displayValue = formatAreaWithLabels(area);\n      }\n\n      const result: MeasurementResult = {\n        type: mode,\n        points: updatedPoints,\n        ...(mode === 'distance' && distance !== undefined && { distance }),\n        ...(mode === 'area' && area !== undefined && { area }),\n        displayValue,\n        timestamp: Date.now()\n      };\n\n      setCurrentResult(result);\n    }\n  }, [points, mode, formatDistanceWithLabels, formatAreaWithLabels]);\n\n  /**\n   * Removes a specific measurement result\n   */\n  const removeResult = useCallback((timestamp: number) => {\n    setResults(prev => prev.filter(result => result.timestamp !== timestamp));\n  }, []);\n\n  /**\n   * Gets current distance (for display during drawing)\n   */\n  const getCurrentDistance = useCallback((): number => {\n    if (points.length < 2) return 0;\n    const latlngs = points.map(p => p.latlng);\n    return calculateDistance(latlngs);\n  }, [points]);\n\n  /**\n   * Gets current area (for display during drawing)\n   */\n  const getCurrentArea = useCallback((): number => {\n    if (points.length < 3) return 0;\n    const latlngs = points.map(p => p.latlng);\n    return calculateProjectedArea(latlngs);\n  }, [points]);\n\n  return {\n    // State\n    mode,\n    state,\n    points,\n    currentResult,\n    results,\n\n    // Actions\n    addPoint,\n    finishMeasurement,\n    cancelMeasurement,\n    resetAll,\n    changeMeasurementMode,\n    removeLastPoint,\n    removeResult,\n\n    // Computed values\n    getCurrentDistance,\n    getCurrentArea,\n    isDrawing: state === 'drawing',\n    isFinished: state === 'finished',\n    canFinish: (mode === 'distance' && points.length >= 2) ||\n               (mode === 'area' && points.length >= 3) ||\n               (mode === 'point' && points.length >= 1)\n  };\n};","import L from 'leaflet';\n\n/**\n * Calculates the area of a polygon using the Shoelace formula on projected coordinates.\n * Μεταφέρθηκε από OLD_geo-canvas/components/utils/measurementUtils.ts\n * @param latlngs An array of L.LatLng points for the polygon.\n * @returns The calculated area in square meters.\n */\nexport const calculateProjectedArea = (latlngs: L.LatLng[]): number => {\n  if (latlngs.length < 3) return 0;\n\n  // Project points to a cartesian plane (meters) using Web Mercator projection\n  const map = L.CRS.EPSG3857;\n  const points = latlngs.map(latlng => map.project(latlng));\n\n  let area = 0;\n  const n = points.length;\n  for (let i = 0; i < n; i++) {\n    const p1 = points[i];\n    const p2 = points[(i + 1) % n];\n    area += p1.x * p2.y - p2.x * p1.y;\n  }\n\n  return Math.abs(area / 2.0);\n};\n\n/**\n * Calculates the total path distance for a series of points.\n * Μεταφέρθηκε από OLD_geo-canvas/components/utils/measurementUtils.ts\n * @param latlngs An array of L.LatLng points.\n * @returns The total distance in meters.\n */\nexport const calculateDistance = (latlngs: L.LatLng[]): number => {\n  if (latlngs.length < 2) {\n    return 0;\n  }\n\n  let totalDistance = 0;\n  for (let i = 0; i < latlngs.length - 1; i++) {\n    totalDistance += latlngs[i].distanceTo(latlngs[i + 1]);\n  }\n  return totalDistance;\n};\n\n/**\n * Calculates the distance between two LatLng points using Haversine formula\n * @param point1 First point\n * @param point2 Second point\n * @returns Distance in meters\n */\nexport const calculatePointDistance = (point1: L.LatLng, point2: L.LatLng): number => {\n  return point1.distanceTo(point2);\n};\n\n/**\n * Calculates the center point of a polygon\n * @param latlngs Array of polygon vertices\n * @returns Center point as LatLng\n */\nexport const calculatePolygonCenter = (latlngs: L.LatLng[]): L.LatLng => {\n  if (latlngs.length === 0) {\n    throw new Error('Cannot calculate center of empty polygon');\n  }\n\n  let latSum = 0;\n  let lngSum = 0;\n\n  for (const point of latlngs) {\n    latSum += point.lat;\n    lngSum += point.lng;\n  }\n\n  return L.latLng(latSum / latlngs.length, lngSum / latlngs.length);\n};\n\n/**\n * Calculates the perimeter of a polygon\n * @param latlngs Array of polygon vertices\n * @returns Perimeter in meters\n */\nexport const calculatePerimeter = (latlngs: L.LatLng[]): number => {\n  if (latlngs.length < 2) return 0;\n\n  // Close the polygon by adding the first point at the end\n  const closedPolygon = [...latlngs, latlngs[0]];\n  return calculateDistance(closedPolygon);\n};\n\n/**\n * Checks if a point is inside a polygon using ray casting algorithm\n * @param point Point to test\n * @param polygon Array of polygon vertices\n * @returns True if point is inside polygon\n */\nexport const isPointInPolygon = (point: L.LatLng, polygon: L.LatLng[]): boolean => {\n  let inside = false;\n  const x = point.lng;\n  const y = point.lat;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].lng;\n    const yi = polygon[i].lat;\n    const xj = polygon[j].lng;\n    const yj = polygon[j].lat;\n\n    if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\n/**\n * Calculates the bounding box of a set of points\n * @param latlngs Array of points\n * @returns Leaflet LatLngBounds object\n */\nexport const calculateBounds = (latlngs: L.LatLng[]): L.LatLngBounds => {\n  if (latlngs.length === 0) {\n    throw new Error('Cannot calculate bounds of empty point array');\n  }\n\n  return L.latLngBounds(latlngs);\n};","import { useLayeraTranslation } from '@layera/i18n';\n\n/**\n * Formats a distance in meters into a readable string, switching to kilometers for large distances.\n * Μεταφέρθηκε από OLD_geo-canvas/components/utils/measurementUtils.ts\n * @param meters The distance in meters.\n * @param decimals The number of decimal places to show.\n * @returns A formatted string like \"500.00 m\" or \"1.20 km\".\n */\nexport const formatDistance = (meters: number, decimals: number = 2): string => {\n  if (meters === 0) return '0 m';\n  if (meters >= 1000) {\n    return `${(meters / 1000).toFixed(decimals)} km`;\n  }\n  return `${meters.toFixed(decimals)} m`;\n};\n\n/**\n * Formats an area in square meters into a readable string, switching to hectares or square kilometers.\n * Μεταφέρθηκε από OLD_geo-canvas/components/utils/measurementUtils.ts\n * @param sqMeters The area in square meters.\n * @returns A formatted string like \"500.00 m²\" or \"1.20 ha\".\n */\nexport const formatArea = (sqMeters: number): string => {\n  if (sqMeters === 0) return '0 m²';\n  if (sqMeters >= 1000000) {\n    return `${(sqMeters / 1000000).toFixed(2)} km²`;\n  }\n  if (sqMeters >= 10000) {\n    return `${(sqMeters / 10000).toFixed(2)} ha`;\n  }\n  return `${sqMeters.toFixed(2)} m²`;\n};\n\n/**\n * Hook for formatted measurement display with i18n support\n * Αντικαθιστά τα hardcoded strings με i18n keys\n */\nexport const useMeasurementFormatter = () => {\n  const { t } = useLayeraTranslation();\n\n  const formatDistanceWithLabels = (meters: number, decimals: number = 2): string => {\n    if (meters === 0) return `0 ${t('geo-drawing.units.meters')}`;\n    if (meters >= 1000) {\n      return `${(meters / 1000).toFixed(decimals)} ${t('geo-drawing.units.kilometers')}`;\n    }\n    return `${meters.toFixed(decimals)} ${t('geo-drawing.units.meters')}`;\n  };\n\n  const formatAreaWithLabels = (sqMeters: number): string => {\n    if (sqMeters === 0) return `0 ${t('geo-drawing.units.square-meters')}`;\n    if (sqMeters >= 1000000) {\n      return `${(sqMeters / 1000000).toFixed(2)} ${t('geo-drawing.units.square-kilometers')}`;\n    }\n    if (sqMeters >= 10000) {\n      return `${(sqMeters / 10000).toFixed(2)} ${t('geo-drawing.units.hectares')}`;\n    }\n    return `${sqMeters.toFixed(2)} ${t('geo-drawing.units.square-meters')}`;\n  };\n\n  const formatCoordinates = (lat: number, lng: number, decimals: number = 6): string => {\n    return `${lat.toFixed(decimals)}, ${lng.toFixed(decimals)}`;\n  };\n\n  const formatPointLabel = (index: number): string => {\n    return t('geo-drawing.point-label', { index: index + 1 });\n  };\n\n  return {\n    formatDistanceWithLabels,\n    formatAreaWithLabels,\n    formatCoordinates,\n    formatPointLabel,\n    // Backward compatibility exports\n    formatDistance,\n    formatArea\n  };\n};\n\n/**\n * Formats coordinates to different coordinate systems\n */\nexport const formatCoordinatesBySystem = (\n  lat: number,\n  lng: number,\n  system: 'WGS84' | 'EGSA87' | 'UTM' = 'WGS84',\n  decimals: number = 6\n): string => {\n  switch (system) {\n    case 'WGS84':\n      return `${lat.toFixed(decimals)}°N, ${lng.toFixed(decimals)}°E`;\n    case 'EGSA87':\n      // Basic conversion placeholder - would need proper transformation\n      return `X: ${lng.toFixed(2)}, Y: ${lat.toFixed(2)} (ΕΓΣΑ87)`;\n    case 'UTM':\n      // Basic UTM formatting placeholder\n      return `UTM: ${lng.toFixed(0)}E, ${lat.toFixed(0)}N`;\n    default:\n      return `${lat.toFixed(decimals)}, ${lng.toFixed(decimals)}`;\n  }\n};\n\n/**\n * Formats bearing/azimuth between two points\n * @param bearing Bearing in degrees\n * @returns Formatted bearing string\n */\nexport const formatBearing = (bearing: number): string => {\n  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];\n  const index = Math.round(bearing / 45) % 8;\n  return `${bearing.toFixed(1)}° (${directions[index]})`;\n};","import { useState, useEffect, useCallback, useRef } from 'react';\nimport L from 'leaflet';\nimport { useMap } from 'react-leaflet';\nimport { useSnapEngine } from '@layera/snap-interactions';\nimport type { GeoJSONFeatureCollection, OSMBuildingFeature } from '../types';\nimport { fetchBuildingOutlines } from '../services/osmService';\nimport { extractOSMGeometry } from '../utils/geometry';\nimport { CONFIG } from '@layera/constants';\n\n/**\n * Hook που ενσωματώνει το snap-to-geometry με OSM building data\n * Βασισμένο στο OLD_geo-canvas/packages/app/src/hooks/useSnapping.ts\n * αλλά χρησιμοποιεί το νέο @layera/snap-engine LEGO system\n */\nexport const useGeometrySnap = (isEnabled: boolean = true) => {\n  const map = useMap();\n  const [osmData, setOsmData] = useState<GeoJSONFeatureCollection | null>(null);\n  const [isSnappingEffective, setIsSnappingEffective] = useState(false);\n  const timeoutRef = useRef<number | null>(null);\n\n  // Initialize snap engine με OSM-specific configuration\n  const snapEngine = useSnapEngine({\n    tolerance: CONFIG.geoDrawing.snapTolerance,\n    enabledTypes: new Set(['vertex', 'edge', 'center', 'nearest']),\n    spatialIndexing: true\n  });\n\n  // Effect για fetching OSM data όταν ο χάρτης κινείται\n  useEffect(() => {\n    const fetchData = async () => {\n      const currentZoom = map.getZoom();\n      if (!isEnabled || currentZoom < CONFIG.geoDrawing.minSnapZoom) {\n        setOsmData(null);\n        setIsSnappingEffective(false);\n        snapEngine.clearGeometries();\n        return;\n      }\n\n      setIsSnappingEffective(true);\n      try {\n        const geojson = await fetchBuildingOutlines(map.getBounds());\n        setOsmData(geojson);\n\n        // Convert OSM features to geometries για το snap engine\n        const geometries: L.LatLng[][] = [];\n        geojson.features.forEach((feature: OSMBuildingFeature) => {\n          const polygons = extractOSMGeometry(feature);\n          geometries.push(...polygons);\n        });\n\n        // Update snap engine με νέα geometries\n        snapEngine.setGeometries(geometries);\n      } catch (error) {\n        console.warn('Failed to fetch OSM data for snapping:', error);\n        setOsmData(null);\n        setIsSnappingEffective(false);\n      }\n    };\n\n    const handleMoveEnd = () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      // Debounce the fetch request to avoid spamming the API\n      timeoutRef.current = window.setTimeout(fetchData, CONFIG.geoDrawing.debounceMs);\n    };\n\n    map.on('moveend zoomend', handleMoveEnd);\n    fetchData(); // Initial check/fetch for the current view\n\n    return () => {\n      map.off('moveend zoomend', handleMoveEnd);\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      setIsSnappingEffective(false);\n      snapEngine.clearGeometries();\n    };\n  }, [map, isEnabled, snapEngine]);\n\n  /**\n   * Performs snapping calculation για ένα cursor point\n   * @param latlng Original cursor position\n   * @returns Snap result with snapped position\n   */\n  const getSnappedPoint = useCallback((latlng: L.LatLng) => {\n    if (!isEnabled || !isSnappingEffective || map.getZoom() < CONFIG.geoDrawing.minSnapZoom) {\n      return {\n        snappedLatLng: latlng,\n        snapPoint: null,\n        snapType: null,\n        isSnapped: false\n      };\n    }\n\n    return snapEngine.snapToPoint(latlng);\n  }, [isEnabled, isSnappingEffective, map, snapEngine]);\n\n  /**\n   * Snap σε κοντινότερο vertex\n   */\n  const snapToVertex = useCallback((latlng: L.LatLng) => {\n    if (!isEnabled || !isSnappingEffective) {\n      return { snappedLatLng: latlng, snapPoint: null, isSnapped: false };\n    }\n\n    return snapEngine.snapToVertex(latlng);\n  }, [isEnabled, isSnappingEffective, snapEngine]);\n\n  /**\n   * Snap σε κοντινότερο edge\n   */\n  const snapToEdge = useCallback((latlng: L.LatLng) => {\n    if (!isEnabled || !isSnappingEffective) {\n      return { snappedLatLng: latlng, snapPoint: null, isSnapped: false };\n    }\n\n    return snapEngine.snapToEdge(latlng);\n  }, [isEnabled, isSnappingEffective, snapEngine]);\n\n  /**\n   * Enables/disables specific snap types\n   */\n  const setSnapTypes = useCallback((types: Set<string>) => {\n    snapEngine.setEnabledTypes(types);\n  }, [snapEngine]);\n\n  /**\n   * Updates snap tolerance\n   */\n  const setSnapTolerance = useCallback((tolerance: number) => {\n    snapEngine.setTolerance(tolerance);\n  }, [snapEngine]);\n\n  /**\n   * Gets building information at a point\n   */\n  const getBuildingInfo = useCallback((latlng: L.LatLng) => {\n    if (!osmData) return null;\n\n    for (const feature of osmData.features) {\n      const polygons = extractOSMGeometry(feature);\n      for (const polygon of polygons) {\n        // Simple point-in-polygon check\n        let inside = false;\n        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n          if (((polygon[i].lat > latlng.lat) !== (polygon[j].lat > latlng.lat)) &&\n              (latlng.lng < (polygon[j].lng - polygon[i].lng) * (latlng.lat - polygon[i].lat) / (polygon[j].lat - polygon[i].lat) + polygon[i].lng)) {\n            inside = !inside;\n          }\n        }\n        if (inside) {\n          return feature.properties;\n        }\n      }\n    }\n    return null;\n  }, [osmData]);\n\n  return {\n    // State\n    isSnappingEffective,\n    osmData,\n    snapEngine,\n\n    // Snap functions\n    getSnappedPoint,\n    snapToVertex,\n    snapToEdge,\n\n    // Configuration\n    setSnapTypes,\n    setSnapTolerance,\n\n    // Utility\n    getBuildingInfo,\n\n    // Backward compatibility με το παλιό API\n    snappingData: osmData\n  };\n};","import L from 'leaflet';\nimport type { GeoJSONFeatureCollection } from '../types';\nimport { CONFIG } from '@layera/constants';\n\n// OSM Service για fetching building outlines\n// Μεταφέρθηκε από OLD_geo-canvas/packages/app/src/services/osmService.ts\n\n// Declare the osmtogeojson library loaded from a script tag in index.html\ndeclare const osmtogeojson: (data: any) => GeoJSONFeatureCollection;\n\n// Simple in-memory cache to avoid redundant API calls\nconst cache = new Map<string, GeoJSONFeatureCollection>();\n\n/**\n * Fetches building outlines from the OpenStreetMap Overpass API for a given map bounds.\n * @param bounds The Leaflet LatLngBounds for which to fetch data.\n * @returns A promise that resolves with a GeoJSON FeatureCollection of building polygons.\n */\nexport const fetchBuildingOutlines = async (bounds: L.LatLngBounds): Promise<GeoJSONFeatureCollection> => {\n  // Create a key for the cache, rounding coordinates to group close-by requests\n  const boundsStr = `${bounds.getSouth().toFixed(4)},${bounds.getWest().toFixed(4)},${bounds.getNorth().toFixed(4)},${bounds.getEast().toFixed(4)}`;\n\n  if (cache.has(boundsStr)) {\n    return Promise.resolve(cache.get(boundsStr)!);\n  }\n\n  const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;\n  const query = `\n    [out:json][timeout:${CONFIG.osm.requestTimeout / 1000}];\n    (\n      node[\"building\"](${bbox});\n      way[\"building\"](${bbox});\n      relation[\"building\"](${bbox});\n    );\n    out body;\n    >;\n    out skel qt;\n  `;\n\n  try {\n    const response = await fetch(CONFIG.osm.overpassApiUrl, {\n      method: 'POST',\n      body: `data=${encodeURIComponent(query)}`,\n    });\n\n    if (!response.ok) {\n      // Don't pollute console for common errors like 429 Too Many Requests\n      if (response.status !== 429 && response.status !== 504) {\n        console.error(`Overpass API error: ${response.statusText}`);\n      }\n      throw new Error(`Network response was not ok: ${response.statusText}`);\n    }\n\n    const osmData = await response.json();\n    const geojson = osmtogeojson(osmData) as GeoJSONFeatureCollection;\n\n    // FIX: Also include MultiPolygons, as complex buildings are often represented this way.\n    // This is the primary fix for snapping appearing to not work in some areas.\n    geojson.features = geojson.features.filter(f =>\n      f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon')\n    );\n\n    cache.set(boundsStr, geojson);\n    return geojson;\n  } catch (error) {\n    // Silently fail to avoid interrupting user experience\n    return { type: 'FeatureCollection', features: [] };\n  }\n};\n\n/**\n * Clears the OSM data cache\n */\nexport const clearOSMCache = (): void => {\n  cache.clear();\n};\n\n/**\n * Gets the current cache size\n * @returns Number of cached entries\n */\nexport const getCacheSize = (): number => {\n  return cache.size;\n};\n\n/**\n * Checks if bounds are cached\n * @param bounds Bounds to check\n * @returns True if bounds are in cache\n */\nexport const isBoundsCached = (bounds: L.LatLngBounds): boolean => {\n  const boundsStr = `${bounds.getSouth().toFixed(4)},${bounds.getWest().toFixed(4)},${bounds.getNorth().toFixed(4)},${bounds.getEast().toFixed(4)}`;\n  return cache.has(boundsStr);\n};\n\n/**\n * Prefetches OSM data for given bounds without returning the data\n * Useful for preloading nearby areas\n * @param bounds Bounds to prefetch\n */\nexport const prefetchBuildingOutlines = async (bounds: L.LatLngBounds): Promise<void> => {\n  try {\n    await fetchBuildingOutlines(bounds);\n  } catch (error) {\n    // Silently fail for prefetch operations\n  }\n};","import L from 'leaflet';\nimport type { GeometryType, OSMBuildingFeature } from '../types';\n\n/**\n * Geometry utility functions για το geo-drawing system\n */\n\n/**\n * Converts GeoJSON coordinates to Leaflet LatLng array\n * @param coordinates GeoJSON coordinates array\n * @param geometryType Type of geometry\n * @returns Array of LatLng points\n */\nexport const geoJsonToLatLng = (\n  coordinates: number[][] | number[][][],\n  geometryType: GeometryType\n): L.LatLng[] => {\n  if (geometryType === 'Polygon' && Array.isArray(coordinates[0]) && Array.isArray(coordinates[0][0])) {\n    // Polygon: coordinates[0] is the exterior ring\n    const ring = coordinates as number[][][];\n    return ring[0].map(coord => L.latLng(coord[1], coord[0]));\n  }\n\n  if (geometryType === 'LineString' && Array.isArray(coordinates[0]) && typeof coordinates[0][0] === 'number') {\n    // LineString: coordinates is array of [lng, lat] pairs\n    const line = coordinates as number[][];\n    return line.map(coord => L.latLng(coord[1], coord[0]));\n  }\n\n  if (geometryType === 'Point' && typeof coordinates[0] === 'number') {\n    // Point: coordinates is [lng, lat]\n    const point = coordinates as number[];\n    return [L.latLng(point[1], point[0])];\n  }\n\n  return [];\n};\n\n/**\n * Converts Leaflet LatLng array to GeoJSON coordinates\n * @param latlngs Array of LatLng points\n * @param geometryType Target geometry type\n * @returns GeoJSON coordinates array\n */\nexport const latLngToGeoJson = (\n  latlngs: L.LatLng[],\n  geometryType: GeometryType\n): number[][] | number[][][] => {\n  const coords = latlngs.map(latlng => [latlng.lng, latlng.lat]);\n\n  if (geometryType === 'Polygon') {\n    // Polygon needs to be closed (first point = last point) and wrapped in array\n    const closedCoords = [...coords];\n    if (coords.length > 0 &&\n        (coords[0][0] !== coords[coords.length - 1][0] ||\n         coords[0][1] !== coords[coords.length - 1][1])) {\n      closedCoords.push(coords[0]);\n    }\n    return [closedCoords];\n  }\n\n  return coords;\n};\n\n/**\n * Calculates the closest point on a line segment to a given point\n * @param point Target point\n * @param segmentStart Start of line segment\n * @param segmentEnd End of line segment\n * @returns Closest point on segment and distance\n */\nexport const closestPointOnSegment = (\n  point: L.LatLng,\n  segmentStart: L.LatLng,\n  segmentEnd: L.LatLng\n): { point: L.LatLng; distance: number } => {\n  // Convert to projected coordinates for accurate calculations\n  const map = L.CRS.EPSG3857;\n  const p = map.project(point);\n  const a = map.project(segmentStart);\n  const b = map.project(segmentEnd);\n\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n\n  if (dx === 0 && dy === 0) {\n    // Segment is a point\n    const closestPoint = segmentStart;\n    return {\n      point: closestPoint,\n      distance: point.distanceTo(closestPoint)\n    };\n  }\n\n  const t = Math.max(0, Math.min(1, ((p.x - a.x) * dx + (p.y - a.y) * dy) / (dx * dx + dy * dy)));\n  const closestProjected = L.point(a.x + t * dx, a.y + t * dy);\n  const closestPoint = map.unproject(closestProjected);\n\n  return {\n    point: closestPoint,\n    distance: point.distanceTo(closestPoint)\n  };\n};\n\n/**\n * Checks if two LatLng points are approximately equal within tolerance\n * @param point1 First point\n * @param point2 Second point\n * @param tolerance Tolerance in meters\n * @returns True if points are within tolerance\n */\nexport const arePointsEqual = (point1: L.LatLng, point2: L.LatLng, tolerance: number = 0.1): boolean => {\n  return point1.distanceTo(point2) <= tolerance;\n};\n\n/**\n * Simplifies a polygon using Douglas-Peucker algorithm\n * @param latlngs Array of polygon vertices\n * @param tolerance Simplification tolerance in meters\n * @returns Simplified polygon vertices\n */\nexport const simplifyPolygon = (latlngs: L.LatLng[], tolerance: number = 1.0): L.LatLng[] => {\n  if (latlngs.length <= 2) return latlngs;\n\n  const douglasPeucker = (points: L.LatLng[], epsilon: number): L.LatLng[] => {\n    if (points.length <= 2) return points;\n\n    let maxDistance = 0;\n    let maxIndex = 0;\n\n    for (let i = 1; i < points.length - 1; i++) {\n      const { distance } = closestPointOnSegment(points[i], points[0], points[points.length - 1]);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        maxIndex = i;\n      }\n    }\n\n    if (maxDistance > epsilon) {\n      const leftPart = douglasPeucker(points.slice(0, maxIndex + 1), epsilon);\n      const rightPart = douglasPeucker(points.slice(maxIndex), epsilon);\n      return [...leftPart.slice(0, -1), ...rightPart];\n    }\n\n    return [points[0], points[points.length - 1]];\n  };\n\n  return douglasPeucker(latlngs, tolerance);\n};\n\n/**\n * Calculates the bearing between two points\n * @param point1 Start point\n * @param point2 End point\n * @returns Bearing in degrees (0-360)\n */\nexport const calculateBearing = (point1: L.LatLng, point2: L.LatLng): number => {\n  const lat1 = point1.lat * Math.PI / 180;\n  const lat2 = point2.lat * Math.PI / 180;\n  const deltaLng = (point2.lng - point1.lng) * Math.PI / 180;\n\n  const y = Math.sin(deltaLng) * Math.cos(lat2);\n  const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);\n\n  let bearing = Math.atan2(y, x) * 180 / Math.PI;\n  return (bearing + 360) % 360;\n};\n\n/**\n * Extracts geometry from OSM Building Feature\n * @param feature OSM building feature\n * @returns Array of LatLng polygons\n */\nexport const extractOSMGeometry = (feature: OSMBuildingFeature): L.LatLng[][] => {\n  const { geometry } = feature;\n  const results: L.LatLng[][] = [];\n\n  if (geometry.type === 'Polygon') {\n    const coords = geometry.coordinates as number[][][];\n    coords.forEach(ring => {\n      const latlngs = ring.map(coord => L.latLng(coord[1], coord[0]));\n      results.push(latlngs);\n    });\n  } else if (geometry.type === 'MultiPolygon') {\n    const coords = geometry.coordinates as number[][][][];\n    coords.forEach(polygon => {\n      polygon.forEach(ring => {\n        const latlngs = ring.map(coord => L.latLng(coord[1], coord[0]));\n        results.push(latlngs);\n      });\n    });\n  }\n\n  return results;\n};","import React from 'react';\nimport { useLayeraTranslation } from '@layera/i18n';\nimport { Button } from '@layera/buttons';\nimport { Card } from '@layera/cards';\nimport { Typography } from '@layera/typography';\nimport { Layout } from '@layera/layout';\nimport { Icons } from '@layera/icons';\nimport type { MeasurementMode } from '../types';\n\ninterface MeasurementControlsProps {\n  mode: MeasurementMode;\n  distance: number;\n  area: number;\n  onModeChange: (mode: MeasurementMode) => void;\n  onReset: () => void;\n  onFinish?: () => void;\n  onCancel?: () => void;\n  isDrawing: boolean;\n  canFinish: boolean;\n  displayValue?: string;\n}\n\n/**\n * Measurement controls component using LEGO systems\n * Βασισμένο στο OLD_geo-canvas/components/measurement/MeasurementControls.tsx\n * αλλά ενσωματώνει τα existing LEGO systems\n */\nexport const MeasurementControls: React.FC<MeasurementControlsProps> = ({\n  mode,\n  distance,\n  area,\n  onModeChange,\n  onReset,\n  onFinish,\n  onCancel,\n  isDrawing,\n  canFinish,\n  displayValue\n}) => {\n  const { t } = useLayeraTranslation();\n\n  return (\n    <Card variant=\"floating\" className=\"min-w-[200px]\">\n      <Typography variant=\"h6\" className=\"text-center mb-3\">\n        {t('geo-drawing.measurement-title')}\n      </Typography>\n\n      {/* Mode Selection */}\n      <Layout direction=\"horizontal\" spacing=\"sm\" className=\"mb-3\">\n        <Button\n          variant={mode === 'distance' ? 'primary' : 'secondary'}\n          size=\"sm\"\n          onClick={() => onModeChange('distance')}\n          disabled={isDrawing}\n          className=\"flex-1\"\n        >\n          <Icons.Rule className=\"w-4 h-4 mr-1\" />\n          {t('geo-drawing.modes.distance')}\n        </Button>\n\n        <Button\n          variant={mode === 'area' ? 'primary' : 'secondary'}\n          size=\"sm\"\n          onClick={() => onModeChange('area')}\n          disabled={isDrawing}\n          className=\"flex-1\"\n        >\n          <Icons.Square className=\"w-4 h-4 mr-1\" />\n          {t('geo-drawing.modes.area')}\n        </Button>\n      </Layout>\n\n      <Layout direction=\"horizontal\" spacing=\"sm\" className=\"mb-3\">\n        <Button\n          variant={mode === 'point' ? 'primary' : 'secondary'}\n          size=\"sm\"\n          onClick={() => onModeChange('point')}\n          disabled={isDrawing}\n          className=\"flex-1\"\n        >\n          <Icons.MapPin className=\"w-4 h-4 mr-1\" />\n          {t('geo-drawing.modes.point')}\n        </Button>\n      </Layout>\n\n      {/* Current Measurement Display */}\n      <Card variant=\"inner\" className=\"mb-3 p-2 min-h-[60px] flex items-center justify-center\">\n        <Typography variant=\"body\" className=\"text-center\">\n          {displayValue || (\n            mode === 'distance'\n              ? `${t('geo-drawing.labels.distance')}: ${distance.toFixed(2)} m`\n              : mode === 'area'\n              ? `${t('geo-drawing.labels.area')}: ${area.toFixed(2)} m²`\n              : t('geo-drawing.labels.select-point')\n          )}\n        </Typography>\n      </Card>\n\n      {/* Action Buttons */}\n      <Layout direction=\"vertical\" spacing=\"sm\">\n        {isDrawing && (\n          <Layout direction=\"horizontal\" spacing=\"sm\">\n            {canFinish && onFinish && (\n              <Button\n                variant=\"success\"\n                size=\"sm\"\n                onClick={onFinish}\n                className=\"flex-1\"\n              >\n                <Icons.Check className=\"w-4 h-4 mr-1\" />\n                {t('geo-drawing.actions.finish')}\n              </Button>\n            )}\n\n            {onCancel && (\n              <Button\n                variant=\"secondary\"\n                size=\"sm\"\n                onClick={onCancel}\n                className=\"flex-1\"\n              >\n                <Icons.X className=\"w-4 h-4 mr-1\" />\n                {t('geo-drawing.actions.cancel')}\n              </Button>\n            )}\n          </Layout>\n        )}\n\n        <Button\n          variant=\"danger\"\n          size=\"sm\"\n          onClick={onReset}\n          className=\"w-full\"\n        >\n          <Icons.Trash className=\"w-4 h-4 mr-1\" />\n          {t('geo-drawing.actions.clear')}\n        </Button>\n      </Layout>\n\n      {/* Instructions */}\n      <Card variant=\"inner\" className=\"mt-3 p-2\">\n        <Typography variant=\"caption\" className=\"text-center leading-tight\">\n          {isDrawing ? (\n            <>\n              {t('geo-drawing.instructions.click-add')}<br/>\n              {mode !== 'point' && (\n                <>\n                  {t('geo-drawing.instructions.double-click-finish')}<br/>\n                </>\n              )}\n              {t('geo-drawing.instructions.esc-cancel')}\n            </>\n          ) : (\n            t('geo-drawing.instructions.select-mode')\n          )}\n        </Typography>\n      </Card>\n    </Card>\n  );\n};","import React, { useCallback, useEffect } from 'react';\nimport { Polygon, Polyline, CircleMarker, useMapEvents } from 'react-leaflet';\nimport L from 'leaflet';\nimport { useTheme } from '@layera/theme-switcher';\nimport { useMeasurement } from '../hooks/useMeasurement';\nimport { useGeometrySnap } from '../hooks/useGeometrySnap';\nimport type { MeasurementMode, CanvasInteractionEvent } from '../types';\n\ninterface MeasurementCanvasProps {\n  mode: MeasurementMode;\n  enableSnapping?: boolean;\n  onMeasurementChange?: (result: any) => void;\n  className?: string;\n}\n\n/**\n * Interactive measurement canvas component\n * Ενσωματώνει το measurement logic με snap-to-geometry functionality\n */\nexport const MeasurementCanvas: React.FC<MeasurementCanvasProps> = ({\n  mode,\n  enableSnapping = true,\n  onMeasurementChange,\n  className\n}) => {\n  const { theme } = useTheme();\n  const {\n    points,\n    state,\n    addPoint,\n    finishMeasurement,\n    cancelMeasurement,\n    changeMeasurementMode,\n    currentResult\n  } = useMeasurement();\n\n  const {\n    getSnappedPoint,\n    isSnappingEffective\n  } = useGeometrySnap(enableSnapping);\n\n  // Sync external mode changes\n  useEffect(() => {\n    changeMeasurementMode(mode);\n  }, [mode, changeMeasurementMode]);\n\n  // Notify parent of measurement changes\n  useEffect(() => {\n    if (currentResult && onMeasurementChange) {\n      onMeasurementChange(currentResult);\n    }\n  }, [currentResult, onMeasurementChange]);\n\n  // Handle map interactions\n  const mapEvents = useMapEvents({\n    click: useCallback((e: L.LeafletMouseEvent) => {\n      if (state === 'finished') return;\n\n      let latlng = e.latlng;\n      let snapped = false;\n      let snapResult;\n\n      // Apply snapping if enabled\n      if (enableSnapping && isSnappingEffective) {\n        const result = getSnappedPoint(e.latlng);\n        if (result.isSnapped && result.snappedLatLng) {\n          latlng = result.snappedLatLng;\n          snapped = true;\n          snapResult = {\n            snapPoint: result.snapPoint!,\n            snapType: result.snapType as 'vertex' | 'edge'\n          };\n        }\n      }\n\n      // Create interaction event\n      const interactionEvent: CanvasInteractionEvent = {\n        type: 'click',\n        latlng,\n        originalEvent: e.originalEvent,\n        snapped,\n        snapResult\n      };\n\n      addPoint(latlng);\n    }, [state, enableSnapping, isSnappingEffective, getSnappedPoint, addPoint]),\n\n    dblclick: useCallback((e: L.LeafletMouseEvent) => {\n      e.originalEvent.preventDefault();\n      e.originalEvent.stopPropagation();\n\n      if (state === 'drawing' && mode !== 'point') {\n        finishMeasurement();\n      }\n    }, [state, mode, finishMeasurement]),\n\n    keydown: useCallback((e: L.LeafletKeyboardEvent) => {\n      if (e.originalEvent.key === 'Escape' && state === 'drawing') {\n        cancelMeasurement();\n      }\n    }, [state, cancelMeasurement])\n  });\n\n  // Get theme-aware colors\n  const getColors = useCallback(() => {\n    const isDark = theme === 'dark';\n    return {\n      line: isDark ? '#60a5fa' : '#3b82f6',\n      fill: isDark ? 'rgba(96, 165, 250, 0.2)' : 'rgba(59, 130, 246, 0.2)',\n      point: isDark ? '#f59e0b' : '#d97706',\n      pointBorder: isDark ? '#1f2937' : '#ffffff'\n    };\n  }, [theme]);\n\n  const colors = getColors();\n\n  // Render measurement geometry\n  const renderGeometry = () => {\n    if (points.length === 0) return null;\n\n    const latlngs = points.map(p => p.latlng);\n\n    return (\n      <>\n        {/* Render points */}\n        {points.map((point, index) => (\n          <CircleMarker\n            key={point.id}\n            center={point.latlng}\n            radius={6}\n            pathOptions={{\n              color: colors.pointBorder,\n              fillColor: colors.point,\n              fillOpacity: 1,\n              weight: 2\n            }}\n          />\n        ))}\n\n        {/* Render lines for distance mode or area outline */}\n        {((mode === 'distance' || mode === 'area') && latlngs.length >= 2) && (\n          <Polyline\n            positions={latlngs}\n            pathOptions={{\n              color: colors.line,\n              weight: 3,\n              opacity: 0.8,\n              dashArray: state === 'drawing' ? '5, 5' : undefined\n            }}\n          />\n        )}\n\n        {/* Render polygon fill for area mode */}\n        {(mode === 'area' && latlngs.length >= 3 && state === 'finished') && (\n          <Polygon\n            positions={latlngs}\n            pathOptions={{\n              color: colors.line,\n              fillColor: colors.fill,\n              fillOpacity: 0.3,\n              weight: 2\n            }}\n          />\n        )}\n      </>\n    );\n  };\n\n  return (\n    <div className={className}>\n      {renderGeometry()}\n    </div>\n  );\n};","import React, { useMemo } from 'react';\nimport { Polygon, Polyline, CircleMarker, Popup } from 'react-leaflet';\nimport L from 'leaflet';\nimport { useTheme } from '@layera/theme-switcher';\nimport { Typography } from '@layera/typography';\nimport { useLayeraTranslation } from '@layera/i18n';\nimport type { MeasurementResult, OSMBuildingFeature } from '../types';\nimport { extractOSMGeometry } from '../utils/geometry';\nimport { useMeasurementFormatter } from '../utils/formatters';\n\ninterface GeometryRendererProps {\n  measurements?: MeasurementResult[];\n  osmFeatures?: OSMBuildingFeature[];\n  showOSMBuildings?: boolean;\n  showMeasurements?: boolean;\n  onMeasurementClick?: (measurement: MeasurementResult) => void;\n  onBuildingClick?: (feature: OSMBuildingFeature) => void;\n}\n\n/**\n * Renders various geometric elements on the map\n * Υποστηρίζει measurement results και OSM building outlines\n */\nexport const GeometryRenderer: React.FC<GeometryRendererProps> = ({\n  measurements = [],\n  osmFeatures = [],\n  showOSMBuildings = true,\n  showMeasurements = true,\n  onMeasurementClick,\n  onBuildingClick\n}) => {\n  const { theme } = useTheme();\n  const { t } = useLayeraTranslation();\n  const { formatDistanceWithLabels, formatAreaWithLabels } = useMeasurementFormatter();\n\n  // Get theme-aware colors\n  const colors = useMemo(() => {\n    const isDark = theme === 'dark';\n    return {\n      // Measurement colors\n      measurementLine: isDark ? '#10b981' : '#059669',\n      measurementFill: isDark ? 'rgba(16, 185, 129, 0.2)' : 'rgba(5, 150, 105, 0.2)',\n      measurementPoint: isDark ? '#f59e0b' : '#d97706',\n\n      // OSM building colors\n      buildingLine: isDark ? '#6b7280' : '#9ca3af',\n      buildingFill: isDark ? 'rgba(107, 114, 128, 0.1)' : 'rgba(156, 163, 175, 0.1)',\n      buildingHover: isDark ? '#374151' : '#d1d5db',\n\n      // Border colors\n      border: isDark ? '#1f2937' : '#ffffff'\n    };\n  }, [theme]);\n\n  // Render OSM building outlines\n  const renderOSMBuildings = () => {\n    if (!showOSMBuildings || osmFeatures.length === 0) return null;\n\n    return osmFeatures.map((feature, index) => {\n      const polygons = extractOSMGeometry(feature);\n\n      return polygons.map((polygon, polygonIndex) => {\n        const key = `building-${index}-${polygonIndex}`;\n\n        return (\n          <Polygon\n            key={key}\n            positions={polygon}\n            pathOptions={{\n              color: colors.buildingLine,\n              fillColor: colors.buildingFill,\n              fillOpacity: 0.1,\n              weight: 1,\n              opacity: 0.6\n            }}\n            eventHandlers={{\n              click: () => onBuildingClick?.(feature),\n              mouseover: (e) => {\n                e.target.setStyle({\n                  fillColor: colors.buildingHover,\n                  fillOpacity: 0.3\n                });\n              },\n              mouseout: (e) => {\n                e.target.setStyle({\n                  fillColor: colors.buildingFill,\n                  fillOpacity: 0.1\n                });\n              }\n            }}\n          >\n            {feature.properties.name && (\n              <Popup>\n                <div>\n                  <Typography variant=\"subtitle\" className=\"font-semibold\">\n                    {feature.properties.name}\n                  </Typography>\n                  {feature.properties.building && (\n                    <Typography variant=\"caption\" className=\"text-gray-600\">\n                      {t('geo-drawing.building-type')}: {feature.properties.building}\n                    </Typography>\n                  )}\n                  {feature.properties['addr:street'] && (\n                    <Typography variant=\"caption\" className=\"text-gray-600\">\n                      {feature.properties['addr:street']} {feature.properties['addr:housenumber']}\n                    </Typography>\n                  )}\n                </div>\n              </Popup>\n            )}\n          </Polygon>\n        );\n      });\n    });\n  };\n\n  // Render measurement results\n  const renderMeasurements = () => {\n    if (!showMeasurements || measurements.length === 0) return null;\n\n    return measurements.map((measurement) => {\n      const latlngs = measurement.points.map(p => p.latlng);\n      const key = `measurement-${measurement.timestamp}`;\n\n      return (\n        <React.Fragment key={key}>\n          {/* Render measurement points */}\n          {measurement.points.map((point, index) => (\n            <CircleMarker\n              key={`${key}-point-${index}`}\n              center={point.latlng}\n              radius={5}\n              pathOptions={{\n                color: colors.border,\n                fillColor: colors.measurementPoint,\n                fillOpacity: 1,\n                weight: 2\n              }}\n              eventHandlers={{\n                click: () => onMeasurementClick?.(measurement)\n              }}\n            >\n              <Popup>\n                <div>\n                  <Typography variant=\"subtitle\" className=\"font-semibold\">\n                    {t('geo-drawing.point-info', { index: index + 1 })}\n                  </Typography>\n                  <Typography variant=\"caption\">\n                    {point.latlng.lat.toFixed(6)}, {point.latlng.lng.toFixed(6)}\n                  </Typography>\n                </div>\n              </Popup>\n            </CircleMarker>\n          ))}\n\n          {/* Render lines for distance/area measurements */}\n          {((measurement.type === 'distance' || measurement.type === 'area') && latlngs.length >= 2) && (\n            <Polyline\n              positions={latlngs}\n              pathOptions={{\n                color: colors.measurementLine,\n                weight: 3,\n                opacity: 0.8\n              }}\n              eventHandlers={{\n                click: () => onMeasurementClick?.(measurement)\n              }}\n            >\n              <Popup>\n                <div>\n                  <Typography variant=\"subtitle\" className=\"font-semibold\">\n                    {t(`geo-drawing.modes.${measurement.type}`)}\n                  </Typography>\n                  <Typography variant=\"body\">\n                    {measurement.displayValue}\n                  </Typography>\n                  <Typography variant=\"caption\" className=\"text-gray-600\">\n                    {new Date(measurement.timestamp).toLocaleString()}\n                  </Typography>\n                </div>\n              </Popup>\n            </Polyline>\n          )}\n\n          {/* Render polygon fill for area measurements */}\n          {(measurement.type === 'area' && latlngs.length >= 3) && (\n            <Polygon\n              positions={latlngs}\n              pathOptions={{\n                color: colors.measurementLine,\n                fillColor: colors.measurementFill,\n                fillOpacity: 0.3,\n                weight: 2\n              }}\n              eventHandlers={{\n                click: () => onMeasurementClick?.(measurement)\n              }}\n            >\n              <Popup>\n                <div>\n                  <Typography variant=\"subtitle\" className=\"font-semibold\">\n                    {t('geo-drawing.area-measurement')}\n                  </Typography>\n                  <Typography variant=\"body\">\n                    {measurement.area && formatAreaWithLabels(measurement.area)}\n                  </Typography>\n                  <Typography variant=\"caption\" className=\"text-gray-600\">\n                    {t('geo-drawing.points-count', { count: measurement.points.length })}\n                  </Typography>\n                </div>\n              </Popup>\n            </Polygon>\n          )}\n        </React.Fragment>\n      );\n    });\n  };\n\n  return (\n    <>\n      {renderOSMBuildings()}\n      {renderMeasurements()}\n    </>\n  );\n};","/**\n * @layera/geo-drawing - LEGO System για geo-spatial drawing και measurement\n *\n * Ενσωματώνει functionality από OLD_geo-canvas με existing LEGO systems:\n * - @layera/snap-engine & @layera/snap-interactions για snapping\n * - @layera/i18n για internationalization\n * - @layera/theme-switcher για theme-aware colors\n * - @layera/buttons, @layera/cards, @layera/typography για UI\n * - @layera/constants για configuration\n * - @layera/notifications για user feedback\n */\n\n// Types\nexport type {\n  MeasurementMode,\n  DrawingState,\n  GeometryType,\n  MeasurementPoint,\n  MeasurementResult,\n  OSMBuildingProperties,\n  OSMBuildingFeature,\n  GeoJSONFeatureCollection,\n  DrawingConfig,\n  CanvasInteractionEvent\n} from './types';\n\n// Core Hooks\nexport { useMeasurement } from './hooks/useMeasurement';\nexport { useGeometrySnap } from './hooks/useGeometrySnap';\n\n// Components\nexport { MeasurementControls } from './components/MeasurementControls';\nexport { MeasurementCanvas } from './components/MeasurementCanvas';\nexport { GeometryRenderer } from './components/GeometryRenderer';\n\n// Utilities\nexport {\n  calculateProjectedArea,\n  calculateDistance,\n  calculatePointDistance,\n  calculatePolygonCenter,\n  calculatePerimeter,\n  isPointInPolygon,\n  calculateBounds\n} from './utils/calculations';\n\nexport {\n  formatDistance,\n  formatArea,\n  useMeasurementFormatter,\n  formatCoordinatesBySystem,\n  formatBearing\n} from './utils/formatters';\n\nexport {\n  geoJsonToLatLng,\n  latLngToGeoJson,\n  closestPointOnSegment,\n  arePointsEqual,\n  simplifyPolygon,\n  calculateBearing,\n  extractOSMGeometry\n} from './utils/geometry';\n\n// Services\nexport {\n  fetchBuildingOutlines,\n  clearOSMCache,\n  getCacheSize,\n  isBoundsCached,\n  prefetchBuildingOutlines\n} from './services/osmService';\n\n// Constants που θα προστεθούν στο @layera/constants\nexport const GEO_DRAWING_CONSTANTS = {\n  DEFAULT_SNAP_TOLERANCE: 15,\n  MIN_SNAP_ZOOM: 16,\n  DEBOUNCE_MS: 500,\n  REQUEST_TIMEOUT: 30000\n} as const;"],"mappings":"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","names":["useLayeraTranslation","useLayeraTranslation","useState","useCallback","useRef","L","closestPoint","CONFIG","useState","useRef","useCallback","useLayeraTranslation","useCallback","useEffect","Fragment","jsx","jsxs","useEffect","useCallback","React","Polygon","Polyline","CircleMarker","useTheme","Typography","useLayeraTranslation","Fragment","jsx","jsxs","useTheme","useLayeraTranslation","Polygon","Typography","React","CircleMarker","Polyline"]}