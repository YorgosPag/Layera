{"version":3,"sources":["../src/hooks/useMeasurement.ts","../src/utils/calculations.ts","../src/utils/formatters.ts","../src/hooks/useGeometrySnap.ts","../src/services/osmService.ts","../src/hooks/useDrawing.ts","../src/utils/geometryDetection.ts","../src/utils/mapLabelIntegration.ts","../src/index.ts"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\nimport L from 'leaflet';\nimport { useLayeraTranslation } from '@layera/tolgee';\nimport type { MeasurementMode, MeasurementPoint, MeasurementResult, DrawingState } from '../types';\nimport { calculateDistance, calculateProjectedArea } from '../utils/calculations';\nimport { useMeasurementFormatter } from '../utils/formatters';\nimport { useNotifications } from '@layera/notifications';\n\n/**\n * Core measurement hook για το geo-drawing system\n * Μεταφέρθηκε και βελτιώθηκε από OLD_geo-canvas\n */\nexport const useMeasurement = () => {\n  const { t } = useLayeraTranslation();\n  const { addNotification } = useNotifications();\n  const { formatDistanceWithLabels, formatAreaWithLabels } = useMeasurementFormatter();\n\n  const [mode, setMode] = useState<MeasurementMode>('distance');\n  const [state, setState] = useState<DrawingState>('idle');\n  const [points, setPoints] = useState<MeasurementPoint[]>([]);\n  const [currentResult, setCurrentResult] = useState<MeasurementResult | null>(null);\n  const [results, setResults] = useState<MeasurementResult[]>([]);\n\n  const pointIdCounter = useRef(0);\n\n  /**\n   * Adds a new measurement point\n   */\n  const addPoint = useCallback((latlng: L.LatLng) => {\n    const newPoint: MeasurementPoint = {\n      id: `point-${pointIdCounter.current++}`,\n      latlng,\n      index: points.length\n    };\n\n    const updatedPoints = [...points, newPoint];\n    setPoints(updatedPoints);\n\n    // Start drawing state on first point\n    if (points.length === 0) {\n      setState('drawing');\n    }\n\n    // Calculate current measurement\n    let distance = 0;\n    let area = 0;\n    let displayValue = '';\n\n    if (mode === 'distance' && updatedPoints.length >= 2) {\n      const latlngs = updatedPoints.map(p => p.latlng);\n      distance = calculateDistance(latlngs);\n      displayValue = formatDistanceWithLabels(distance);\n    } else if (mode === 'area' && updatedPoints.length >= 3) {\n      const latlngs = updatedPoints.map(p => p.latlng);\n      area = calculateProjectedArea(latlngs);\n      displayValue = formatAreaWithLabels(area);\n    } else if (mode === 'point') {\n      displayValue = `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;\n    }\n\n    const result: MeasurementResult = {\n      type: mode,\n      points: updatedPoints,\n      ...(mode === 'distance' && distance !== undefined && { distance }),\n      ...(mode === 'area' && area !== undefined && { area }),\n      displayValue,\n      timestamp: Date.now()\n    };\n\n    setCurrentResult(result);\n  }, [points, mode, formatDistanceWithLabels, formatAreaWithLabels]);\n\n  /**\n   * Finishes the current measurement\n   */\n  const finishMeasurement = useCallback(() => {\n    if (!currentResult) return;\n\n    // Validation based on mode\n    if (mode === 'distance' && points.length < 2) {\n      addNotification({\n        type: 'error',\n        message: t('geo-drawing.errors.minimum-points-distance')\n      });\n      return;\n    }\n\n    if (mode === 'area' && points.length < 3) {\n      addNotification({\n        type: 'error',\n        message: t('geo-drawing.errors.minimum-points-area')\n      });\n      return;\n    }\n\n    setResults(prev => [...prev, currentResult]);\n    setState('finished');\n\n    addNotification({\n      type: 'success',\n      message: t('geo-drawing.measurement-completed', {\n        type: t(`geo-drawing.modes.${mode}`),\n        value: currentResult.displayValue\n      })\n    });\n  }, [currentResult, mode, points.length, addNotification, t]);\n\n  /**\n   * Cancels the current measurement\n   */\n  const cancelMeasurement = useCallback(() => {\n    setPoints([]);\n    setCurrentResult(null);\n    setState('idle');\n  }, []);\n\n  /**\n   * Resets all measurements\n   */\n  const resetAll = useCallback(() => {\n    setPoints([]);\n    setCurrentResult(null);\n    setResults([]);\n    setState('idle');\n    pointIdCounter.current = 0;\n  }, []);\n\n  /**\n   * Changes measurement mode\n   */\n  const changeMeasurementMode = useCallback((newMode: MeasurementMode) => {\n    if (state === 'drawing') {\n      // Ask user confirmation if currently drawing\n      if (window.confirm(t('geo-drawing.confirm-mode-change'))) {\n        cancelMeasurement();\n        setMode(newMode);\n      }\n    } else {\n      setMode(newMode);\n    }\n  }, [state, cancelMeasurement, t]);\n\n  /**\n   * Removes the last point\n   */\n  const removeLastPoint = useCallback(() => {\n    if (points.length === 0) return;\n\n    const updatedPoints = points.slice(0, -1);\n    setPoints(updatedPoints);\n\n    if (updatedPoints.length === 0) {\n      setState('idle');\n      setCurrentResult(null);\n    } else {\n      // Recalculate measurement\n      let distance = 0;\n      let area = 0;\n      let displayValue = '';\n\n      if (mode === 'distance' && updatedPoints.length >= 2) {\n        const latlngs = updatedPoints.map(p => p.latlng);\n        distance = calculateDistance(latlngs);\n        displayValue = formatDistanceWithLabels(distance);\n      } else if (mode === 'area' && updatedPoints.length >= 3) {\n        const latlngs = updatedPoints.map(p => p.latlng);\n        area = calculateProjectedArea(latlngs);\n        displayValue = formatAreaWithLabels(area);\n      }\n\n      const result: MeasurementResult = {\n        type: mode,\n        points: updatedPoints,\n        ...(mode === 'distance' && distance !== undefined && { distance }),\n        ...(mode === 'area' && area !== undefined && { area }),\n        displayValue,\n        timestamp: Date.now()\n      };\n\n      setCurrentResult(result);\n    }\n  }, [points, mode, formatDistanceWithLabels, formatAreaWithLabels]);\n\n  /**\n   * Removes a specific measurement result\n   */\n  const removeResult = useCallback((timestamp: number) => {\n    setResults(prev => prev.filter(result => result.timestamp !== timestamp));\n  }, []);\n\n  /**\n   * Gets current distance (for display during drawing)\n   */\n  const getCurrentDistance = useCallback((): number => {\n    if (points.length < 2) return 0;\n    const latlngs = points.map(p => p.latlng);\n    return calculateDistance(latlngs);\n  }, [points]);\n\n  /**\n   * Gets current area (for display during drawing)\n   */\n  const getCurrentArea = useCallback((): number => {\n    if (points.length < 3) return 0;\n    const latlngs = points.map(p => p.latlng);\n    return calculateProjectedArea(latlngs);\n  }, [points]);\n\n  return {\n    // State\n    mode,\n    state,\n    points,\n    currentResult,\n    results,\n\n    // Actions\n    addPoint,\n    finishMeasurement,\n    cancelMeasurement,\n    resetAll,\n    changeMeasurementMode,\n    removeLastPoint,\n    removeResult,\n\n    // Computed values\n    getCurrentDistance,\n    getCurrentArea,\n    isDrawing: state === 'drawing',\n    isFinished: state === 'finished',\n    canFinish: (mode === 'distance' && points.length >= 2) ||\n               (mode === 'area' && points.length >= 3) ||\n               (mode === 'point' && points.length >= 1)\n  };\n};","import * as L from 'leaflet';\n\n/**\n * Calculates the area of a polygon using the Shoelace formula on projected coordinates.\n * Μεταφέρθηκε από OLD_geo-canvas/components/utils/measurementUtils.ts\n * @param latlngs An array of L.LatLng points for the polygon.\n * @returns The calculated area in square meters.\n */\nexport const calculateProjectedArea = (latlngs: L.LatLng[]): number => {\n  if (latlngs.length < 3) return 0;\n\n  // Project points to a cartesian plane (meters) using Web Mercator projection\n  const map = L.CRS.EPSG3857;\n  const points = latlngs.map(latlng => map.project(latlng));\n\n  let area = 0;\n  const n = points.length;\n  for (let i = 0; i < n; i++) {\n    const p1 = points[i];\n    const p2 = points[(i + 1) % n];\n    if (p1 && p2) {\n      area += p1.x * p2.y - p2.x * p1.y;\n    }\n  }\n\n  return Math.abs(area / 2.0);\n};\n\n/**\n * Calculates the total path distance for a series of points.\n * Μεταφέρθηκε από OLD_geo-canvas/components/utils/measurementUtils.ts\n * @param latlngs An array of L.LatLng points.\n * @returns The total distance in meters.\n */\nexport const calculateDistance = (latlngs: L.LatLng[]): number => {\n  if (latlngs.length < 2) {\n    return 0;\n  }\n\n  let totalDistance = 0;\n  for (let i = 0; i < latlngs.length - 1; i++) {\n    const point1 = latlngs[i];\n    const point2 = latlngs[i + 1];\n    if (point1 && point2) {\n      totalDistance += point1.distanceTo(point2);\n    }\n  }\n  return totalDistance;\n};\n\n/**\n * Calculates the distance between two LatLng points using Haversine formula\n * @param point1 First point\n * @param point2 Second point\n * @returns Distance in meters\n */\nexport const calculatePointDistance = (point1: L.LatLng, point2: L.LatLng): number => {\n  return point1.distanceTo(point2);\n};\n\n/**\n * Calculates the center point of a polygon\n * @param latlngs Array of polygon vertices\n * @returns Center point as LatLng\n */\nexport const calculatePolygonCenter = (latlngs: L.LatLng[]): L.LatLng => {\n  if (latlngs.length === 0) {\n    throw new Error('Cannot calculate center of empty polygon');\n  }\n\n  let latSum = 0;\n  let lngSum = 0;\n\n  for (const point of latlngs) {\n    latSum += point.lat;\n    lngSum += point.lng;\n  }\n\n  return L.latLng(latSum / latlngs.length, lngSum / latlngs.length);\n};\n\n/**\n * Calculates the perimeter of a polygon\n * @param latlngs Array of polygon vertices\n * @returns Perimeter in meters\n */\nexport const calculatePerimeter = (latlngs: L.LatLng[]): number => {\n  if (latlngs.length < 2) return 0;\n\n  // Close the polygon by adding the first point at the end\n  const firstPoint = latlngs[0];\n  if (!firstPoint) return 0;\n  const closedPolygon = [...latlngs, firstPoint];\n  return calculateDistance(closedPolygon);\n};\n\n/**\n * Checks if a point is inside a polygon using ray casting algorithm\n * @param point Point to test\n * @param polygon Array of polygon vertices\n * @returns True if point is inside polygon\n */\nexport const isPointInPolygon = (point: L.LatLng, polygon: L.LatLng[]): boolean => {\n  let inside = false;\n  const x = point.lng;\n  const y = point.lat;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const pointI = polygon[i];\n    const pointJ = polygon[j];\n    if (!pointI || !pointJ) continue;\n\n    const xi = pointI.lng;\n    const yi = pointI.lat;\n    const xj = pointJ.lng;\n    const yj = pointJ.lat;\n\n    if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\n/**\n * Calculates the bounding box of a set of points\n * @param latlngs Array of points\n * @returns Leaflet LatLngBounds object\n */\nexport const calculateBounds = (latlngs: L.LatLng[]): L.LatLngBounds => {\n  if (latlngs.length === 0) {\n    throw new Error('Cannot calculate bounds of empty point array');\n  }\n\n  return L.latLngBounds(latlngs);\n};\n\n/**\n * Calculates the radius of a circle from center to a point on circumference\n * @param center Center point of the circle\n * @param circumferencePoint Point on the circle's circumference\n * @returns Radius in meters\n */\nexport const calculateCircleRadius = (center: L.LatLng, circumferencePoint: L.LatLng): number => {\n  return center.distanceTo(circumferencePoint);\n};\n\n/**\n * Calculates the area of a circle\n * @param radius Radius in meters\n * @returns Area in square meters\n */\nexport const calculateCircleArea = (radius: number): number => {\n  if (radius <= 0) return 0;\n  return Math.PI * radius * radius;\n};\n\n/**\n * Calculates the circumference of a circle\n * @param radius Radius in meters\n * @returns Circumference in meters\n */\nexport const calculateCircleCircumference = (radius: number): number => {\n  if (radius <= 0) return 0;\n  return 2 * Math.PI * radius;\n};\n\n/**\n * Calculates the diameter of a circle\n * @param radius Radius in meters\n * @returns Diameter in meters\n */\nexport const calculateCircleDiameter = (radius: number): number => {\n  if (radius <= 0) return 0;\n  return 2 * radius;\n};\n\n/**\n * Calculates arc length given radius and angle\n * @param radius Radius in meters\n * @param angleRadians Angle in radians\n * @returns Arc length in meters\n */\nexport const calculateArcLength = (radius: number, angleRadians: number): number => {\n  if (radius <= 0 || angleRadians <= 0) return 0;\n  return radius * angleRadians;\n};\n\n/**\n * Calculates the angle between three points (middle point is the vertex)\n * @param point1 First point\n * @param vertex Middle point (vertex of the angle)\n * @param point2 Third point\n * @returns Angle in radians\n */\nexport const calculateAngle = (point1: L.LatLng, vertex: L.LatLng, point2: L.LatLng): number => {\n  // Convert to projected coordinates for accurate calculation\n  const map = L.CRS.EPSG3857;\n  const p1 = map.project(point1);\n  const v = map.project(vertex);\n  const p2 = map.project(point2);\n\n  // Calculate vectors from vertex to each point\n  const vector1 = { x: p1.x - v.x, y: p1.y - v.y };\n  const vector2 = { x: p2.x - v.x, y: p2.y - v.y };\n\n  // Calculate dot product and magnitudes\n  const dotProduct = vector1.x * vector2.x + vector1.y * vector2.y;\n  const magnitude1 = Math.sqrt(vector1.x * vector1.x + vector1.y * vector1.y);\n  const magnitude2 = Math.sqrt(vector2.x * vector2.x + vector2.y * vector2.y);\n\n  if (magnitude1 === 0 || magnitude2 === 0) return 0;\n\n  // Calculate angle using inverse cosine\n  const cosAngle = dotProduct / (magnitude1 * magnitude2);\n\n  // Clamp to valid range for acos\n  const clampedCos = Math.max(-1, Math.min(1, cosAngle));\n\n  return Math.acos(clampedCos);\n};\n\n/**\n * Detects if three points form a circle and calculates its properties\n * @param point1 First point on circle\n * @param point2 Second point on circle\n * @param point3 Third point on circle\n * @returns Circle properties or null if points don't form a valid circle\n */\nexport const detectCircleFromThreePoints = (\n  point1: L.LatLng,\n  point2: L.LatLng,\n  point3: L.LatLng\n): { center: L.LatLng; radius: number } | null => {\n  // Convert to projected coordinates for accurate calculation\n  const map = L.CRS.EPSG3857;\n  const p1 = map.project(point1);\n  const p2 = map.project(point2);\n  const p3 = map.project(point3);\n\n  // Check if points are collinear\n  const area = Math.abs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2);\n  if (area < 1e-10) {\n    return null; // Points are collinear\n  }\n\n  // Calculate circumcenter using the perpendicular bisector method\n  const d = 2 * (p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y));\n\n  if (Math.abs(d) < 1e-10) {\n    return null; // Points are too close to collinear\n  }\n\n  const ux = ((p1.x * p1.x + p1.y * p1.y) * (p2.y - p3.y) +\n             (p2.x * p2.x + p2.y * p2.y) * (p3.y - p1.y) +\n             (p3.x * p3.x + p3.y * p3.y) * (p1.y - p2.y)) / d;\n\n  const uy = ((p1.x * p1.x + p1.y * p1.y) * (p3.x - p2.x) +\n             (p2.x * p2.x + p2.y * p2.y) * (p1.x - p3.x) +\n             (p3.x * p3.x + p3.y * p3.y) * (p2.x - p1.x)) / d;\n\n  // Convert back to geographic coordinates\n  const centerProjected = L.point(ux, uy);\n  const center = map.unproject(centerProjected);\n\n  // Calculate radius\n  const radius = center.distanceTo(point1);\n\n  return { center, radius };\n};","import { useLayeraTranslation } from '@layera/tolgee';\n\n/**\n * Formats a distance in meters into a readable string, switching to kilometers for large distances.\n * Μεταφέρθηκε από OLD_geo-canvas/components/utils/measurementUtils.ts\n * @param meters The distance in meters.\n * @param decimals The number of decimal places to show.\n * @returns A formatted string like \"500.00 m\" or \"1.20 km\".\n */\nexport const formatDistance = (meters: number, decimals: number = 2): string => {\n  if (meters === 0) return '0 m';\n  if (meters >= 1000) {\n    return `${(meters / 1000).toFixed(decimals)} km`;\n  }\n  return `${meters.toFixed(decimals)} m`;\n};\n\n/**\n * Formats an area in square meters into a readable string, switching to hectares or square kilometers.\n * Μεταφέρθηκε από OLD_geo-canvas/components/utils/measurementUtils.ts\n * @param sqMeters The area in square meters.\n * @returns A formatted string like \"500.00 m²\" or \"1.20 ha\".\n */\nexport const formatArea = (sqMeters: number): string => {\n  if (sqMeters === 0) return '0 m²';\n  if (sqMeters >= 1000000) {\n    return `${(sqMeters / 1000000).toFixed(2)} km²`;\n  }\n  if (sqMeters >= 10000) {\n    return `${(sqMeters / 10000).toFixed(2)} ha`;\n  }\n  return `${sqMeters.toFixed(2)} m²`;\n};\n\n/**\n * Hook for formatted measurement display with i18n support\n * Αντικαθιστά τα hardcoded strings με i18n keys\n */\nexport const useMeasurementFormatter = () => {\n  const { t } = useLayeraTranslation();\n\n  const formatDistanceWithLabels = (meters: number, decimals: number = 2): string => {\n    if (meters === 0) return `0 ${t('geo-drawing.units.meters')}`;\n    if (meters >= 1000) {\n      return `${(meters / 1000).toFixed(decimals)} ${t('geo-drawing.units.kilometers')}`;\n    }\n    return `${meters.toFixed(decimals)} ${t('geo-drawing.units.meters')}`;\n  };\n\n  const formatAreaWithLabels = (sqMeters: number): string => {\n    if (sqMeters === 0) return `0 ${t('geo-drawing.units.square-meters')}`;\n    if (sqMeters >= 1000000) {\n      return `${(sqMeters / 1000000).toFixed(2)} ${t('geo-drawing.units.square-kilometers')}`;\n    }\n    if (sqMeters >= 10000) {\n      return `${(sqMeters / 10000).toFixed(2)} ${t('geo-drawing.units.hectares')}`;\n    }\n    return `${sqMeters.toFixed(2)} ${t('geo-drawing.units.square-meters')}`;\n  };\n\n  const formatCoordinates = (lat: number, lng: number, decimals: number = 6): string => {\n    return `${lat.toFixed(decimals)}, ${lng.toFixed(decimals)}`;\n  };\n\n  const formatPointLabel = (index: number): string => {\n    return t('geo-drawing.point-label', { index: index + 1 });\n  };\n\n  return {\n    formatDistanceWithLabels,\n    formatAreaWithLabels,\n    formatCoordinates,\n    formatPointLabel,\n    // Backward compatibility exports\n    formatDistance,\n    formatArea\n  };\n};\n\n/**\n * Formats coordinates to different coordinate systems\n */\nexport const formatCoordinatesBySystem = (\n  lat: number,\n  lng: number,\n  system: 'WGS84' | 'EGSA87' | 'UTM' = 'WGS84',\n  decimals: number = 6\n): string => {\n  switch (system) {\n    case 'WGS84':\n      return `${lat.toFixed(decimals)}°N, ${lng.toFixed(decimals)}°E`;\n    case 'EGSA87':\n      // Basic conversion placeholder - would need proper transformation\n      return `X: ${lng.toFixed(2)}, Y: ${lat.toFixed(2)} (ΕΓΣΑ87)`;\n    case 'UTM':\n      // Basic UTM formatting placeholder\n      return `UTM: ${lng.toFixed(0)}E, ${lat.toFixed(0)}N`;\n    default:\n      return `${lat.toFixed(decimals)}, ${lng.toFixed(decimals)}`;\n  }\n};\n\n/**\n * Formats bearing/azimuth between two points\n * @param bearing Bearing in degrees\n * @returns Formatted bearing string\n */\nexport const formatBearing = (bearing: number): string => {\n  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];\n  const index = Math.round(bearing / 45) % 8;\n  return `${bearing.toFixed(1)}° (${directions[index]})`;\n};","import { useState, useEffect, useCallback, useRef } from 'react';\nimport L from 'leaflet';\nimport { useMap } from 'react-leaflet';\nimport type { OSMBuildingCollection } from '@layera/geo-core';\nimport { fetchBuildingOutlines } from '../services/osmService';\nimport { CONFIG } from '@layera/constants';\n\n/**\n * Hook που ενσωματώνει το snap-to-geometry με OSM building data\n * Temporary simplified version μέχρι να συμβατοποιηθούν τα snap packages\n */\nexport const useGeometrySnap = (isEnabled: boolean = true) => {\n  const map = useMap();\n  const [osmData, setOsmData] = useState<OSMBuildingCollection | null>(null);\n  const [isSnappingEffective, setIsSnappingEffective] = useState(false);\n  const timeoutRef = useRef<number | null>(null);\n\n  // Effect για fetching OSM data όταν ο χάρτης κινείται\n  useEffect(() => {\n    const fetchData = async () => {\n      const currentZoom = map.getZoom();\n      if (!isEnabled || currentZoom < (CONFIG.geoDrawing?.minSnapZoom || 16)) {\n        setOsmData(null);\n        setIsSnappingEffective(false);\n        return;\n      }\n\n      setIsSnappingEffective(true);\n      try {\n        const geojson = await fetchBuildingOutlines(map.getBounds());\n        setOsmData(geojson);\n      } catch (error) {\n        console.error('Error fetching OSM data for snapping:', error);\n        setOsmData(null);\n        setIsSnappingEffective(false);\n      }\n    };\n\n    const debouncedFetch = () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = window.setTimeout(fetchData, CONFIG.geoDrawing?.debounceMs || 500);\n    };\n\n    map.on('moveend', debouncedFetch);\n    map.on('zoomend', debouncedFetch);\n\n    // Initial fetch\n    fetchData();\n\n    return () => {\n      map.off('moveend', debouncedFetch);\n      map.off('zoomend', debouncedFetch);\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [map, isEnabled]);\n\n  /**\n   * Snap function που δέχεται LatLng και επιστρέφει snapped coordinates\n   * Temporary implementation που επιστρέφει το original point\n   */\n  const snapToGeometry = useCallback(async (point: L.LatLng): Promise<L.LatLng> => {\n    // TODO: Implement actual snapping when snap packages are compatible\n    return point;\n  }, []);\n\n  /**\n   * Toggles snap types - placeholder\n   */\n  const toggleSnapType = useCallback((type: string, enabled: boolean) => {\n    // TODO: Implement when snap engine is compatible\n    console.log(`Toggle snap type ${type}: ${enabled}`);\n  }, []);\n\n  /**\n   * Updates snap tolerance - placeholder\n   */\n  const updateTolerance = useCallback((tolerance: number) => {\n    // TODO: Implement when snap engine is compatible\n    console.log(`Update tolerance: ${tolerance}`);\n  }, []);\n\n  return {\n    // State\n    isSnappingEffective,\n    osmData,\n    isSnapped: false,\n    lastSnapResult: null,\n\n    // Functions\n    snapToGeometry,\n    toggleSnapType,\n    updateTolerance,\n\n    // Placeholder values\n    snapEngine: null,\n    performanceMetrics: null\n  };\n};","/**\n * @layera/geo-drawing/services/osmService.ts\n *\n * BACKWARD COMPATIBILITY RE-EXPORTS\n * ===================================\n *\n * Αυτό το αρχείο παρέχει backward compatibility για το παλιό API.\n * Όλες οι OSM services έχουν μετακινηθεί στο @layera/geo-mapping package\n * ως μέρος της enterprise refactoring στρατηγικής.\n *\n * Enterprise Architecture Benefits:\n * - Separation of concerns: Drawing ≠ Data fetching\n * - Reusability: Άλλα packages μπορούν να χρησιμοποιήσουν OSM services\n * - Independent deployment: OSM services ενημερώνονται ανεξάρτητα\n * - Better testing: Isolated testing για mapping functionality\n *\n * MIGRATION PATH:\n * ==============\n *\n * ΠΑΛΙΟ (deprecated):\n * import { fetchBuildingOutlines } from '@layera/geo-drawing';\n *\n * ΝΕΟ (recommended):\n * import { fetchBuildingOutlines } from '@layera/geo-mapping';\n *\n * Αυτό το re-export θα διατηρηθεί για backward compatibility\n * μέχρι να ολοκληρωθεί η migration όλων των consumers.\n */\n\n// Re-export all OSM services from the new dedicated package\nexport {\n  fetchBuildingOutlines,\n  fetchAdministrativeBoundary,\n  fetchBoundaryByAddressComponent,\n  clearOSMCache,\n  getCacheSize,\n  isBoundsCached,\n  prefetchBuildingOutlines\n} from '@layera/geo-mapping';","/**\r\n * useDrawing.ts - Legacy Drawing Hook για backward compatibility\r\n *\r\n * Compatibility wrapper για την μετάβαση από @layera/map-drawing.\r\n * Προσφέρει simple drawing interface που χρησιμοποιούνταν στο παλιό σύστημα.\r\n */\r\n\r\nimport { useState, useCallback } from 'react';\r\nimport type { DrawnArea } from '@layera/map-core';\r\n\r\nexport type DrawingMode = 'none' | 'polygon' | 'marker' | 'circle';\r\n\r\nexport interface UseDrawingOptions {\r\n  initialMode?: DrawingMode;\r\n  onAreaCreated?: (area: DrawnArea) => void;\r\n  onAreaDeleted?: (areaId: string) => void;\r\n  onModeChanged?: (mode: DrawingMode) => void;\r\n}\r\n\r\nexport interface UseDrawingReturn {\r\n  drawingMode: DrawingMode;\r\n  setDrawingMode: (mode: DrawingMode) => void;\r\n  drawnAreas: DrawnArea[];\r\n  addArea: (area: DrawnArea) => void;\r\n  removeArea: (areaId: string) => void;\r\n  clearAreas: () => void;\r\n  isDrawing: boolean;\r\n  toggleDrawing: () => void;\r\n}\r\n\r\n/**\r\n * Legacy drawing hook για compatibility με το παλιό @layera/map-drawing\r\n */\r\nexport function useDrawing(options: UseDrawingOptions = {}): UseDrawingReturn {\r\n  const {\r\n    initialMode = 'none',\r\n    onAreaCreated,\r\n    onAreaDeleted,\r\n    onModeChanged\r\n  } = options;\r\n\r\n  const [drawingMode, setDrawingModeState] = useState<DrawingMode>(initialMode);\r\n  const [drawnAreas, setDrawnAreas] = useState<DrawnArea[]>([]);\r\n  const [isDrawing, setIsDrawing] = useState(false);\r\n\r\n  const setDrawingMode = useCallback((mode: DrawingMode) => {\r\n    setDrawingModeState(mode);\r\n    setIsDrawing(mode !== 'none');\r\n    onModeChanged?.(mode);\r\n  }, [onModeChanged]);\r\n\r\n  const addArea = useCallback((area: DrawnArea) => {\r\n    setDrawnAreas(prev => [...prev, area]);\r\n    onAreaCreated?.(area);\r\n  }, [onAreaCreated]);\r\n\r\n  const removeArea = useCallback((areaId: string) => {\r\n    setDrawnAreas(prev => prev.filter(area => area.id !== areaId));\r\n    onAreaDeleted?.(areaId);\r\n  }, [onAreaDeleted]);\r\n\r\n  const clearAreas = useCallback(() => {\r\n    setDrawnAreas([]);\r\n  }, []);\r\n\r\n  const toggleDrawing = useCallback(() => {\r\n    setDrawingMode(drawingMode === 'none' ? 'polygon' : 'none');\r\n  }, [drawingMode, setDrawingMode]);\r\n\r\n  return {\r\n    drawingMode,\r\n    setDrawingMode,\r\n    drawnAreas,\r\n    addArea,\r\n    removeArea,\r\n    clearAreas,\r\n    isDrawing,\r\n    toggleDrawing\r\n  };\r\n}\r\n\r\nexport type { UseDrawingOptions, UseDrawingReturn };","/**\r\n * @layera/geo-drawing - Advanced Geometric Detection Algorithms\r\n *\r\n * Enterprise algorithms για intelligent shape recognition και measurement.\r\n * Integrates με existing calculation utilities.\r\n */\r\n\r\nimport * as L from 'leaflet';\r\nimport {\r\n  calculateDistance,\r\n  calculateCircleRadius,\r\n  calculateAngle,\r\n  detectCircleFromThreePoints\r\n} from './calculations';\r\nimport type {\r\n  MeasurementPoint,\r\n  CircleMeasurement,\r\n  ArcMeasurement,\r\n  MeasurementMode\r\n} from '../types';\r\n\r\n/**\r\n * Geometric shape detection thresholds\r\n */\r\nconst DETECTION_THRESHOLDS = {\r\n  /** Tolerance για circle detection (percentage deviation from perfect circle) */\r\n  CIRCLE_TOLERANCE: 0.05, // 5%\r\n\r\n  /** Minimum points required για reliable circle detection */\r\n  MIN_CIRCLE_POINTS: 3,\r\n\r\n  /** Maximum points to consider για circle detection (performance) */\r\n  MAX_CIRCLE_POINTS: 8,\r\n\r\n  /** Tolerance για line detection (max deviation from straight line) */\r\n  LINE_TOLERANCE: 5, // meters\r\n\r\n  /** Tolerance για right angle detection */\r\n  RIGHT_ANGLE_TOLERANCE: Math.PI / 36, // 5 degrees in radians\r\n\r\n  /** Minimum distance between points to be considered significant */\r\n  MIN_SIGNIFICANT_DISTANCE: 1 // meters\r\n} as const;\r\n\r\n/**\r\n * Detected geometry types\r\n */\r\nexport type DetectedGeometry =\r\n  | { type: 'circle'; properties: CircleMeasurement }\r\n  | { type: 'arc'; properties: ArcMeasurement }\r\n  | { type: 'line'; properties: { start: L.LatLng; end: L.LatLng; length: number } }\r\n  | { type: 'rectangle'; properties: { corners: L.LatLng[]; area: number; perimeter: number } }\r\n  | { type: 'triangle'; properties: { vertices: L.LatLng[]; area: number; angles: number[] } }\r\n  | { type: 'polygon'; properties: { vertices: L.LatLng[]; area: number; perimeter: number } }\r\n  | { type: 'unknown'; properties: Record<string, never> };\r\n\r\n/**\r\n * Analyzes a set of points και detects the most likely geometric shape\r\n */\r\nexport const detectGeometry = (points: MeasurementPoint[]): DetectedGeometry => {\r\n  if (points.length < 2) {\r\n    return { type: 'unknown', properties: {} };\r\n  }\r\n\r\n  const latlngs = points.map(p => p.latlng);\r\n\r\n  // Try circle detection first (most specific)\r\n  if (points.length >= DETECTION_THRESHOLDS.MIN_CIRCLE_POINTS) {\r\n    const circleResult = detectCircle(latlngs);\r\n    if (circleResult) {\r\n      return { type: 'circle', properties: circleResult };\r\n    }\r\n  }\r\n\r\n  // Try line detection\r\n  if (points.length === 2) {\r\n    return {\r\n      type: 'line',\r\n      properties: {\r\n        start: latlngs[0]!,\r\n        end: latlngs[1]!,\r\n        length: calculateDistance(latlngs)\r\n      }\r\n    };\r\n  }\r\n\r\n  // Try rectangle detection\r\n  if (points.length === 4 || points.length === 5) {\r\n    const rectangleResult = detectRectangle(latlngs);\r\n    if (rectangleResult) {\r\n      return { type: 'rectangle', properties: rectangleResult };\r\n    }\r\n  }\r\n\r\n  // Try triangle detection\r\n  if (points.length === 3 || points.length === 4) {\r\n    const triangleResult = detectTriangle(latlngs.slice(0, 3));\r\n    if (triangleResult) {\r\n      return { type: 'triangle', properties: triangleResult };\r\n    }\r\n  }\r\n\r\n  // Default to polygon\r\n  return detectPolygon(latlngs);\r\n};\r\n\r\n/**\r\n * Detects if points form a circle\r\n */\r\nconst detectCircle = (points: L.LatLng[]): CircleMeasurement | null => {\r\n  if (points.length < DETECTION_THRESHOLDS.MIN_CIRCLE_POINTS) {\r\n    return null;\r\n  }\r\n\r\n  // Take subset of points για performance\r\n  const samplePoints = points.length > DETECTION_THRESHOLDS.MAX_CIRCLE_POINTS\r\n    ? samplePointsEvenly(points, DETECTION_THRESHOLDS.MAX_CIRCLE_POINTS)\r\n    : points;\r\n\r\n  // Try to find circle από first 3 points\r\n  const circleFromThree = detectCircleFromThreePoints(\r\n    samplePoints[0]!,\r\n    samplePoints[1]!,\r\n    samplePoints[2]!\r\n  );\r\n\r\n  if (!circleFromThree) {\r\n    return null;\r\n  }\r\n\r\n  const { center, radius } = circleFromThree;\r\n\r\n  // Verify all other points fit the circle within tolerance\r\n  let totalDeviation = 0;\r\n  let validPoints = 0;\r\n\r\n  for (const point of samplePoints) {\r\n    const distanceToCenter = calculateCircleRadius(center, point);\r\n    const deviation = Math.abs(distanceToCenter - radius) / radius;\r\n\r\n    if (deviation <= DETECTION_THRESHOLDS.CIRCLE_TOLERANCE) {\r\n      validPoints++;\r\n    }\r\n    totalDeviation += deviation;\r\n  }\r\n\r\n  // Require at least 80% of points to fit circle\r\n  const validRatio = validPoints / samplePoints.length;\r\n  if (validRatio < 0.8) {\r\n    return null;\r\n  }\r\n\r\n  // Calculate circle properties\r\n  const area = Math.PI * radius * radius;\r\n  const circumference = 2 * Math.PI * radius;\r\n  const diameter = 2 * radius;\r\n\r\n  return {\r\n    center,\r\n    radius,\r\n    area,\r\n    circumference,\r\n    diameter\r\n  };\r\n};\r\n\r\n/**\r\n * Detects if points form a rectangle\r\n */\r\nconst detectRectangle = (points: L.LatLng[]): { corners: L.LatLng[]; area: number; perimeter: number } | null => {\r\n  if (points.length !== 4 && points.length !== 5) {\r\n    return null;\r\n  }\r\n\r\n  // If 5 points, assume last point closes the rectangle\r\n  const corners = points.length === 5 ? points.slice(0, 4) : points;\r\n\r\n  // Check if we have 4 right angles\r\n  const angles: number[] = [];\r\n  for (let i = 0; i < 4; i++) {\r\n    const prev = corners[(i + 3) % 4]!;\r\n    const current = corners[i]!;\r\n    const next = corners[(i + 1) % 4]!;\r\n\r\n    const angle = calculateAngle(prev, current, next);\r\n    angles.push(angle);\r\n  }\r\n\r\n  // Check if all angles are approximately 90 degrees\r\n  const rightAngle = Math.PI / 2;\r\n  const rightAngleCount = angles.filter(angle =>\r\n    Math.abs(angle - rightAngle) <= DETECTION_THRESHOLDS.RIGHT_ANGLE_TOLERANCE\r\n  ).length;\r\n\r\n  if (rightAngleCount < 3) { // Allow one angle to be slightly off\r\n    return null;\r\n  }\r\n\r\n  // Calculate area using shoelace formula\r\n  let area = 0;\r\n  for (let i = 0; i < 4; i++) {\r\n    const current = corners[i]!;\r\n    const next = corners[(i + 1) % 4]!;\r\n    area += (current.lng * next.lat - next.lng * current.lat);\r\n  }\r\n  area = Math.abs(area) / 2;\r\n\r\n  // Calculate perimeter\r\n  let perimeter = 0;\r\n  for (let i = 0; i < 4; i++) {\r\n    const current = corners[i]!;\r\n    const next = corners[(i + 1) % 4]!;\r\n    perimeter += calculateDistance([current, next]);\r\n  }\r\n\r\n  return {\r\n    corners,\r\n    area,\r\n    perimeter\r\n  };\r\n};\r\n\r\n/**\r\n * Detects triangle properties\r\n */\r\nconst detectTriangle = (points: L.LatLng[]): { vertices: L.LatLng[]; area: number; angles: number[] } | null => {\r\n  if (points.length < 3) {\r\n    return null;\r\n  }\r\n\r\n  const vertices = points.slice(0, 3);\r\n\r\n  // Calculate angles\r\n  const angles = [\r\n    calculateAngle(vertices[2]!, vertices[0]!, vertices[1]!),\r\n    calculateAngle(vertices[0]!, vertices[1]!, vertices[2]!),\r\n    calculateAngle(vertices[1]!, vertices[2]!, vertices[0]!)\r\n  ];\r\n\r\n  // Calculate area using cross product\r\n  const a = vertices[0]!;\r\n  const b = vertices[1]!;\r\n  const c = vertices[2]!;\r\n\r\n  const area = Math.abs(\r\n    (b.lat - a.lat) * (c.lng - a.lng) - (c.lat - a.lat) * (b.lng - a.lng)\r\n  ) / 2;\r\n\r\n  return {\r\n    vertices,\r\n    area,\r\n    angles\r\n  };\r\n};\r\n\r\n/**\r\n * Default polygon detection\r\n */\r\nconst detectPolygon = (points: L.LatLng[]): DetectedGeometry => {\r\n  if (points.length < 3) {\r\n    return { type: 'unknown', properties: {} };\r\n  }\r\n\r\n  // Calculate area using shoelace formula\r\n  let area = 0;\r\n  const n = points.length;\r\n  for (let i = 0; i < n; i++) {\r\n    const current = points[i]!;\r\n    const next = points[(i + 1) % n]!;\r\n    area += (current.lng * next.lat - next.lng * current.lat);\r\n  }\r\n  area = Math.abs(area) / 2;\r\n\r\n  // Calculate perimeter\r\n  let perimeter = 0;\r\n  for (let i = 0; i < n; i++) {\r\n    const current = points[i]!;\r\n    const next = points[(i + 1) % n]!;\r\n    perimeter += calculateDistance([current, next]);\r\n  }\r\n\r\n  return {\r\n    type: 'polygon',\r\n    properties: {\r\n      vertices: points,\r\n      area,\r\n      perimeter\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Samples points evenly από a larger set\r\n */\r\nconst samplePointsEvenly = (points: L.LatLng[], targetCount: number): L.LatLng[] => {\r\n  if (points.length <= targetCount) {\r\n    return points;\r\n  }\r\n\r\n  const result: L.LatLng[] = [];\r\n  const step = points.length / targetCount;\r\n\r\n  for (let i = 0; i < targetCount; i++) {\r\n    const index = Math.floor(i * step);\r\n    const point = points[index];\r\n    if (point) {\r\n      result.push(point);\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Suggests the most appropriate measurement mode based on detected geometry\r\n */\r\nexport const suggestMeasurementMode = (detectedGeometry: DetectedGeometry): MeasurementMode => {\r\n  switch (detectedGeometry.type) {\r\n    case 'circle':\r\n      return 'circle-area';\r\n    case 'line':\r\n      return 'distance';\r\n    case 'rectangle':\r\n    case 'triangle':\r\n    case 'polygon':\r\n      return 'area';\r\n    case 'arc':\r\n      return 'arc-length';\r\n    default:\r\n      return 'point';\r\n  }\r\n};\r\n\r\n/**\r\n * Calculates confidence score για detected geometry (0-1)\r\n */\r\nexport const calculateDetectionConfidence = (\r\n  points: MeasurementPoint[],\r\n  detectedGeometry: DetectedGeometry\r\n): number => {\r\n  if (points.length < 2) {\r\n    return 0;\r\n  }\r\n\r\n  switch (detectedGeometry.type) {\r\n    case 'circle':\r\n      return calculateCircleConfidence(points.map(p => p.latlng), detectedGeometry.properties);\r\n\r\n    case 'line':\r\n      return points.length === 2 ? 1.0 : 0.5;\r\n\r\n    case 'rectangle':\r\n      return calculateRectangleConfidence(points.map(p => p.latlng));\r\n\r\n    case 'triangle':\r\n      return points.length === 3 ? 0.9 : 0.6;\r\n\r\n    case 'polygon':\r\n      return 0.7; // Moderate confidence για general polygons\r\n\r\n    default:\r\n      return 0.1;\r\n  }\r\n};\r\n\r\n/**\r\n * Calculates confidence για circle detection\r\n */\r\nconst calculateCircleConfidence = (points: L.LatLng[], circle: CircleMeasurement): number => {\r\n  let totalDeviation = 0;\r\n\r\n  for (const point of points) {\r\n    const distanceToCenter = calculateCircleRadius(circle.center, point);\r\n    const deviation = Math.abs(distanceToCenter - circle.radius) / circle.radius;\r\n    totalDeviation += deviation;\r\n  }\r\n\r\n  const averageDeviation = totalDeviation / points.length;\r\n  return Math.max(0, 1 - (averageDeviation / DETECTION_THRESHOLDS.CIRCLE_TOLERANCE));\r\n};\r\n\r\n/**\r\n * Calculates confidence για rectangle detection\r\n */\r\nconst calculateRectangleConfidence = (points: L.LatLng[]): number => {\r\n  if (points.length !== 4 && points.length !== 5) {\r\n    return 0;\r\n  }\r\n\r\n  const corners = points.length === 5 ? points.slice(0, 4) : points;\r\n  const rightAngle = Math.PI / 2;\r\n  let rightAngleCount = 0;\r\n\r\n  for (let i = 0; i < 4; i++) {\r\n    const prev = corners[(i + 3) % 4]!;\r\n    const current = corners[i]!;\r\n    const next = corners[(i + 1) % 4]!;\r\n\r\n    const angle = calculateAngle(prev, current, next);\r\n    if (Math.abs(angle - rightAngle) <= DETECTION_THRESHOLDS.RIGHT_ANGLE_TOLERANCE) {\r\n      rightAngleCount++;\r\n    }\r\n  }\r\n\r\n  return rightAngleCount / 4;\r\n};","/**\r\n * @layera/geo-drawing - Map Labels Integration\r\n *\r\n * Enterprise integration με @layera/map-labels για unified annotations.\r\n * Converts measurement results σε map label configurations.\r\n */\r\n\r\nimport * as L from 'leaflet';\r\nimport {\r\n  calculateDistance\r\n} from './calculations';\r\nimport type {\r\n  MeasurementResult,\r\n  MeasurementPoint,\r\n  CircleMeasurement\r\n} from '../types';\r\nimport type { DetectedGeometry } from './geometryDetection';\r\n\r\n/**\r\n * Map label configuration για @layera/map-labels integration\r\n */\r\nexport interface MapLabelConfig {\r\n  /** Position για το label */\r\n  position: L.LatLng;\r\n  /** Text content */\r\n  text: string;\r\n  /** Label variant type */\r\n  variant: 'title' | 'subtitle' | 'area' | 'distance' | 'info' | 'warning' | 'success';\r\n  /** Background type */\r\n  background: 'transparent' | 'semi-transparent' | 'solid';\r\n  /** Text alignment */\r\n  align?: 'left' | 'center' | 'right';\r\n  /** Whether label is clickable */\r\n  clickable?: boolean;\r\n  /** Custom CSS classes */\r\n  customClasses?: string[];\r\n  /** Z-index priority */\r\n  priority?: 'normal' | 'high' | 'critical';\r\n}\r\n\r\n/**\r\n * Μεταφέρει measurement result σε map label configuration\r\n */\r\nexport const measurementToMapLabel = (\r\n  measurement: MeasurementResult,\r\n  options: {\r\n    showUnits?: boolean;\r\n    locale?: string;\r\n    precision?: number;\r\n    customPosition?: L.LatLng;\r\n  } = {}\r\n): MapLabelConfig => {\r\n  const {\r\n    showUnits = true,\r\n    locale = 'el-GR',\r\n    precision,\r\n    customPosition\r\n  } = options;\r\n\r\n  // Calculate optimal position\r\n  const position = customPosition || calculateOptimalLabelPosition(measurement.points);\r\n\r\n  // Determine variant based on measurement type\r\n  const variant = getVariantForMeasurementType(measurement.type);\r\n\r\n  // Format display text\r\n  const text = formatMeasurementForLabel(measurement, {\r\n    showUnits,\r\n    locale,\r\n    precision: precision ?? undefined\r\n  });\r\n\r\n  return {\r\n    position,\r\n    text,\r\n    variant,\r\n    background: 'semi-transparent',\r\n    align: 'center',\r\n    clickable: true,\r\n    priority: 'normal'\r\n  };\r\n};\r\n\r\n/**\r\n * Μεταφέρει detected geometry σε multiple map labels\r\n */\r\nexport const geometryToMapLabels = (\r\n  geometry: DetectedGeometry,\r\n  points: MeasurementPoint[],\r\n  options: {\r\n    showDetails?: boolean;\r\n    locale?: string;\r\n    showCoordinates?: boolean;\r\n  } = {}\r\n): MapLabelConfig[] => {\r\n  const { showCoordinates = false } = options;\r\n  const labels: MapLabelConfig[] = [];\r\n\r\n  switch (geometry.type) {\r\n    case 'circle':\r\n      labels.push(...createCircleLabels(geometry.properties, options));\r\n      break;\r\n\r\n    case 'rectangle':\r\n      labels.push(...createRectangleLabels(geometry.properties, options));\r\n      break;\r\n\r\n    case 'triangle':\r\n      labels.push(...createTriangleLabels(geometry.properties, options));\r\n      break;\r\n\r\n    case 'line':\r\n      labels.push(createLineLabel(geometry.properties, options));\r\n      break;\r\n\r\n    case 'polygon':\r\n      labels.push(...createPolygonLabels(geometry.properties, options));\r\n      break;\r\n\r\n    default:\r\n      // Create basic point labels\r\n      if (showCoordinates) {\r\n        labels.push(...createPointLabels(points, options));\r\n      }\r\n  }\r\n\r\n  return labels;\r\n};\r\n\r\n/**\r\n * Creates circle-specific labels\r\n */\r\nconst createCircleLabels = (\r\n  circle: CircleMeasurement,\r\n  options: { showDetails?: boolean; locale?: string }\r\n): MapLabelConfig[] => {\r\n  const labels: MapLabelConfig[] = [];\r\n  const { showDetails = true, locale = 'el-GR' } = options;\r\n\r\n  // Main area label at center\r\n  labels.push({\r\n    position: circle.center,\r\n    text: formatArea(circle.area, locale),\r\n    variant: 'area',\r\n    background: 'semi-transparent',\r\n    align: 'center',\r\n    clickable: true,\r\n    priority: 'high'\r\n  });\r\n\r\n  if (showDetails) {\r\n    // Radius label\r\n    const radiusPosition = calculateRadiusLabelPosition(circle.center, circle.radius);\r\n    labels.push({\r\n      position: radiusPosition,\r\n      text: `R: ${formatDistance(circle.radius, locale)}`,\r\n      variant: 'distance',\r\n      background: 'semi-transparent',\r\n      align: 'center',\r\n      clickable: false,\r\n      priority: 'normal'\r\n    });\r\n\r\n    // Circumference label\r\n    const circumferencePosition = calculateCircumferenceLabelPosition(circle.center, circle.radius);\r\n    labels.push({\r\n      position: circumferencePosition,\r\n      text: `C: ${formatDistance(circle.circumference, locale)}`,\r\n      variant: 'info',\r\n      background: 'semi-transparent',\r\n      align: 'center',\r\n      clickable: false,\r\n      priority: 'normal'\r\n    });\r\n  }\r\n\r\n  return labels;\r\n};\r\n\r\n/**\r\n * Creates rectangle-specific labels\r\n */\r\nconst createRectangleLabels = (\r\n  rectangle: { corners: L.LatLng[]; area: number; perimeter: number },\r\n  options: { showDetails?: boolean; locale?: string }\r\n): MapLabelConfig[] => {\r\n  const labels: MapLabelConfig[] = [];\r\n  const { showDetails = true, locale = 'el-GR' } = options;\r\n\r\n  // Center area label\r\n  const center = calculatePolygonCenter(rectangle.corners);\r\n  labels.push({\r\n    position: center,\r\n    text: formatArea(rectangle.area, locale),\r\n    variant: 'area',\r\n    background: 'semi-transparent',\r\n    align: 'center',\r\n    clickable: true,\r\n    priority: 'high'\r\n  });\r\n\r\n  if (showDetails) {\r\n    // Perimeter label\r\n    labels.push({\r\n      position: calculatePerimeterLabelPosition(rectangle.corners),\r\n      text: `P: ${formatDistance(rectangle.perimeter, locale)}`,\r\n      variant: 'distance',\r\n      background: 'semi-transparent',\r\n      align: 'center',\r\n      clickable: false,\r\n      priority: 'normal'\r\n    });\r\n\r\n    // Side length labels\r\n    const sideLabels = calculateSideLengthLabels(rectangle.corners, locale);\r\n    labels.push(...sideLabels);\r\n  }\r\n\r\n  return labels;\r\n};\r\n\r\n/**\r\n * Creates triangle-specific labels\r\n */\r\nconst createTriangleLabels = (\r\n  triangle: { vertices: L.LatLng[]; area: number; angles: number[] },\r\n  options: { showDetails?: boolean; locale?: string }\r\n): MapLabelConfig[] => {\r\n  const labels: MapLabelConfig[] = [];\r\n  const { showDetails = true, locale = 'el-GR' } = options;\r\n\r\n  // Center area label\r\n  const center = calculatePolygonCenter(triangle.vertices);\r\n  labels.push({\r\n    position: center,\r\n    text: formatArea(triangle.area, locale),\r\n    variant: 'area',\r\n    background: 'semi-transparent',\r\n    align: 'center',\r\n    clickable: true,\r\n    priority: 'high'\r\n  });\r\n\r\n  if (showDetails) {\r\n    // Angle labels at each vertex\r\n    triangle.vertices.forEach((vertex, index) => {\r\n      const angleDegrees = (triangle.angles[index]! * 180) / Math.PI;\r\n      labels.push({\r\n        position: vertex,\r\n        text: `${angleDegrees.toFixed(1)}°`,\r\n        variant: 'info',\r\n        background: 'semi-transparent',\r\n        align: 'center',\r\n        clickable: false,\r\n        priority: 'normal'\r\n      });\r\n    });\r\n  }\r\n\r\n  return labels;\r\n};\r\n\r\n/**\r\n * Creates line label\r\n */\r\nconst createLineLabel = (\r\n  line: { start: L.LatLng; end: L.LatLng; length: number },\r\n  options: { locale?: string }\r\n): MapLabelConfig => {\r\n  const { locale = 'el-GR' } = options;\r\n\r\n  // Mid-point label\r\n  const midPoint = L.latLng(\r\n    (line.start.lat + line.end.lat) / 2,\r\n    (line.start.lng + line.end.lng) / 2\r\n  );\r\n\r\n  return {\r\n    position: midPoint,\r\n    text: formatDistance(line.length, locale),\r\n    variant: 'distance',\r\n    background: 'semi-transparent',\r\n    align: 'center',\r\n    clickable: true,\r\n    priority: 'normal'\r\n  };\r\n};\r\n\r\n/**\r\n * Creates polygon labels\r\n */\r\nconst createPolygonLabels = (\r\n  polygon: { vertices: L.LatLng[]; area: number; perimeter: number },\r\n  options: { showDetails?: boolean; locale?: string }\r\n): MapLabelConfig[] => {\r\n  const labels: MapLabelConfig[] = [];\r\n  const { showDetails = true, locale = 'el-GR' } = options;\r\n\r\n  // Center area label\r\n  const center = calculatePolygonCenter(polygon.vertices);\r\n  labels.push({\r\n    position: center,\r\n    text: formatArea(polygon.area, locale),\r\n    variant: 'area',\r\n    background: 'semi-transparent',\r\n    align: 'center',\r\n    clickable: true,\r\n    priority: 'high'\r\n  });\r\n\r\n  if (showDetails) {\r\n    // Perimeter label\r\n    labels.push({\r\n      position: calculatePerimeterLabelPosition(polygon.vertices),\r\n      text: `P: ${formatDistance(polygon.perimeter, locale)}`,\r\n      variant: 'distance',\r\n      background: 'semi-transparent',\r\n      align: 'center',\r\n      clickable: false,\r\n      priority: 'normal'\r\n    });\r\n  }\r\n\r\n  return labels;\r\n};\r\n\r\n/**\r\n * Creates point coordinate labels\r\n */\r\nconst createPointLabels = (\r\n  points: MeasurementPoint[],\r\n  options: { locale?: string }\r\n): MapLabelConfig[] => {\r\n  const { locale: _locale = 'el-GR' } = options;\r\n\r\n  return points.map((point, index) => ({\r\n    position: point.latlng,\r\n    text: point.label || `P${index + 1}`,\r\n    variant: 'info' as const,\r\n    background: 'transparent' as const,\r\n    align: 'center' as const,\r\n    clickable: true,\r\n    priority: 'normal' as const\r\n  }));\r\n};\r\n\r\n// Helper functions\r\n\r\nconst calculateOptimalLabelPosition = (points: MeasurementPoint[]): L.LatLng => {\r\n  if (points.length === 0) {\r\n    return L.latLng(0, 0);\r\n  }\r\n\r\n  const latlngs = points.map(p => p.latlng);\r\n  return calculatePolygonCenter(latlngs);\r\n};\r\n\r\nconst calculatePolygonCenter = (points: L.LatLng[]): L.LatLng => {\r\n  let latSum = 0;\r\n  let lngSum = 0;\r\n\r\n  for (const point of points) {\r\n    latSum += point.lat;\r\n    lngSum += point.lng;\r\n  }\r\n\r\n  return L.latLng(latSum / points.length, lngSum / points.length);\r\n};\r\n\r\nconst calculateRadiusLabelPosition = (center: L.LatLng, radius: number): L.LatLng => {\r\n  // Position label at 45 degrees από center\r\n  const bearing = Math.PI / 4; // 45 degrees\r\n  const distance = radius * 0.7; // 70% of radius\r\n\r\n  const lat = center.lat + (distance / 111320) * Math.cos(bearing);\r\n  const lng = center.lng + (distance / (111320 * Math.cos(center.lat * Math.PI / 180))) * Math.sin(bearing);\r\n\r\n  return L.latLng(lat, lng);\r\n};\r\n\r\nconst calculateCircumferenceLabelPosition = (center: L.LatLng, radius: number): L.LatLng => {\r\n  // Position label at 135 degrees από center\r\n  const bearing = (3 * Math.PI) / 4; // 135 degrees\r\n  const distance = radius * 1.1; // Slightly outside circle\r\n\r\n  const lat = center.lat + (distance / 111320) * Math.cos(bearing);\r\n  const lng = center.lng + (distance / (111320 * Math.cos(center.lat * Math.PI / 180))) * Math.sin(bearing);\r\n\r\n  return L.latLng(lat, lng);\r\n};\r\n\r\nconst calculatePerimeterLabelPosition = (vertices: L.LatLng[]): L.LatLng => {\r\n  // Find the longest edge και place label at its midpoint\r\n  let longestEdge = { start: vertices[0]!, end: vertices[1]!, length: 0 };\r\n\r\n  for (let i = 0; i < vertices.length; i++) {\r\n    const start = vertices[i]!;\r\n    const end = vertices[(i + 1) % vertices.length]!;\r\n    const length = calculateDistance([start, end]);\r\n\r\n    if (length > longestEdge.length) {\r\n      longestEdge = { start, end, length };\r\n    }\r\n  }\r\n\r\n  return L.latLng(\r\n    (longestEdge.start.lat + longestEdge.end.lat) / 2,\r\n    (longestEdge.start.lng + longestEdge.end.lng) / 2\r\n  );\r\n};\r\n\r\nconst calculateSideLengthLabels = (corners: L.LatLng[], locale: string): MapLabelConfig[] => {\r\n  const labels: MapLabelConfig[] = [];\r\n\r\n  for (let i = 0; i < corners.length; i++) {\r\n    const start = corners[i]!;\r\n    const end = corners[(i + 1) % corners.length]!;\r\n    const length = calculateDistance([start, end]);\r\n\r\n    const midPoint = L.latLng(\r\n      (start.lat + end.lat) / 2,\r\n      (start.lng + end.lng) / 2\r\n    );\r\n\r\n    labels.push({\r\n      position: midPoint,\r\n      text: formatDistance(length, locale),\r\n      variant: 'distance',\r\n      background: 'transparent',\r\n      align: 'center',\r\n      clickable: false,\r\n      priority: 'normal'\r\n    });\r\n  }\r\n\r\n  return labels;\r\n};\r\n\r\nconst getVariantForMeasurementType = (type: string): MapLabelConfig['variant'] => {\r\n  switch (type) {\r\n    case 'area':\r\n    case 'circle-area':\r\n      return 'area';\r\n    case 'distance':\r\n    case 'circle-radius':\r\n    case 'circle-diameter':\r\n    case 'circle-circumference':\r\n    case 'arc-length':\r\n      return 'distance';\r\n    case 'angle':\r\n      return 'info';\r\n    case 'perimeter':\r\n      return 'distance';\r\n    default:\r\n      return 'info';\r\n  }\r\n};\r\n\r\nconst formatMeasurementForLabel = (\r\n  measurement: MeasurementResult,\r\n  options: { showUnits?: boolean; locale?: string; precision?: number | undefined }\r\n): string => {\r\n  const { showUnits = true, locale = 'el-GR', precision } = options;\r\n\r\n  // Use existing displayValue if available\r\n  if (measurement.displayValue && showUnits) {\r\n    return measurement.displayValue;\r\n  }\r\n\r\n  // Format based on measurement type\r\n  switch (measurement.type) {\r\n    case 'area':\r\n    case 'circle-area':\r\n      return formatArea(measurement.area || 0, locale, precision);\r\n\r\n    case 'distance':\r\n      return formatDistance(measurement.distance || 0, locale, precision);\r\n\r\n    case 'circle-radius':\r\n      return formatDistance(measurement.radius || 0, locale, precision);\r\n\r\n    case 'circle-circumference':\r\n      return formatDistance(measurement.circumference || 0, locale, precision);\r\n\r\n    case 'circle-diameter':\r\n      return formatDistance(measurement.diameter || 0, locale, precision);\r\n\r\n    case 'arc-length':\r\n      return formatDistance(measurement.arcLength || 0, locale, precision);\r\n\r\n    case 'angle':\r\n      const degrees = ((measurement.angle || 0) * 180) / Math.PI;\r\n      return `${degrees.toFixed(precision || 1)}°`;\r\n\r\n    case 'perimeter':\r\n      return formatDistance(measurement.perimeter || 0, locale, precision);\r\n\r\n    default:\r\n      return measurement.displayValue || '';\r\n  }\r\n};\r\n\r\nconst formatArea = (area: number, _locale: string, precision?: number): string => {\r\n  // Simplified formatting - in production would use @layera/tolgee\r\n  if (area >= 1000000) {\r\n    return `${(area / 1000000).toFixed(precision || 2)} km²`;\r\n  } else if (area >= 10000) {\r\n    return `${(area / 10000).toFixed(precision || 1)} ha`;\r\n  } else {\r\n    return `${area.toFixed(precision || 0)} m²`;\r\n  }\r\n};\r\n\r\nconst formatDistance = (distance: number, _locale: string, precision?: number): string => {\r\n  // Simplified formatting - in production would use @layera/tolgee\r\n  if (distance >= 1000) {\r\n    return `${(distance / 1000).toFixed(precision || 2)} km`;\r\n  } else {\r\n    return `${distance.toFixed(precision || 0)} m`;\r\n  }\r\n};","/**\n * @layera/geo-drawing - LEGO System για geo-spatial drawing και measurement\n *\n * Ενσωματώνει functionality από OLD_geo-canvas με existing LEGO systems:\n * - @layera/snap-engine & @layera/snap-interactions για snapping\n * - @layera/tolgee για internationalization\n * - @layera/theme-switcher για theme-aware colors\n * - @layera/buttons, @layera/cards, @layera/typography για UI\n * - @layera/constants για configuration\n * - @layera/notifications για user feedback\n */\n\n// Types\nexport type {\n  MeasurementMode,\n  DrawingState,\n  GeometryType,\n  MeasurementPoint,\n  MeasurementResult,\n  CircleMeasurement,\n  ArcMeasurement,\n  AngleMeasurement,\n  OSMBuildingProperties,\n  OSMBuildingFeature,\n  GeoJSONFeatureCollection,\n  DrawingConfig,\n  CanvasInteractionEvent\n} from './types';\n\n// Compatibility layer για @layera/map-drawing migration\nexport type { DrawnArea } from '@layera/map-core';\nexport type DrawingMode = 'none' | 'polygon' | 'marker' | 'circle';\n\n// Legacy drawing interface για backward compatibility\nexport interface LegacyDrawingState {\n  activeMode: DrawingMode;\n  drawnAreas: import('@layera/map-core').DrawnArea[];\n}\n\n\n// Core Hooks\nexport { useMeasurement } from './hooks/useMeasurement';\nexport { useGeometrySnap } from './hooks/useGeometrySnap';\n\n// Legacy compatibility hooks\nexport { useDrawing } from './hooks/useDrawing';\nexport type { UseDrawingOptions, UseDrawingReturn } from './hooks/useDrawing';\n\n// Components - Temporarily disabled during migration\n// export { MeasurementControls } from './components/MeasurementControls';\n// export { MeasurementCanvas } from './components/MeasurementCanvas';\n// export { GeometryRenderer } from './components/GeometryRenderer';\n\n// Utilities\nexport {\n  calculateProjectedArea,\n  calculateDistance,\n  calculatePointDistance,\n  calculatePolygonCenter,\n  calculatePerimeter,\n  isPointInPolygon,\n  calculateBounds,\n  calculateCircleRadius,\n  calculateCircleArea,\n  calculateCircleCircumference,\n  calculateCircleDiameter,\n  calculateArcLength,\n  calculateAngle,\n  detectCircleFromThreePoints\n} from './utils/calculations';\n\nexport {\n  formatDistance,\n  formatArea,\n  useMeasurementFormatter,\n  formatCoordinatesBySystem,\n  formatBearing\n} from './utils/formatters';\n\nexport {\n  detectGeometry,\n  suggestMeasurementMode,\n  calculateDetectionConfidence\n} from './utils/geometryDetection';\n\nexport type { DetectedGeometry } from './utils/geometryDetection';\n\nexport {\n  measurementToMapLabel,\n  geometryToMapLabels\n} from './utils/mapLabelIntegration';\n\nexport type { MapLabelConfig } from './utils/mapLabelIntegration';\n\n// Geometry utilities - Temporarily disabled during migration due to TypeScript strict mode issues\n// export {\n//   geoJsonToLatLng,\n//   latLngToGeoJson,\n//   closestPointOnSegment,\n//   arePointsEqual,\n//   simplifyPolygon,\n//   calculateBearing,\n//   extractOSMGeometry\n// } from './utils/geometry';\n\n// Services\nexport {\n  fetchBuildingOutlines,\n  clearOSMCache,\n  getCacheSize,\n  isBoundsCached,\n  prefetchBuildingOutlines,\n  fetchAdministrativeBoundary,\n  fetchBoundaryByAddressComponent\n} from './services/osmService';\n\n// Constants που θα προστεθούν στο @layera/constants\nexport const GEO_DRAWING_CONSTANTS = {\n  DEFAULT_SNAP_TOLERANCE: 15,\n  MIN_SNAP_ZOOM: 16,\n  DEBOUNCE_MS: 500,\n  REQUEST_TIMEOUT: 30000\n} as const;"],"mappings":"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","names":["useLayeraTranslation","point","useLayeraTranslation","useState","useCallback","useRef","useState","useRef","useCallback","point","useState","useCallback","point","L","formatArea","formatDistance","calculatePolygonCenter","point"]}