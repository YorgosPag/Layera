{"version":3,"sources":["../src/index.ts","../src/service.ts","../src/types/index.ts","../src/factory.ts"],"sourcesContent":["/**\r\n * @layera/boundary-service - Main Export\r\n *\r\n * Enterprise boundary service ŒºŒµ Œ∫Œ±Œ∏ŒøŒªŒπŒ∫ŒÆ œÖœÄŒøœÉœÑŒÆœÅŒπŒæŒ∑ œÄŒµœÅŒπŒøœáœéŒΩ\r\n */\r\n\r\n// Main service\r\nexport { BoundaryService } from './service';\r\n\r\n// Types\r\nexport type {\r\n  BoundaryServiceConfig,\r\n  BoundaryProvider,\r\n  BoundaryOptions,\r\n  BoundaryResult,\r\n  BoundaryMetadata,\r\n  ProviderConfig,\r\n  ProviderApiConfig,\r\n  ProviderOptions,\r\n  BoundingBox,\r\n  CacheConfig,\r\n  QueueConfig,\r\n  RetryConfig,\r\n  ProviderHealth,\r\n  ServiceHealth,\r\n  GeocodingResult,\r\n  QueueRequest,\r\n  QueueProcessor,\r\n  QueueStats,\r\n  BoundaryEvent,\r\n  BoundarySubscriptionCallback,\r\n  BoundaryServiceError,\r\n  ProviderError,\r\n  CacheError,\r\n  QueueError\r\n} from './types';\r\n\r\n// Factory function Œ≥ŒπŒ± quick setup\r\nexport { createBoundaryService } from './factory';\r\n\r\n// Version\r\nexport const BOUNDARY_SERVICE_VERSION = '1.0.0';","/**\r\n * @layera/boundary-service - Main Service\r\n *\r\n * Enterprise boundary service ŒºŒµ Œ∫Œ±Œ∏ŒøŒªŒπŒ∫ŒÆ œÖœÄŒøœÉœÑŒÆœÅŒπŒæŒ∑ œÄŒµœÅŒπŒøœáœéŒΩ\r\n * Multi-provider fallback Œ∫Œ±Œπ intelligent caching\r\n */\r\n\r\nimport { DatabaseNamespace, FirestoreCache } from '@layera/database-core';\r\nimport type { GeoJSONFeatureCollection } from '@layera/geo-core';\r\nimport type {\r\n  BoundaryServiceConfig,\r\n  BoundaryProvider,\r\n  BoundaryOptions,\r\n  BoundaryResult,\r\n  ServiceHealth,\r\n  GeocodingResult\r\n} from './types';\r\nimport { BoundaryServiceError } from './types';\r\n\r\n/**\r\n * Main boundary service class\r\n */\r\nexport class BoundaryService {\r\n  private providers: BoundaryProvider[] = [];\r\n  private cache: FirestoreCache;\r\n  private _namespace: DatabaseNamespace;\r\n  private config: BoundaryServiceConfig;\r\n\r\n  constructor(config: BoundaryServiceConfig, namespace: DatabaseNamespace) {\r\n    this.config = config;\r\n    this._namespace = namespace;\r\n    this.cache = new FirestoreCache(\r\n      this._namespace,\r\n      'boundaries_cache',\r\n      config.cache?.ttl || 30 * 24 * 60 * 60 * 1000 // 30 days default\r\n    );\r\n\r\n    console.log('üó∫Ô∏è BoundaryService initialized');\r\n  }\r\n\r\n  /**\r\n   * Get boundary Œ≥ŒπŒ± search query ŒºŒµ fallback chain\r\n   */\r\n  async getBoundary(\r\n    query: string,\r\n    options: BoundaryOptions = {}\r\n  ): Promise<BoundaryResult> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      console.log(`üîç Boundary search: \"${query}\"`);\r\n\r\n      // 1. Check cache first (unless force fresh)\r\n      if (!options.forceFresh) {\r\n        const cached = await this.getCachedBoundary(query, options);\r\n        if (cached) {\r\n          console.log(`‚ö° Cache hit Œ≥ŒπŒ±: ${query}`);\r\n          return {\r\n            boundary: cached,\r\n            metadata: {\r\n              source: 'cache',\r\n              query,\r\n              responseTime: Date.now() - startTime,\r\n              fromCache: true,\r\n              confidence: 1.0,\r\n              isApproximate: false\r\n            }\r\n          };\r\n        }\r\n      }\r\n\r\n      // 2. Try providers in priority order\r\n      for (const provider of this.getSortedProviders()) {\r\n        try {\r\n          if (!(await provider.isAvailable())) {\r\n            console.warn(`‚ö†Ô∏è Provider ${provider.name} not available`);\r\n            continue;\r\n          }\r\n\r\n          const result = await Promise.race([\r\n            provider.fetchBoundary(query, options),\r\n            this.createTimeout(options.timeout || 5000)\r\n          ]);\r\n\r\n          if (result && result.boundary.features.length > 0) {\r\n            console.log(`‚úÖ Found boundary via ${provider.name}`);\r\n\r\n            // Cache successful result\r\n            await this.cacheBoundary(query, result.boundary, options);\r\n\r\n            return {\r\n              boundary: result.boundary,\r\n              metadata: {\r\n                ...result.metadata,\r\n                responseTime: Date.now() - startTime,\r\n                fromCache: false\r\n              }\r\n            };\r\n          }\r\n\r\n        } catch (error) {\r\n          console.warn(`‚ö†Ô∏è Provider ${provider.name} failed:`, error instanceof Error ? error.message : 'Unknown error');\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // 3. Generate approximate boundary as fallback\r\n      if (options.includeApproximate !== false) {\r\n        console.log(`üéØ Generating approximate boundary Œ≥ŒπŒ±: ${query}`);\r\n        const approximateBoundary = await this.generateApproximateBoundary(query);\r\n\r\n        return {\r\n          boundary: approximateBoundary,\r\n          metadata: {\r\n            source: 'approximate',\r\n            query,\r\n            responseTime: Date.now() - startTime,\r\n            fromCache: false,\r\n            confidence: 0.3,\r\n            isApproximate: true\r\n          }\r\n        };\r\n      }\r\n\r\n      // 4. No results found\r\n      throw new BoundaryServiceError(\r\n        `No boundary found Œ≥ŒπŒ±: ${query}`,\r\n        'NOT_FOUND'\r\n      );\r\n\r\n    } catch (error) {\r\n      console.error(`üö´ Boundary search failed Œ≥ŒπŒ±: ${query}`, error);\r\n\r\n      if (error instanceof BoundaryServiceError) {\r\n        throw error;\r\n      }\r\n\r\n      throw new BoundaryServiceError(\r\n        `Boundary search failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        'SEARCH_FAILED'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe to boundary updates Œ≥ŒπŒ± query\r\n   */\r\n  subscribeToBoundary(\r\n    query: string,\r\n    callback: (result: BoundaryResult | null) => void,\r\n    options: BoundaryOptions = {}\r\n  ): () => void {\r\n    // Immediate result Œ±œÄœå cache ŒÆ null\r\n    this.getCachedBoundary(query, options)\r\n      .then(boundary => {\r\n        if (boundary) {\r\n          callback({\r\n            boundary,\r\n            metadata: {\r\n              source: 'cache',\r\n              query,\r\n              responseTime: 0,\r\n              fromCache: true,\r\n              confidence: 1.0,\r\n              isApproximate: false\r\n            }\r\n          });\r\n        } else {\r\n          callback(null);\r\n        }\r\n      })\r\n      .catch(() => callback(null));\r\n\r\n    // Queue background fetch if not cached\r\n    this.queueBackgroundFetch(query, options, callback);\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      // Cleanup subscription\r\n      console.log(`üîÑ Unsubscribed Œ±œÄœå boundary updates Œ≥ŒπŒ±: ${query}`);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get service health status\r\n   */\r\n  async getHealth(): Promise<ServiceHealth> {\r\n    const providerHealthPromises = this.providers.map(p => p.getHealth());\r\n    const providerHealthResults = await Promise.allSettled(providerHealthPromises);\r\n\r\n    const providers = providerHealthResults.map((result, index) => {\r\n      if (result.status === 'fulfilled') {\r\n        return result.value;\r\n      } else {\r\n        return {\r\n          provider: this.providers[index]?.name || 'unknown',\r\n          status: 'down' as const,\r\n          responseTime: -1,\r\n          successRate: 0,\r\n          errorCount: 1,\r\n          lastSuccess: null,\r\n          lastError: result.reason instanceof Error ? result.reason.message : 'Unknown error'\r\n        };\r\n      }\r\n    });\r\n\r\n    const cacheStats = await this.cache.stats();\r\n    const healthyProviders = providers.filter(p => p.status === 'healthy').length;\r\n\r\n    return {\r\n      status: healthyProviders > 0 ? 'healthy' : 'down',\r\n      providers,\r\n      cache: {\r\n        status: cacheStats.keys > 0 ? 'healthy' : 'degraded',\r\n        hitRate: cacheStats.hitRate,\r\n        size: cacheStats.keys\r\n      },\r\n      queue: {\r\n        status: 'healthy', // TODO: Implement queue stats\r\n        size: 0,\r\n        processingRate: 0\r\n      },\r\n      lastCheck: new Date()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear service cache\r\n   */\r\n  async clearCache(): Promise<void> {\r\n    await this.cache.clear();\r\n    console.log('üßπ Boundary service cache cleared');\r\n  }\r\n\r\n  // Private methods\r\n\r\n  private async getCachedBoundary(\r\n    query: string,\r\n    options: BoundaryOptions\r\n  ): Promise<GeoJSONFeatureCollection | null> {\r\n    const cacheKey = this.createCacheKey(query, options);\r\n    return await this.cache.get<GeoJSONFeatureCollection>(cacheKey);\r\n  }\r\n\r\n  private async cacheBoundary(\r\n    query: string,\r\n    boundary: GeoJSONFeatureCollection,\r\n    options: BoundaryOptions\r\n  ): Promise<void> {\r\n    const cacheKey = this.createCacheKey(query, options);\r\n    const ttl = this.config.cache?.ttl || 30 * 24 * 60 * 60 * 1000;\r\n    await this.cache.set(cacheKey, boundary, ttl);\r\n  }\r\n\r\n  private createCacheKey(query: string, options: BoundaryOptions): string {\r\n    const normalizedQuery = query.toLowerCase().trim();\r\n    const optionsHash = JSON.stringify({\r\n      adminLevels: options.adminLevels?.sort(),\r\n      language: options.language,\r\n      countryCode: options.countryCode\r\n    });\r\n\r\n    return `boundary:${normalizedQuery}:${Buffer.from(optionsHash).toString('base64')}`;\r\n  }\r\n\r\n  private getSortedProviders(): BoundaryProvider[] {\r\n    return [...this.providers].sort((a, b) => a.priority - b.priority);\r\n  }\r\n\r\n  private async generateApproximateBoundary(query: string): Promise<GeoJSONFeatureCollection> {\r\n    try {\r\n      // Simplified geocoding - œÉœÑŒ∑ŒΩ œÄœÅŒ¨ŒæŒ∑ Œ∏Œ± œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒøœçœÉŒµ @layera/geocoding\r\n      const geocodingResult = await this.geocodeLocation(query);\r\n\r\n      if (geocodingResult) {\r\n        // Create bounding box around coordinates\r\n        const { latitude, longitude } = geocodingResult.coordinates;\r\n        const radius = 0.01; // ~1km radius\r\n\r\n        const coordinates = [\r\n          [longitude - radius, latitude - radius],\r\n          [longitude + radius, latitude - radius],\r\n          [longitude + radius, latitude + radius],\r\n          [longitude - radius, latitude + radius],\r\n          [longitude - radius, latitude - radius] // Close polygon\r\n        ];\r\n\r\n        return {\r\n          type: 'FeatureCollection',\r\n          features: [{\r\n            type: 'Feature',\r\n            properties: {\r\n              name: geocodingResult.name,\r\n              approximate: true,\r\n              confidence: geocodingResult.confidence\r\n            },\r\n            geometry: {\r\n              type: 'Polygon',\r\n              coordinates: [coordinates]\r\n            }\r\n          }]\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.warn(`‚ö†Ô∏è Geocoding failed Œ≥ŒπŒ±: ${query}`, error);\r\n    }\r\n\r\n    // Ultimate fallback - global bounding box\r\n    return {\r\n      type: 'FeatureCollection',\r\n      features: [{\r\n        type: 'Feature',\r\n        properties: {\r\n          name: query,\r\n          approximate: true,\r\n          confidence: 0.1,\r\n          fallback: true\r\n        },\r\n        geometry: {\r\n          type: 'Polygon',\r\n          coordinates: [[\r\n            [-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]\r\n          ]]\r\n        }\r\n      }]\r\n    };\r\n  }\r\n\r\n  private async geocodeLocation(_query: string): Promise<GeocodingResult | null> {\r\n    // Simplified implementation - œÉœÑŒ∑ŒΩ œÄœÅŒ¨ŒæŒ∑ Œ∏Œ± œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒøœçœÉŒµ proper geocoding service\r\n    // TODO: Integrate ŒºŒµ @layera/geocoding\r\n    return null;\r\n  }\r\n\r\n  private async queueBackgroundFetch(\r\n    query: string,\r\n    options: BoundaryOptions,\r\n    callback: (result: BoundaryResult | null) => void\r\n  ): Promise<void> {\r\n    // Background fetch implementation\r\n    setTimeout(async () => {\r\n      try {\r\n        const result = await this.getBoundary(query, { ...options, forceFresh: true });\r\n        callback(result);\r\n      } catch (error) {\r\n        console.warn(`‚ö†Ô∏è Background fetch failed Œ≥ŒπŒ±: ${query}`, error);\r\n        callback(null);\r\n      }\r\n    }, 100);\r\n  }\r\n\r\n  private createTimeout(ms: number): Promise<never> {\r\n    return new Promise((_, reject) => {\r\n      setTimeout(() => reject(new Error('Timeout')), ms);\r\n    });\r\n  }\r\n\r\n  // Provider management\r\n\r\n  /**\r\n   * Add provider to service\r\n   */\r\n  addProvider(provider: BoundaryProvider): void {\r\n    this.providers.push(provider);\r\n    this.providers.sort((a, b) => a.priority - b.priority);\r\n    console.log(`‚ûï Added boundary provider: ${provider.name} (priority: ${provider.priority})`);\r\n  }\r\n\r\n  /**\r\n   * Remove provider Œ±œÄœå service\r\n   */\r\n  removeProvider(providerName: string): void {\r\n    const index = this.providers.findIndex(p => p.name === providerName);\r\n    if (index >= 0) {\r\n      this.providers.splice(index, 1);\r\n      console.log(`‚ûñ Removed boundary provider: ${providerName}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get provider statistics\r\n   */\r\n  async getProviderStats(): Promise<Array<{ name: string; health: any }>> {\r\n    const stats = await Promise.allSettled(\r\n      this.providers.map(async provider => ({\r\n        name: provider.name,\r\n        health: await provider.getHealth()\r\n      }))\r\n    );\r\n\r\n    return stats\r\n      .filter((result): result is PromiseFulfilledResult<{ name: string; health: any }> =>\r\n        result.status === 'fulfilled'\r\n      )\r\n      .map(result => result.value);\r\n  }\r\n}","/**\r\n * @layera/boundary-service - Types\r\n *\r\n * Type definitions Œ≥ŒπŒ± enterprise boundary service\r\n * ŒöŒëŒúŒôŒë œáœÅŒÆœÉŒ∑ any - TypeScript strict mode\r\n */\r\n\r\nimport type { GeoJSONFeatureCollection } from '@layera/geo-core';\r\n\r\n/**\r\n * Boundary service configuration\r\n */\r\nexport interface BoundaryServiceConfig {\r\n  /** Providers configuration */\r\n  providers: ProviderConfig[];\r\n  /** Cache configuration */\r\n  cache?: CacheConfig;\r\n  /** Queue configuration */\r\n  queue?: QueueConfig;\r\n  /** Default options */\r\n  defaults?: BoundaryOptions;\r\n}\r\n\r\n/**\r\n * Provider configuration\r\n */\r\nexport interface ProviderConfig {\r\n  /** Provider type */\r\n  type: 'osm' | 'nominatim' | 'mapbox' | 'google';\r\n  /** Provider priority (lower = higher priority) */\r\n  priority: number;\r\n  /** API configuration */\r\n  config: ProviderApiConfig;\r\n  /** Provider-specific options */\r\n  options?: ProviderOptions;\r\n}\r\n\r\n/**\r\n * Provider API configuration\r\n */\r\nexport interface ProviderApiConfig {\r\n  /** API endpoint URL */\r\n  endpoint?: string;\r\n  /** API key (Œ≥ŒπŒ± paid services) */\r\n  apiKey?: string;\r\n  /** Request timeout in milliseconds */\r\n  timeout?: number;\r\n  /** Rate limiting */\r\n  rateLimit?: RateLimitConfig;\r\n}\r\n\r\n/**\r\n * Rate limiting configuration\r\n */\r\nexport interface RateLimitConfig {\r\n  /** Requests per second */\r\n  requestsPerSecond: number;\r\n  /** Burst limit */\r\n  burst?: number;\r\n}\r\n\r\n/**\r\n * Provider options\r\n */\r\nexport interface ProviderOptions {\r\n  /** Maximum results to return */\r\n  maxResults?: number;\r\n  /** Language preference */\r\n  language?: string;\r\n  /** Country bias */\r\n  countryBias?: string;\r\n  /** Bounding box Œ≥ŒπŒ± search area */\r\n  bbox?: BoundingBox;\r\n}\r\n\r\n/**\r\n * Bounding box\r\n */\r\nexport interface BoundingBox {\r\n  /** South latitude */\r\n  south: number;\r\n  /** West longitude */\r\n  west: number;\r\n  /** North latitude */\r\n  north: number;\r\n  /** East longitude */\r\n  east: number;\r\n}\r\n\r\n/**\r\n * Cache configuration\r\n */\r\nexport interface CacheConfig {\r\n  /** Cache TTL in milliseconds */\r\n  ttl: number;\r\n  /** Maximum cache size */\r\n  maxSize?: number;\r\n  /** Cleanup interval in milliseconds */\r\n  cleanupInterval?: number;\r\n}\r\n\r\n/**\r\n * Queue configuration\r\n */\r\nexport interface QueueConfig {\r\n  /** Maximum queue size */\r\n  maxSize: number;\r\n  /** Processing interval in milliseconds */\r\n  processingInterval: number;\r\n  /** Retry configuration */\r\n  retry: RetryConfig;\r\n}\r\n\r\n/**\r\n * Retry configuration\r\n */\r\nexport interface RetryConfig {\r\n  /** Maximum retry attempts */\r\n  maxAttempts: number;\r\n  /** Base delay in milliseconds */\r\n  baseDelay: number;\r\n  /** Exponential backoff multiplier */\r\n  backoffMultiplier: number;\r\n  /** Maximum delay in milliseconds */\r\n  maxDelay: number;\r\n}\r\n\r\n/**\r\n * Boundary search options\r\n */\r\nexport interface BoundaryOptions {\r\n  /** Administrative levels to search */\r\n  adminLevels?: number[];\r\n  /** Language preference */\r\n  language?: string;\r\n  /** Country code Œ≥ŒπŒ± filtering */\r\n  countryCode?: string;\r\n  /** Search timeout in milliseconds */\r\n  timeout?: number;\r\n  /** Force fresh API call (skip cache) */\r\n  forceFresh?: boolean;\r\n  /** Include approximate results */\r\n  includeApproximate?: boolean;\r\n}\r\n\r\n/**\r\n * Boundary result\r\n */\r\nexport interface BoundaryResult {\r\n  /** GeoJSON feature collection */\r\n  boundary: GeoJSONFeatureCollection;\r\n  /** Result metadata */\r\n  metadata: BoundaryMetadata;\r\n}\r\n\r\n/**\r\n * Boundary metadata\r\n */\r\nexport interface BoundaryMetadata {\r\n  /** Source provider */\r\n  source: string;\r\n  /** Search query used */\r\n  query: string;\r\n  /** Response time in milliseconds */\r\n  responseTime: number;\r\n  /** From cache flag */\r\n  fromCache: boolean;\r\n  /** Confidence score (0-1) */\r\n  confidence: number;\r\n  /** Is approximate result */\r\n  isApproximate: boolean;\r\n  /** Cache TTL in milliseconds */\r\n  cacheTtl?: number;\r\n  /** Administrative level */\r\n  adminLevel?: number;\r\n  /** Country code */\r\n  countryCode?: string;\r\n}\r\n\r\n/**\r\n * Provider interface\r\n */\r\nexport interface BoundaryProvider {\r\n  /** Provider name */\r\n  readonly name: string;\r\n  /** Provider priority */\r\n  readonly priority: number;\r\n  /** Provider configuration */\r\n  readonly config: ProviderApiConfig;\r\n\r\n  /** Check if provider is available */\r\n  isAvailable(): Promise<boolean>;\r\n  /** Fetch boundary Œ≥ŒπŒ± search query */\r\n  fetchBoundary(query: string, options?: BoundaryOptions): Promise<BoundaryResult | null>;\r\n  /** Get provider health status */\r\n  getHealth(): Promise<ProviderHealth>;\r\n}\r\n\r\n/**\r\n * Provider health status\r\n */\r\nexport interface ProviderHealth {\r\n  /** Provider name */\r\n  provider: string;\r\n  /** Health status */\r\n  status: 'healthy' | 'degraded' | 'down';\r\n  /** Response time in milliseconds */\r\n  responseTime: number;\r\n  /** Success rate percentage */\r\n  successRate: number;\r\n  /** Error count in last hour */\r\n  errorCount: number;\r\n  /** Last successful request timestamp */\r\n  lastSuccess: Date | null;\r\n  /** Last error */\r\n  lastError: string | null;\r\n}\r\n\r\n/**\r\n * Queue request\r\n */\r\nexport interface QueueRequest {\r\n  /** Unique request ID */\r\n  id: string;\r\n  /** Search query */\r\n  query: string;\r\n  /** Search options */\r\n  options?: BoundaryOptions;\r\n  /** Request priority */\r\n  priority: 'low' | 'medium' | 'high';\r\n  /** Created timestamp */\r\n  createdAt: Date;\r\n  /** Scheduled processing time */\r\n  scheduledAt: Date;\r\n  /** Processing attempts */\r\n  attempts: number;\r\n  /** Request status */\r\n  status: 'pending' | 'processing' | 'completed' | 'failed';\r\n  /** Error message if failed */\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Queue processor interface\r\n */\r\nexport interface QueueProcessor {\r\n  /** Process pending requests */\r\n  process(): Promise<void>;\r\n  /** Add request to queue */\r\n  enqueue(request: Omit<QueueRequest, 'id' | 'createdAt' | 'attempts' | 'status'>): Promise<void>;\r\n  /** Get queue statistics */\r\n  getStats(): Promise<QueueStats>;\r\n}\r\n\r\n/**\r\n * Queue statistics\r\n */\r\nexport interface QueueStats {\r\n  /** Total requests in queue */\r\n  total: number;\r\n  /** Pending requests */\r\n  pending: number;\r\n  /** Processing requests */\r\n  processing: number;\r\n  /** Completed requests (last 24h) */\r\n  completed: number;\r\n  /** Failed requests (last 24h) */\r\n  failed: number;\r\n  /** Average processing time */\r\n  avgProcessingTime: number;\r\n}\r\n\r\n/**\r\n * Geocoding result Œ≥ŒπŒ± approximate boundaries\r\n */\r\nexport interface GeocodingResult {\r\n  /** Location name */\r\n  name: string;\r\n  /** Coordinates */\r\n  coordinates: {\r\n    latitude: number;\r\n    longitude: number;\r\n  };\r\n  /** Bounding box */\r\n  bbox?: BoundingBox;\r\n  /** Administrative info */\r\n  admin?: {\r\n    country?: string;\r\n    region?: string;\r\n    city?: string;\r\n  };\r\n  /** Confidence score */\r\n  confidence: number;\r\n}\r\n\r\n/**\r\n * Service health status\r\n */\r\nexport interface ServiceHealth {\r\n  /** Overall service status */\r\n  status: 'healthy' | 'degraded' | 'down';\r\n  /** Provider health status */\r\n  providers: ProviderHealth[];\r\n  /** Cache health */\r\n  cache: {\r\n    status: 'healthy' | 'degraded' | 'down';\r\n    hitRate: number;\r\n    size: number;\r\n  };\r\n  /** Queue health */\r\n  queue: {\r\n    status: 'healthy' | 'degraded' | 'down';\r\n    size: number;\r\n    processingRate: number;\r\n  };\r\n  /** Last health check */\r\n  lastCheck: Date;\r\n}\r\n\r\n/**\r\n * Event types Œ≥ŒπŒ± boundary service\r\n */\r\nexport type BoundaryEvent =\r\n  | { type: 'boundary.found'; data: { query: string; result: BoundaryResult } }\r\n  | { type: 'boundary.cached'; data: { query: string; ttl: number } }\r\n  | { type: 'boundary.queued'; data: { query: string; priority: string } }\r\n  | { type: 'provider.failed'; data: { provider: string; error: string } }\r\n  | { type: 'service.degraded'; data: { reason: string } };\r\n\r\n/**\r\n * Subscription callback Œ≥ŒπŒ± boundary updates\r\n */\r\nexport type BoundarySubscriptionCallback = (result: BoundaryResult) => void;\r\n\r\n/**\r\n * Error types\r\n */\r\nexport class BoundaryServiceError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly code: string,\r\n    public readonly provider?: string\r\n  ) {\r\n    super(message);\r\n    this.name = 'BoundaryServiceError';\r\n  }\r\n}\r\n\r\nexport class ProviderError extends BoundaryServiceError {\r\n  constructor(\r\n    message: string,\r\n    provider: string,\r\n    public readonly statusCode?: number\r\n  ) {\r\n    super(message, 'PROVIDER_ERROR', provider);\r\n    this.name = 'ProviderError';\r\n  }\r\n}\r\n\r\nexport class CacheError extends BoundaryServiceError {\r\n  constructor(message: string) {\r\n    super(message, 'CACHE_ERROR');\r\n    this.name = 'CacheError';\r\n  }\r\n}\r\n\r\nexport class QueueError extends BoundaryServiceError {\r\n  constructor(message: string) {\r\n    super(message, 'QUEUE_ERROR');\r\n    this.name = 'QueueError';\r\n  }\r\n}","/**\r\n * @layera/boundary-service - Factory\r\n *\r\n * Factory functions Œ≥ŒπŒ± ŒµœçŒ∫ŒøŒªŒ∑ Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ± boundary service\r\n */\r\n\r\nimport { createDatabaseNamespace } from '@layera/database-core';\r\nimport { BoundaryService } from './service';\r\nimport type { BoundaryServiceConfig } from './types';\r\n\r\n/**\r\n * Create boundary service ŒºŒµ default configuration\r\n */\r\nexport function createBoundaryService(\r\n  config?: Partial<BoundaryServiceConfig>\r\n): BoundaryService {\r\n  // Default configuration\r\n  const defaultConfig: BoundaryServiceConfig = {\r\n    providers: [\r\n      {\r\n        type: 'osm',\r\n        priority: 1,\r\n        config: {\r\n          endpoint: 'https://overpass-api.de/api/interpreter',\r\n          timeout: 5000\r\n        }\r\n      },\r\n      {\r\n        type: 'nominatim',\r\n        priority: 2,\r\n        config: {\r\n          endpoint: 'https://nominatim.openstreetmap.org',\r\n          timeout: 3000\r\n        }\r\n      }\r\n    ],\r\n    cache: {\r\n      ttl: 30 * 24 * 60 * 60 * 1000, // 30 days\r\n      cleanupInterval: 60 * 60 * 1000 // 1 hour\r\n    },\r\n    queue: {\r\n      maxSize: 1000,\r\n      processingInterval: 5 * 60 * 1000, // 5 minutes\r\n      retry: {\r\n        maxAttempts: 3,\r\n        baseDelay: 1000,\r\n        backoffMultiplier: 2,\r\n        maxDelay: 30000\r\n      }\r\n    },\r\n    defaults: {\r\n      adminLevels: [4, 6, 8],\r\n      timeout: 5000,\r\n      includeApproximate: true\r\n    }\r\n  };\r\n\r\n  // Merge configurations\r\n  const finalConfig = {\r\n    ...defaultConfig,\r\n    ...config,\r\n    providers: config?.providers || defaultConfig.providers,\r\n    cache: { ...defaultConfig.cache, ...config?.cache },\r\n    queue: { ...defaultConfig.queue, ...config?.queue },\r\n    defaults: { ...defaultConfig.defaults, ...config?.defaults }\r\n  };\r\n\r\n  // Create database namespace\r\n  const namespace = createDatabaseNamespace('boundary_service');\r\n\r\n  // Create service\r\n  return new BoundaryService(finalConfig, namespace);\r\n}\r\n\r\n/**\r\n * Create boundary service Œ≥ŒπŒ± testing\r\n */\r\nexport function createTestBoundaryService(): BoundaryService {\r\n  return createBoundaryService({\r\n    cache: {\r\n      ttl: 5 * 60 * 1000, // 5 minutes Œ≥ŒπŒ± testing\r\n      cleanupInterval: 60 * 1000 // 1 minute\r\n    },\r\n    defaults: {\r\n      timeout: 1000, // Short timeout Œ≥ŒπŒ± tests\r\n      includeApproximate: true\r\n    }\r\n  });\r\n}"],"mappings":"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","names":["import_database_core"]}