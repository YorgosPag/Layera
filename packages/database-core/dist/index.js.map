{"version":3,"sources":["../src/index.ts","../src/namespaces/namespace.ts","../src/cache/firestore-cache.ts","../src/utils/factory.ts"],"sourcesContent":["/**\r\n * @layera/database-core - Main Export\r\n *\r\n * Enterprise database core Œ≥ŒπŒ± LEGO systems\r\n * Œ†Œ±œÅŒ≠œáŒµŒπ isolated namespaces Œ∫Œ±Œπ caching Œ≥ŒπŒ± Œ∫Œ¨Œ∏Œµ LEGO\r\n */\r\n\r\n// Core classes\r\nexport { DatabaseNamespace } from './namespaces/namespace';\r\nexport { FirestoreCache } from './cache/firestore-cache';\r\n\r\n// Type exports\r\nexport type {\r\n  DatabaseConfig,\r\n  DatabaseNamespace as IDatabaseNamespace,\r\n  CollectionSchema,\r\n  DocumentSchema,\r\n  FieldDefinition,\r\n  ValidationRule,\r\n  IndexDefinition,\r\n  IndexField,\r\n  MigrationStrategy,\r\n  MigrationFunction,\r\n  TTLPolicy,\r\n  SecurityRule,\r\n  PerformanceHint,\r\n  NamespaceHealth,\r\n  HealthError,\r\n  CacheStrategy,\r\n  CacheStats,\r\n  EventBus,\r\n  LegoEvent,\r\n  EventHandler,\r\n  UnsubscribeFunction,\r\n  DatabaseRegistry,\r\n  LegoInfo,\r\n  QueryBuilder,\r\n  WhereOperator,\r\n  QueryResult,\r\n  QueryMetadata,\r\n  RealtimeSubscription,\r\n  SnapshotCallback,\r\n  ErrorCallback\r\n} from './types';\r\n\r\n// Utilities\r\nexport { createDatabaseNamespace, initializeFirestore } from './utils/factory';\r\n\r\n// Constants\r\nexport const DATABASE_CORE_VERSION = '1.0.0';","/**\r\n * @layera/database-core - Database Namespace\r\n *\r\n * Isolated database namespace Œ≥ŒπŒ± Œ∫Œ¨Œ∏Œµ LEGO system\r\n * ŒïŒæŒ±œÉœÜŒ±ŒªŒØŒ∂ŒµŒπ Œ∫Œ±ŒºŒØŒ± cross-LEGO ŒµŒæŒ¨œÅœÑŒ∑œÉŒ∑ œÉœÑŒ∑ Œ≤Œ¨œÉŒ∑ Œ¥ŒµŒ¥ŒøŒºŒ≠ŒΩœâŒΩ\r\n */\r\n\r\nimport {\r\n  Firestore,\r\n  collection,\r\n  doc,\r\n  runTransaction,\r\n  Transaction,\r\n  CollectionReference,\r\n  DocumentReference,\r\n  getDocs,\r\n  query,\r\n  limit,\r\n  Timestamp,\r\n  serverTimestamp\r\n} from 'firebase/firestore';\r\n\r\nimport type {\r\n  DatabaseNamespace as IDataBaseNamespace,\r\n  NamespaceHealth,\r\n  HealthError\r\n} from '../types';\r\n\r\n/**\r\n * Isolated database namespace implementation\r\n */\r\nexport class DatabaseNamespace implements IDataBaseNamespace {\r\n  public readonly namespace: string;\r\n  public readonly firestore: Firestore;\r\n\r\n  constructor(legoName: string, firestore: Firestore) {\r\n    // Validate LEGO name\r\n    if (!legoName || typeof legoName !== 'string') {\r\n      throw new Error('Invalid LEGO name: must be non-empty string');\r\n    }\r\n\r\n    // Sanitize namespace\r\n    this.namespace = `lego_${legoName.toLowerCase().replace(/[^a-z0-9_]/g, '_')}`;\r\n    this.firestore = firestore;\r\n\r\n    console.log(`üì¶ Created database namespace: ${this.namespace}`);\r\n  }\r\n\r\n  /**\r\n   * Get scoped collection reference\r\n   */\r\n  collection(name: string): CollectionReference {\r\n    if (!name || typeof name !== 'string') {\r\n      throw new Error('Collection name must be non-empty string');\r\n    }\r\n\r\n    const collectionPath = `${this.namespace}/${name}`;\r\n    return collection(this.firestore, collectionPath);\r\n  }\r\n\r\n  /**\r\n   * Get scoped document reference\r\n   */\r\n  doc(collectionName: string, docId?: string): DocumentReference {\r\n    const coll = this.collection(collectionName);\r\n    return docId ? doc(coll, docId) : doc(coll);\r\n  }\r\n\r\n  /**\r\n   * Run transaction within namespace\r\n   */\r\n  async transaction<T>(fn: (tx: Transaction) => Promise<T>): Promise<T> {\r\n    try {\r\n      return await runTransaction(this.firestore, fn);\r\n    } catch (error) {\r\n      console.error(`üö´ Transaction failed in ${this.namespace}:`, error);\r\n      throw new Error(`Transaction failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if namespace has any data\r\n   */\r\n  async exists(): Promise<boolean> {\r\n    try {\r\n      // Check if any collection exists ŒºŒµ at least one document\r\n      const collections = await this.listCollections();\r\n\r\n      for (const collectionName of collections) {\r\n        const coll = this.collection(collectionName);\r\n        const snapshot = await getDocs(query(coll, limit(1)));\r\n\r\n        if (!snapshot.empty) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    } catch (error) {\r\n      console.error(`üö´ Failed to check namespace existence: ${this.namespace}`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all data in namespace (DANGER!)\r\n   */\r\n  async clear(): Promise<void> {\r\n    console.warn(`‚ö†Ô∏è Clearing all data in namespace: ${this.namespace}`);\r\n\r\n    try {\r\n      await this.transaction(async (tx) => {\r\n        const collections = await this.listCollections();\r\n\r\n        for (const collectionName of collections) {\r\n          await this.clearCollection(tx, collectionName);\r\n        }\r\n      });\r\n\r\n      console.log(`‚úÖ Cleared namespace: ${this.namespace}`);\r\n    } catch (error) {\r\n      console.error(`üö´ Failed to clear namespace: ${this.namespace}`, error);\r\n      throw new Error(`Clear failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get namespace health information\r\n   */\r\n  async health(): Promise<NamespaceHealth> {\r\n    const startTime = Date.now();\r\n    const errors: HealthError[] = [];\r\n    let collections = 0;\r\n    let documents = 0;\r\n    let storageSize = 0;\r\n\r\n    try {\r\n      // Count collections and documents\r\n      const collectionNames = await this.listCollections();\r\n      collections = collectionNames.length;\r\n\r\n      for (const collectionName of collectionNames) {\r\n        try {\r\n          const coll = this.collection(collectionName);\r\n          const snapshot = await getDocs(coll);\r\n          documents += snapshot.size;\r\n\r\n          // Estimate storage size (rough calculation)\r\n          snapshot.docs.forEach(doc => {\r\n            const data = doc.data();\r\n            storageSize += JSON.stringify(data).length;\r\n          });\r\n        } catch (collectionError) {\r\n          errors.push({\r\n            code: 'COLLECTION_ERROR',\r\n            message: `Failed to read collection ${collectionName}: ${collectionError instanceof Error ? collectionError.message : 'Unknown error'}`,\r\n            timestamp: serverTimestamp() as Timestamp\r\n          });\r\n        }\r\n      }\r\n\r\n      const responseTime = Date.now() - startTime;\r\n      const status = errors.length === 0 ?\r\n        (responseTime < 1000 ? 'healthy' : 'degraded') :\r\n        'down';\r\n\r\n      return {\r\n        namespace: this.namespace,\r\n        status,\r\n        collections,\r\n        documents,\r\n        storageSize,\r\n        lastUpdate: serverTimestamp() as Timestamp,\r\n        ...(errors.length > 0 && { errors })\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        namespace: this.namespace,\r\n        status: 'down',\r\n        collections: 0,\r\n        documents: 0,\r\n        storageSize: 0,\r\n        lastUpdate: serverTimestamp() as Timestamp,\r\n        errors: [{\r\n          code: 'HEALTH_CHECK_ERROR',\r\n          message: error instanceof Error ? error.message : 'Unknown error',\r\n          timestamp: serverTimestamp() as Timestamp\r\n        }]\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * List all collections in namespace (helper method)\r\n   */\r\n  private async listCollections(): Promise<string[]> {\r\n    // Note: Firestore client SDK doesn't have listCollections\r\n    // This is a simplified implementation\r\n    // In production, you'd use Admin SDK ŒÆ keep a registry\r\n\r\n    const knownCollections = [\r\n      'cache',\r\n      'queue',\r\n      'analytics',\r\n      'preferences',\r\n      'history',\r\n      'metadata'\r\n    ];\r\n\r\n    const existingCollections: string[] = [];\r\n\r\n    for (const collectionName of knownCollections) {\r\n      try {\r\n        const coll = this.collection(collectionName);\r\n        const snapshot = await getDocs(query(coll, limit(1)));\r\n\r\n        if (!snapshot.empty) {\r\n          existingCollections.push(collectionName);\r\n        }\r\n      } catch {\r\n        // Collection doesn't exist or access denied\r\n        continue;\r\n      }\r\n    }\r\n\r\n    return existingCollections;\r\n  }\r\n\r\n  /**\r\n   * Clear collection within transaction\r\n   */\r\n  private async clearCollection(tx: Transaction, collectionName: string): Promise<void> {\r\n    const coll = this.collection(collectionName);\r\n    const snapshot = await getDocs(coll);\r\n\r\n    // Delete in batches to avoid transaction limits\r\n    const batch = snapshot.docs.slice(0, 500); // Firestore limit\r\n\r\n    for (const documentSnapshot of batch) {\r\n      tx.delete(documentSnapshot.ref);\r\n    }\r\n\r\n    // If more documents exist, they'll be handled in subsequent transactions\r\n    if (snapshot.docs.length > 500) {\r\n      console.warn(`‚ö†Ô∏è Collection ${collectionName} has >500 docs, will require multiple transactions`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create collection ŒºŒµ validation\r\n   */\r\n  createCollection(name: string): CollectionReference {\r\n    if (!name.match(/^[a-z0-9_]+$/)) {\r\n      throw new Error(`Invalid collection name: ${name}. Use only lowercase letters, numbers, and underscores.`);\r\n    }\r\n\r\n    return this.collection(name);\r\n  }\r\n\r\n  /**\r\n   * Batch write operations\r\n   */\r\n  async batchWrite(operations: BatchOperation[]): Promise<void> {\r\n    if (operations.length === 0) {\r\n      return;\r\n    }\r\n\r\n    if (operations.length > 500) {\r\n      throw new Error('Batch operations limited to 500 items');\r\n    }\r\n\r\n    await this.transaction(async (tx) => {\r\n      for (const operation of operations) {\r\n        switch (operation.type) {\r\n          case 'set':\r\n            tx.set(operation.ref, operation.data);\r\n            break;\r\n          case 'update':\r\n            if (operation.data) {\r\n              tx.update(operation.ref, operation.data);\r\n            }\r\n            break;\r\n          case 'delete':\r\n            tx.delete(operation.ref);\r\n            break;\r\n          default:\r\n            throw new Error(`Unknown operation type: ${(operation as unknown as { type: string }).type}`);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get namespace statistics\r\n   */\r\n  async getStats(): Promise<NamespaceStats> {\r\n    const health = await this.health();\r\n\r\n    return {\r\n      namespace: this.namespace,\r\n      collections: health.collections,\r\n      documents: health.documents,\r\n      storageSize: health.storageSize,\r\n      healthy: health.status === 'healthy',\r\n      lastCheck: health.lastUpdate\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Batch operation type\r\n */\r\ninterface BatchOperation {\r\n  type: 'set' | 'update' | 'delete';\r\n  ref: DocumentReference;\r\n  data?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Namespace statistics\r\n */\r\ninterface NamespaceStats {\r\n  namespace: string;\r\n  collections: number;\r\n  documents: number;\r\n  storageSize: number;\r\n  healthy: boolean;\r\n  lastCheck: Timestamp;\r\n}","/**\r\n * @layera/database-core - Firestore Cache Strategy\r\n *\r\n * Enterprise caching layer ŒºŒµ TTL support Œ∫Œ±Œπ automatic cleanup\r\n * ŒßœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒµŒØ Firestore œâœÇ persistent cache store\r\n */\r\n\r\nimport {\r\n  getDoc,\r\n  setDoc,\r\n  deleteDoc,\r\n  query,\r\n  where,\r\n  getDocs,\r\n  Timestamp,\r\n  serverTimestamp\r\n} from 'firebase/firestore';\r\n\r\nimport type { CacheStrategy, CacheStats } from '../types';\r\nimport type { DatabaseNamespace } from '../namespaces/namespace';\r\n\r\n/**\r\n * Firestore-based cache implementation\r\n */\r\nexport class FirestoreCache implements CacheStrategy {\r\n  private namespace: DatabaseNamespace;\r\n  private collectionName: string;\r\n  private defaultTTL: number;\r\n\r\n  constructor(\r\n    namespace: DatabaseNamespace,\r\n    collectionName = 'cache',\r\n    defaultTTL = 24 * 60 * 60 * 1000 // 24 hours\r\n  ) {\r\n    this.namespace = namespace;\r\n    this.collectionName = collectionName;\r\n    this.defaultTTL = defaultTTL;\r\n\r\n    console.log(`üíæ Created Firestore cache: ${namespace.namespace}/${collectionName}`);\r\n  }\r\n\r\n  /**\r\n   * Get cached value\r\n   */\r\n  async get<T>(key: string): Promise<T | null> {\r\n    try {\r\n      const cacheDoc = await this.getCacheDocument(key);\r\n\r\n      if (!cacheDoc.exists()) {\r\n        return null;\r\n      }\r\n\r\n      const data = cacheDoc.data();\r\n      if (!data) {\r\n        return null;\r\n      }\r\n\r\n      // Check TTL\r\n      const now = Date.now();\r\n      const expiresAt = data.expiresAt?.toMillis() || 0;\r\n\r\n      if (expiresAt > 0 && now > expiresAt) {\r\n        // Expired - delete silently\r\n        await this.delete(key);\r\n        return null;\r\n      }\r\n\r\n      // Update access statistics\r\n      await this.updateAccessStats(key);\r\n\r\n      return data.value as T;\r\n\r\n    } catch (error) {\r\n      console.error(`üö´ Cache get failed for key: ${key}`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set cached value ŒºŒµ TTL\r\n   */\r\n  async set<T>(key: string, value: T, ttl?: number): Promise<void> {\r\n    try {\r\n      const actualTTL = ttl || this.defaultTTL;\r\n      const expiresAt = actualTTL > 0 ?\r\n        new Date(Date.now() + actualTTL) :\r\n        null;\r\n\r\n      const cacheData: CacheDocument<T> = {\r\n        key,\r\n        value,\r\n        createdAt: serverTimestamp() as Timestamp,\r\n        updatedAt: serverTimestamp() as Timestamp,\r\n        expiresAt: expiresAt ? Timestamp.fromDate(expiresAt) : null,\r\n        hits: 0,\r\n        lastAccess: serverTimestamp() as Timestamp\r\n      };\r\n\r\n      const docRef = this.getCacheDocumentRef(key);\r\n      await setDoc(docRef, cacheData);\r\n\r\n    } catch (error) {\r\n      console.error(`üö´ Cache set failed for key: ${key}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete cached value\r\n   */\r\n  async delete(key: string): Promise<void> {\r\n    try {\r\n      const docRef = this.getCacheDocumentRef(key);\r\n      await deleteDoc(docRef);\r\n    } catch (error) {\r\n      console.error(`üö´ Cache delete failed for key: ${key}`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all cache\r\n   */\r\n  async clear(): Promise<void> {\r\n    try {\r\n      const coll = this.namespace.collection(this.collectionName);\r\n      const snapshot = await getDocs(coll);\r\n\r\n      // Delete in batches\r\n      const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));\r\n      await Promise.all(deletePromises);\r\n\r\n      console.log(`‚úÖ Cleared cache: ${this.namespace.namespace}/${this.collectionName}`);\r\n    } catch (error) {\r\n      console.error(`üö´ Cache clear failed`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  async stats(): Promise<CacheStats> {\r\n    try {\r\n      const coll = this.namespace.collection(this.collectionName);\r\n      const snapshot = await getDocs(coll);\r\n\r\n      let totalHits = 0;\r\n      let totalKeys = snapshot.size;\r\n      let memoryUsage = 0;\r\n      let expiredKeys = 0;\r\n\r\n      const now = Date.now();\r\n\r\n      snapshot.docs.forEach(doc => {\r\n        const data = doc.data() as CacheDocument<unknown>;\r\n\r\n        totalHits += data.hits || 0;\r\n\r\n        // Estimate memory usage\r\n        memoryUsage += JSON.stringify(data).length;\r\n\r\n        // Count expired\r\n        if (data.expiresAt && now > data.expiresAt.toMillis()) {\r\n          expiredKeys++;\r\n        }\r\n      });\r\n\r\n      const hitRate = totalKeys > 0 ? (totalHits / totalKeys) * 100 : 0;\r\n\r\n      return {\r\n        keys: totalKeys,\r\n        hitRate,\r\n        memoryUsage,\r\n        evictions: expiredKeys\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('üö´ Cache stats failed', error);\r\n      return {\r\n        keys: 0,\r\n        hitRate: 0,\r\n        memoryUsage: 0,\r\n        evictions: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired entries\r\n   */\r\n  async cleanup(): Promise<number> {\r\n    try {\r\n      const coll = this.namespace.collection(this.collectionName);\r\n      const now = Timestamp.now();\r\n\r\n      // Query for expired documents\r\n      const expiredQuery = query(\r\n        coll,\r\n        where('expiresAt', '<=', now)\r\n      );\r\n\r\n      const snapshot = await getDocs(expiredQuery);\r\n      const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));\r\n\r\n      await Promise.all(deletePromises);\r\n\r\n      const cleanedCount = snapshot.size;\r\n      if (cleanedCount > 0) {\r\n        console.log(`üßπ Cleaned ${cleanedCount} expired cache entries`);\r\n      }\r\n\r\n      return cleanedCount;\r\n\r\n    } catch (error) {\r\n      console.error('üö´ Cache cleanup failed', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preload popular keys\r\n   */\r\n  async preload(keys: string[]): Promise<void> {\r\n    try {\r\n      const loadPromises = keys.map(key => this.get(key));\r\n      await Promise.all(loadPromises);\r\n\r\n      console.log(`üì¶ Preloaded ${keys.length} cache keys`);\r\n    } catch (error) {\r\n      console.error('üö´ Cache preload failed', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache document reference\r\n   */\r\n  private getCacheDocumentRef(key: string) {\r\n    // Sanitize key Œ≥ŒπŒ± Firestore\r\n    const sanitizedKey = key.replace(/[/\\\\#\\$\\[\\]]/g, '_');\r\n    return this.namespace.doc(this.collectionName, sanitizedKey);\r\n  }\r\n\r\n  /**\r\n   * Get cache document\r\n   */\r\n  private async getCacheDocument(key: string) {\r\n    const docRef = this.getCacheDocumentRef(key);\r\n    return await getDoc(docRef);\r\n  }\r\n\r\n  /**\r\n   * Update access statistics\r\n   */\r\n  private async updateAccessStats(key: string): Promise<void> {\r\n    try {\r\n      const docRef = this.getCacheDocumentRef(key);\r\n\r\n      await this.namespace.transaction(async (tx) => {\r\n        const doc = await tx.get(docRef);\r\n        if (doc.exists()) {\r\n          const data = doc.data() as CacheDocument<unknown>;\r\n          tx.update(docRef, {\r\n            hits: (data.hits || 0) + 1,\r\n            lastAccess: serverTimestamp()\r\n          });\r\n        }\r\n      });\r\n    } catch (error) {\r\n      // Non-critical error - don't fail the get operation\r\n      console.warn(`‚ö†Ô∏è Failed to update access stats for key: ${key}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get key info for debugging\r\n   */\r\n  async getKeyInfo(key: string): Promise<CacheKeyInfo | null> {\r\n    try {\r\n      const doc = await this.getCacheDocument(key);\r\n      if (!doc.exists()) {\r\n        return null;\r\n      }\r\n\r\n      const data = doc.data() as CacheDocument<unknown>;\r\n      const now = Date.now();\r\n      const isExpired = data.expiresAt ? now > data.expiresAt.toMillis() : false;\r\n\r\n      return {\r\n        key,\r\n        exists: true,\r\n        createdAt: data.createdAt,\r\n        updatedAt: data.updatedAt,\r\n        expiresAt: data.expiresAt,\r\n        hits: data.hits || 0,\r\n        lastAccess: data.lastAccess,\r\n        isExpired,\r\n        size: JSON.stringify(data.value).length\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error(`üö´ Get key info failed: ${key}`, error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Cache document structure\r\n */\r\ninterface CacheDocument<T> {\r\n  key: string;\r\n  value: T;\r\n  createdAt: Timestamp;\r\n  updatedAt: Timestamp;\r\n  expiresAt: Timestamp | null;\r\n  hits: number;\r\n  lastAccess: Timestamp;\r\n}\r\n\r\n/**\r\n * Cache key information\r\n */\r\ninterface CacheKeyInfo {\r\n  key: string;\r\n  exists: boolean;\r\n  createdAt: Timestamp;\r\n  updatedAt: Timestamp;\r\n  expiresAt: Timestamp | null;\r\n  hits: number;\r\n  lastAccess: Timestamp;\r\n  isExpired: boolean;\r\n  size: number;\r\n}","/**\r\n * @layera/database-core - Factory Utilities\r\n *\r\n * Factory functions Œ≥ŒπŒ± ŒµœçŒ∫ŒøŒªŒ∑ Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ± database instances\r\n */\r\n\r\nimport { initializeApp, getApps, FirebaseApp } from 'firebase/app';\r\nimport { getFirestore, Firestore, connectFirestoreEmulator } from 'firebase/firestore';\r\nimport { DatabaseNamespace } from '../namespaces/namespace';\r\n\r\n/**\r\n * Firebase configuration interface\r\n */\r\ninterface FirebaseConfig {\r\n  apiKey: string;\r\n  authDomain: string;\r\n  projectId: string;\r\n  storageBucket: string;\r\n  messagingSenderId: string;\r\n  appId: string;\r\n}\r\n\r\n/**\r\n * Initialize Firestore ŒºŒµ proper configuration\r\n */\r\nexport function initializeFirestore(config?: FirebaseConfig): Firestore {\r\n  let app: FirebaseApp;\r\n\r\n  // Use existing app if available\r\n  const existingApps = getApps();\r\n  if (existingApps.length > 0) {\r\n    app = existingApps[0]!;\r\n  } else {\r\n    // Create new app\r\n    const firebaseConfig = config || getDefaultConfig();\r\n    app = initializeApp(firebaseConfig);\r\n  }\r\n\r\n  const firestore = getFirestore(app);\r\n\r\n  // Connect to emulator in development\r\n  if (process.env.NODE_ENV === 'development' && !isEmulatorConnected(firestore)) {\r\n    try {\r\n      connectFirestoreEmulator(firestore, 'localhost', 8080);\r\n      console.log('üîß Connected to Firestore emulator');\r\n    } catch (error) {\r\n      // Emulator might not be running - that's ok\r\n      console.log('üì° Using production Firestore');\r\n    }\r\n  }\r\n\r\n  return firestore;\r\n}\r\n\r\n/**\r\n * Create database namespace Œ≥ŒπŒ± LEGO\r\n */\r\nexport function createDatabaseNamespace(\r\n  legoName: string,\r\n  firestore?: Firestore\r\n): DatabaseNamespace {\r\n  const db = firestore || initializeFirestore();\r\n  return new DatabaseNamespace(legoName, db);\r\n}\r\n\r\n/**\r\n * Get default Firebase configuration Œ±œÄœå environment\r\n */\r\nfunction getDefaultConfig(): FirebaseConfig {\r\n  const config = {\r\n    apiKey: process.env.FIREBASE_API_KEY || process.env.REACT_APP_FIREBASE_API_KEY,\r\n    authDomain: process.env.FIREBASE_AUTH_DOMAIN || process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,\r\n    projectId: process.env.FIREBASE_PROJECT_ID || process.env.REACT_APP_FIREBASE_PROJECT_ID,\r\n    storageBucket: process.env.FIREBASE_STORAGE_BUCKET || process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,\r\n    messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID || process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,\r\n    appId: process.env.FIREBASE_APP_ID || process.env.REACT_APP_FIREBASE_APP_ID\r\n  };\r\n\r\n  // Validate required fields\r\n  const requiredFields = ['projectId', 'apiKey', 'authDomain'] as const;\r\n  const missingFields = requiredFields.filter(field => !config[field]);\r\n\r\n  if (missingFields.length > 0) {\r\n    throw new Error(`Missing Firebase configuration: ${missingFields.join(', ')}`);\r\n  }\r\n\r\n  return config as FirebaseConfig;\r\n}\r\n\r\n/**\r\n * Check if Firestore emulator is already connected\r\n */\r\nfunction isEmulatorConnected(firestore: Firestore): boolean {\r\n  // This is a workaround - Firestore doesn't expose emulator connection status\r\n  // We check if _delegate._settings contains emulator config\r\n  try {\r\n    const settings = (firestore as unknown as { _delegate?: { _settings?: { host?: string } } })._delegate?._settings;\r\n    return settings?.host?.includes('localhost') || false;\r\n  } catch {\r\n    return false;\r\n  }\r\n}"],"mappings":"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","names":["doc","import_firestore","doc","import_firestore"]}