{"version":3,"sources":["../src/hooks/useFileCompression.ts","../src/types/index.ts","../src/utils/compressionEngine.ts","../src/utils/compressionValidator.ts"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\r\nimport { useNotifications } from '@layera/notifications';\r\nimport { useLayeraTranslation } from '@layera/i18n';\r\nimport {\r\n  CompressionOptions,\r\n  CompressionResult,\r\n  CompressionProgress,\r\n  CompressionError,\r\n  BatchCompressionOptions,\r\n  BatchCompressionResult,\r\n  CompressionValidationResult\r\n} from '../types';\r\nimport { CompressionEngine } from '../utils/compressionEngine';\r\nimport { validateCompressionOptions, recommendOptimizations } from '../utils/compressionValidator';\r\n\r\nexport interface UseFileCompressionOptions {\r\n  defaultOptions?: CompressionOptions;\r\n  maxConcurrentFiles?: number;\r\n  showNotifications?: boolean;\r\n  onProgress?: (progress: CompressionProgress) => void;\r\n  onComplete?: (results: CompressionResult[]) => void;\r\n  onError?: (error: CompressionError) => void;\r\n}\r\n\r\nexport interface UseFileCompressionReturn {\r\n  // State\r\n  isCompressing: boolean;\r\n  progress: number;\r\n  results: CompressionResult[];\r\n  errors: CompressionError[];\r\n\r\n  // Actions\r\n  compressFile: (file: File, options?: CompressionOptions) => Promise<CompressionResult>;\r\n  compressFiles: (files: File[], options?: BatchCompressionOptions) => Promise<BatchCompressionResult>;\r\n  cancelCompression: () => void;\r\n  clearResults: () => void;\r\n\r\n  // Validation & optimization\r\n  validateOptions: (options: CompressionOptions) => CompressionValidationResult;\r\n  getRecommendations: (file: File) => Promise<CompressionOptions>;\r\n  estimateCompression: (file: File, options: CompressionOptions) => Promise<{\r\n    estimatedSize: number;\r\n    estimatedRatio: number;\r\n  }>;\r\n}\r\n\r\nexport function useFileCompression(\r\n  options: UseFileCompressionOptions = {}\r\n): UseFileCompressionReturn {\r\n  const { t } = useLayeraTranslation();\r\n  const { addNotification } = useNotifications();\r\n  const [isCompressing, setIsCompressing] = useState(false);\r\n  const [progress, setProgress] = useState(0);\r\n  const [results, setResults] = useState<CompressionResult[]>([]);\r\n  const [errors, setErrors] = useState<CompressionError[]>([]);\r\n\r\n  const engineRef = useRef<CompressionEngine | null>(null);\r\n  const abortControllerRef = useRef<AbortController | null>(null);\r\n\r\n  const {\r\n    defaultOptions = {},\r\n    maxConcurrentFiles = 3,\r\n    showNotifications = true,\r\n    onProgress,\r\n    onComplete,\r\n    onError\r\n  } = options;\r\n\r\n  // Initialize compression engine\r\n  useEffect(() => {\r\n    try {\r\n      engineRef.current = new CompressionEngine();\r\n    } catch (error) {\r\n      console.error('Failed to initialize compression engine:', error);\r\n      if (showNotifications) {\r\n        addNotification({\r\n          type: 'error',\r\n          message: t('compression.engine.init.error')\r\n        });\r\n      }\r\n    }\r\n\r\n    return () => {\r\n      if (engineRef.current) {\r\n        engineRef.current.destroy();\r\n      }\r\n    };\r\n  }, [showNotifications, t]);\r\n\r\n  const reportProgress = useCallback((\r\n    fileId: string,\r\n    stage: CompressionProgress['stage'],\r\n    progress: number,\r\n    message: string\r\n  ) => {\r\n    const progressData: CompressionProgress = {\r\n      fileId,\r\n      stage,\r\n      progress,\r\n      message\r\n    };\r\n\r\n    setProgress(progress);\r\n    onProgress?.(progressData);\r\n\r\n    if (showNotifications && stage === 'complete') {\r\n      addNotification({\r\n        type: 'success',\r\n        message: t('compression.file.success', { progress: Math.round(progress) }),\r\n        duration: 3000\r\n      });\r\n    }\r\n  }, [onProgress, showNotifications, t]);\r\n\r\n  const handleError = useCallback((error: CompressionError) => {\r\n    setErrors(prev => [...prev, error]);\r\n    onError?.(error);\r\n\r\n    if (showNotifications) {\r\n      addNotification({\r\n        type: 'error',\r\n        message: t('compression.file.error', {\r\n          error: error.message\r\n        }),\r\n        duration: 5000\r\n      });\r\n    }\r\n  }, [onError, showNotifications, t]);\r\n\r\n  const compressFile = useCallback(async (\r\n    file: File,\r\n    compressionOptions?: CompressionOptions\r\n  ): Promise<CompressionResult> => {\r\n    if (!engineRef.current) {\r\n      throw new CompressionError(\r\n        'Compression engine not initialized',\r\n        'ENGINE_NOT_INITIALIZED'\r\n      );\r\n    }\r\n\r\n    const fileId = `compress-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    const finalOptions = { ...defaultOptions, ...compressionOptions };\r\n\r\n    try {\r\n      setIsCompressing(true);\r\n      reportProgress(fileId, 'analyzing', 10, t('compression.analyzing.file'));\r\n\r\n      // Validate options\r\n      const validation = validateCompressionOptions(finalOptions);\r\n      if (!validation.isValid) {\r\n        throw new CompressionError(\r\n          validation.errors.map(e => e.message).join(', '),\r\n          'VALIDATION_FAILED'\r\n        );\r\n      }\r\n\r\n      // Show warnings\r\n      if (validation.warnings.length > 0 && showNotifications) {\r\n        validation.warnings.forEach(warning => {\r\n          addNotification({\r\n            type: 'warning',\r\n            message: warning.message,\r\n            duration: 4000,\r\n            ...(warning.suggestion && {\r\n              action: { label: t('compression.suggestion'), onClick: () => {} }\r\n            })\r\n          });\r\n        });\r\n      }\r\n\r\n      reportProgress(fileId, 'compressing', 50, t('compression.compressing.file'));\r\n\r\n      // Perform compression\r\n      const result = await engineRef.current.compressFile(file, finalOptions);\r\n\r\n      reportProgress(fileId, 'complete', 100, t('compression.completed'));\r\n\r\n      setResults(prev => [...prev, result]);\r\n      return result;\r\n\r\n    } catch (error) {\r\n      const compressionError = error instanceof CompressionError\r\n        ? error\r\n        : new CompressionError(\r\n            error instanceof Error ? error.message : 'Unknown compression error',\r\n            'COMPRESSION_FAILED',\r\n            fileId\r\n          );\r\n\r\n      handleError(compressionError);\r\n      throw compressionError;\r\n\r\n    } finally {\r\n      setIsCompressing(false);\r\n      setProgress(0);\r\n    }\r\n  }, [defaultOptions, reportProgress, handleError, showNotifications, t]);\r\n\r\n  const compressFiles = useCallback(async (\r\n    files: File[],\r\n    batchOptions?: BatchCompressionOptions\r\n  ): Promise<BatchCompressionResult> => {\r\n    if (!engineRef.current) {\r\n      throw new CompressionError(\r\n        'Compression engine not initialized',\r\n        'ENGINE_NOT_INITIALIZED'\r\n      );\r\n    }\r\n\r\n    const startTime = performance.now();\r\n    const batchResults: CompressionResult[] = [];\r\n    const batchErrors: CompressionError[] = [];\r\n\r\n    const {\r\n      maxConcurrentFiles: batchMaxConcurrent = maxConcurrentFiles,\r\n      stopOnError = false,\r\n      onFileComplete,\r\n      onFileError,\r\n      ...compressionOptions\r\n    } = batchOptions || {};\r\n\r\n    try {\r\n      setIsCompressing(true);\r\n      abortControllerRef.current = new AbortController();\r\n\r\n      // Process files in chunks\r\n      for (let i = 0; i < files.length; i += batchMaxConcurrent) {\r\n        if (abortControllerRef.current.signal.aborted) {\r\n          break;\r\n        }\r\n\r\n        const chunk = files.slice(i, i + batchMaxConcurrent);\r\n        const overallProgress = ((i + chunk.length) / files.length) * 100;\r\n        setProgress(overallProgress);\r\n\r\n        const chunkPromises = chunk.map(async (file) => {\r\n          try {\r\n            const result = await compressFile(file, compressionOptions);\r\n            batchResults.push(result);\r\n            onFileComplete?.(result);\r\n            return result;\r\n          } catch (error) {\r\n            const compressionError = error instanceof CompressionError ? error :\r\n              new CompressionError(\r\n                error instanceof Error ? error.message : 'Unknown error',\r\n                'FILE_COMPRESSION_FAILED'\r\n              );\r\n\r\n            batchErrors.push(compressionError);\r\n            onFileError?.(compressionError);\r\n\r\n            if (stopOnError) {\r\n              throw compressionError;\r\n            }\r\n            return null;\r\n          }\r\n        });\r\n\r\n        await Promise.all(chunkPromises);\r\n      }\r\n\r\n      const processingTime = performance.now() - startTime;\r\n      const totalOriginalSize = batchResults.reduce((sum, r) => sum + r.originalSize, 0);\r\n      const totalCompressedSize = batchResults.reduce((sum, r) => sum + r.compressedSize, 0);\r\n\r\n      const batchResult: BatchCompressionResult = {\r\n        results: batchResults,\r\n        errors: batchErrors,\r\n        totalOriginalSize,\r\n        totalCompressedSize,\r\n        overallCompressionRatio: totalOriginalSize > 0\r\n          ? Math.round(((totalOriginalSize - totalCompressedSize) / totalOriginalSize) * 100 * 100) / 100\r\n          : 0,\r\n        processingTime\r\n      };\r\n\r\n      onComplete?.(batchResults);\r\n\r\n      if (showNotifications) {\r\n        addNotification({\r\n          type: 'success',\r\n          message: t('compression.batch.complete', {\r\n            successful: batchResults.length,\r\n            total: files.length,\r\n            savings: batchResult.overallCompressionRatio\r\n          }),\r\n          duration: 5000\r\n        });\r\n      }\r\n\r\n      return batchResult;\r\n\r\n    } finally {\r\n      setIsCompressing(false);\r\n      setProgress(0);\r\n      abortControllerRef.current = null;\r\n    }\r\n  }, [compressFile, maxConcurrentFiles, onComplete, showNotifications, t]);\r\n\r\n  const cancelCompression = useCallback(() => {\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n      setIsCompressing(false);\r\n      setProgress(0);\r\n\r\n      if (showNotifications) {\r\n        addNotification({\r\n          type: 'info',\r\n          message: t('compression.cancelled')\r\n        });\r\n      }\r\n    }\r\n  }, [showNotifications, t]);\r\n\r\n  const clearResults = useCallback(() => {\r\n    setResults([]);\r\n    setErrors([]);\r\n    setProgress(0);\r\n  }, []);\r\n\r\n  const validateOptions = useCallback((options: CompressionOptions): CompressionValidationResult => {\r\n    return validateCompressionOptions(options);\r\n  }, []);\r\n\r\n  const getRecommendations = useCallback(async (file: File): Promise<CompressionOptions> => {\r\n    return recommendOptimizations(file);\r\n  }, []);\r\n\r\n  const estimateCompression = useCallback(async (\r\n    file: File,\r\n    options: CompressionOptions\r\n  ): Promise<{ estimatedSize: number; estimatedRatio: number }> => {\r\n    // Simple estimation βασισμένο σε file type και quality\r\n    const baseRatio = options.quality ? (100 - options.quality) / 100 : 0.3;\r\n    const formatMultiplier = options.format === 'webp' ? 0.8 :\r\n                           options.format === 'avif' ? 0.7 : 1.0;\r\n\r\n    const estimatedRatio = baseRatio * formatMultiplier;\r\n    const estimatedSize = Math.round(file.size * (1 - estimatedRatio));\r\n\r\n    return {\r\n      estimatedSize,\r\n      estimatedRatio: Math.round(estimatedRatio * 100 * 100) / 100\r\n    };\r\n  }, []);\r\n\r\n  return {\r\n    // State\r\n    isCompressing,\r\n    progress,\r\n    results,\r\n    errors,\r\n\r\n    // Actions\r\n    compressFile,\r\n    compressFiles,\r\n    cancelCompression,\r\n    clearResults,\r\n\r\n    // Validation & optimization\r\n    validateOptions,\r\n    getRecommendations,\r\n    estimateCompression\r\n  };\r\n}","// Core compression types\r\nexport interface CompressionOptions {\r\n  quality?: number; // 0-100 for lossy formats\r\n  format?: CompressionFormat;\r\n  maxWidth?: number;\r\n  maxHeight?: number;\r\n  maintainAspectRatio?: boolean;\r\n  enableProgressive?: boolean;\r\n  stripMetadata?: boolean;\r\n  customSettings?: Record<string, unknown>;\r\n}\r\n\r\nexport type CompressionFormat = 'jpeg' | 'webp' | 'avif' | 'png' | 'original';\r\n\r\nexport interface CompressionResult {\r\n  originalFile: File;\r\n  compressedBlob: Blob;\r\n  originalSize: number;\r\n  compressedSize: number;\r\n  compressionRatio: number;\r\n  format: CompressionFormat;\r\n  quality: number;\r\n  metadata: CompressionMetadata;\r\n}\r\n\r\nexport interface CompressionMetadata {\r\n  width?: number;\r\n  height?: number;\r\n  originalFormat: string;\r\n  targetFormat: string;\r\n  processingTime: number;\r\n  algorithm: string;\r\n}\r\n\r\nexport interface CompressionProgress {\r\n  fileId: string;\r\n  stage: 'analyzing' | 'compressing' | 'optimizing' | 'complete';\r\n  progress: number;\r\n  message: string;\r\n  estimatedTimeRemaining?: number;\r\n}\r\n\r\n// Batch compression\r\nexport interface BatchCompressionOptions extends CompressionOptions {\r\n  maxConcurrentFiles?: number;\r\n  stopOnError?: boolean;\r\n  onFileComplete?: (result: CompressionResult) => void;\r\n  onFileError?: (error: CompressionError) => void;\r\n}\r\n\r\nexport interface BatchCompressionResult {\r\n  results: CompressionResult[];\r\n  errors: CompressionError[];\r\n  totalOriginalSize: number;\r\n  totalCompressedSize: number;\r\n  overallCompressionRatio: number;\r\n  processingTime: number;\r\n}\r\n\r\n// Validation and rules\r\nexport interface CompressionRule {\r\n  maxFileSize: number;\r\n  allowedFormats: string[];\r\n  minQuality?: number;\r\n  maxQuality?: number;\r\n  maxDimensions?: {\r\n    width: number;\r\n    height: number;\r\n  };\r\n}\r\n\r\nexport interface CompressionValidationResult {\r\n  isValid: boolean;\r\n  errors: CompressionValidationError[];\r\n  warnings: CompressionValidationWarning[];\r\n  recommendations: CompressionRecommendation[];\r\n}\r\n\r\nexport interface CompressionValidationError {\r\n  code: string;\r\n  message: string;\r\n  severity: 'error' | 'warning';\r\n}\r\n\r\nexport interface CompressionValidationWarning {\r\n  code: string;\r\n  message: string;\r\n  suggestion?: string;\r\n}\r\n\r\nexport interface CompressionRecommendation {\r\n  type: 'quality' | 'format' | 'dimension' | 'optimization';\r\n  message: string;\r\n  impact: 'high' | 'medium' | 'low';\r\n  estimatedSavings?: number;\r\n}\r\n\r\n// Error handling\r\nexport class CompressionError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public code: string,\r\n    public fileId?: string,\r\n    public originalError?: Error\r\n  ) {\r\n    super(message);\r\n    this.name = 'CompressionError';\r\n  }\r\n}\r\n\r\nexport class UnsupportedFormatError extends CompressionError {\r\n  constructor(format: string, supportedFormats: string[]) {\r\n    super(\r\n      `Unsupported format: ${format}. Supported formats: ${supportedFormats.join(', ')}`,\r\n      'UNSUPPORTED_FORMAT'\r\n    );\r\n  }\r\n}\r\n\r\nexport class CompressionQualityError extends CompressionError {\r\n  constructor(quality: number, minQuality: number, maxQuality: number) {\r\n    super(\r\n      `Invalid quality: ${quality}. Must be between ${minQuality} and ${maxQuality}`,\r\n      'INVALID_QUALITY'\r\n    );\r\n  }\r\n}\r\n\r\n// Configuration\r\nexport interface CompressionConfig {\r\n  defaultOptions: CompressionOptions;\r\n  supportedFormats: Record<string, CompressionFormatConfig>;\r\n  maxFileSize: number;\r\n  maxConcurrentCompressions: number;\r\n  enableWebWorkers: boolean;\r\n}\r\n\r\nexport interface CompressionFormatConfig {\r\n  extension: string;\r\n  mimeType: string;\r\n  qualityRange: {\r\n    min: number;\r\n    max: number;\r\n    default: number;\r\n  };\r\n  supportsProgressive: boolean;\r\n  supportsTransparency: boolean;\r\n  compressionAlgorithm: string;\r\n}\r\n\r\n// Events and callbacks\r\nexport interface CompressionEvent {\r\n  type: 'compression:started' | 'compression:progress' | 'compression:completed' | 'compression:failed';\r\n  fileId: string;\r\n  data?: unknown;\r\n}\r\n\r\nexport type CompressionCallback = (event: CompressionEvent) => void;\r\n\r\n// Worker types (για background processing)\r\nexport interface CompressionWorkerMessage {\r\n  id: string;\r\n  type: 'compress' | 'batch-compress' | 'cancel';\r\n  payload: {\r\n    file?: ArrayBuffer;\r\n    options?: CompressionOptions;\r\n    files?: ArrayBuffer[];\r\n    batchOptions?: BatchCompressionOptions;\r\n  };\r\n}\r\n\r\nexport interface CompressionWorkerResponse {\r\n  id: string;\r\n  type: 'success' | 'error' | 'progress';\r\n  payload: {\r\n    result?: CompressionResult;\r\n    error?: string;\r\n    progress?: CompressionProgress;\r\n  };\r\n}","import {\r\n  CompressionOptions,\r\n  CompressionResult,\r\n  CompressionFormat,\r\n  CompressionMetadata,\r\n  CompressionError,\r\n  UnsupportedFormatError,\r\n  CompressionQualityError\r\n} from '../types';\r\n\r\n// Supported formats configuration\r\nconst SUPPORTED_FORMATS: Record<string, {\r\n  mimeType: string;\r\n  quality: { min: number; max: number; default: number };\r\n  supportsTransparency: boolean;\r\n}> = {\r\n  jpeg: {\r\n    mimeType: 'image/jpeg',\r\n    quality: { min: 10, max: 100, default: 85 },\r\n    supportsTransparency: false\r\n  },\r\n  webp: {\r\n    mimeType: 'image/webp',\r\n    quality: { min: 10, max: 100, default: 80 },\r\n    supportsTransparency: true\r\n  },\r\n  avif: {\r\n    mimeType: 'image/avif',\r\n    quality: { min: 10, max: 100, default: 75 },\r\n    supportsTransparency: true\r\n  },\r\n  png: {\r\n    mimeType: 'image/png',\r\n    quality: { min: 10, max: 100, default: 100 },\r\n    supportsTransparency: true\r\n  }\r\n};\r\n\r\n/**\r\n * Enhanced compression engine βασισμένο σε Canvas API\r\n * Enhanced από OLD_geo-canvas patterns για image processing\r\n */\r\nexport class CompressionEngine {\r\n  private canvas: HTMLCanvasElement;\r\n  private ctx: CanvasRenderingContext2D;\r\n\r\n  constructor() {\r\n    this.canvas = document.createElement('canvas');\r\n    const context = this.canvas.getContext('2d');\r\n    if (!context) {\r\n      throw new CompressionError('Canvas 2D context not supported', 'CANVAS_NOT_SUPPORTED');\r\n    }\r\n    this.ctx = context;\r\n  }\r\n\r\n  /**\r\n   * Κύρια μέθοδος συμπίεσης αρχείου\r\n   */\r\n  async compressFile(\r\n    file: File,\r\n    options: CompressionOptions = {}\r\n  ): Promise<CompressionResult> {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      // Validate input\r\n      await this.validateFile(file, options);\r\n\r\n      // Load image\r\n      const img = await this.loadImage(file);\r\n\r\n      // Calculate dimensions\r\n      const dimensions = this.calculateDimensions(img, options);\r\n\r\n      // Setup canvas\r\n      this.setupCanvas(dimensions.width, dimensions.height);\r\n\r\n      // Draw and resize image\r\n      this.drawImage(img, dimensions);\r\n\r\n      // Apply optimizations\r\n      await this.applyOptimizations(options);\r\n\r\n      // Compress to target format\r\n      const compressedBlob = await this.compressToFormat(options);\r\n\r\n      // Generate metadata\r\n      const metadata = this.generateMetadata(\r\n        file,\r\n        options,\r\n        dimensions,\r\n        performance.now() - startTime\r\n      );\r\n\r\n      return {\r\n        originalFile: file,\r\n        compressedBlob,\r\n        originalSize: file.size,\r\n        compressedSize: compressedBlob.size,\r\n        compressionRatio: this.calculateCompressionRatio(file.size, compressedBlob.size),\r\n        format: options.format || this.detectBestFormat(file),\r\n        quality: options.quality || this.getDefaultQuality(options.format),\r\n        metadata\r\n      };\r\n\r\n    } catch (error) {\r\n      throw new CompressionError(\r\n        `Compression failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n        'COMPRESSION_FAILED',\r\n        undefined,\r\n        error instanceof Error ? error : undefined\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Batch compression για πολλαπλά αρχεία\r\n   */\r\n  async compressFiles(\r\n    files: File[],\r\n    options: CompressionOptions = {}\r\n  ): Promise<CompressionResult[]> {\r\n    const results: CompressionResult[] = [];\r\n\r\n    for (const file of files) {\r\n      try {\r\n        const result = await this.compressFile(file, options);\r\n        results.push(result);\r\n      } catch (error) {\r\n        console.warn(`Failed to compress file ${file.name}:`, error);\r\n        // Continue με άλλα files\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Validates file για compression\r\n   */\r\n  private async validateFile(file: File, options: CompressionOptions): Promise<void> {\r\n    // Check if it's an image\r\n    if (!file.type.startsWith('image/')) {\r\n      throw new UnsupportedFormatError(file.type, Object.keys(SUPPORTED_FORMATS));\r\n    }\r\n\r\n    // Validate quality\r\n    if (options.quality !== undefined) {\r\n      const format = options.format || this.detectBestFormat(file);\r\n      const formatConfig = SUPPORTED_FORMATS[format];\r\n\r\n      if (formatConfig && (\r\n        options.quality < formatConfig.quality.min ||\r\n        options.quality > formatConfig.quality.max\r\n      )) {\r\n        throw new CompressionQualityError(\r\n          options.quality,\r\n          formatConfig.quality.min,\r\n          formatConfig.quality.max\r\n        );\r\n      }\r\n    }\r\n\r\n    // Validate file size (100MB max)\r\n    if (file.size > 100 * 1024 * 1024) {\r\n      throw new CompressionError(\r\n        `File too large: ${Math.round(file.size / 1024 / 1024)}MB. Maximum: 100MB`,\r\n        'FILE_TOO_LARGE'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loads image από file\r\n   */\r\n  private loadImage(file: File): Promise<HTMLImageElement> {\r\n    return new Promise((resolve, reject) => {\r\n      const img = new Image();\r\n      const url = URL.createObjectURL(file);\r\n\r\n      img.onload = () => {\r\n        URL.revokeObjectURL(url);\r\n        resolve(img);\r\n      };\r\n\r\n      img.onerror = () => {\r\n        URL.revokeObjectURL(url);\r\n        reject(new CompressionError('Failed to load image', 'IMAGE_LOAD_FAILED'));\r\n      };\r\n\r\n      img.src = url;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Calculates optimal dimensions για resize\r\n   */\r\n  private calculateDimensions(\r\n    img: HTMLImageElement,\r\n    options: CompressionOptions\r\n  ): { width: number; height: number } {\r\n    let { width, height } = img;\r\n    const { maxWidth, maxHeight, maintainAspectRatio = true } = options;\r\n\r\n    if (!maxWidth && !maxHeight) {\r\n      return { width, height };\r\n    }\r\n\r\n    if (maintainAspectRatio) {\r\n      const aspectRatio = width / height;\r\n\r\n      if (maxWidth && width > maxWidth) {\r\n        width = maxWidth;\r\n        height = width / aspectRatio;\r\n      }\r\n\r\n      if (maxHeight && height > maxHeight) {\r\n        height = maxHeight;\r\n        width = height * aspectRatio;\r\n      }\r\n    } else {\r\n      if (maxWidth && width > maxWidth) {\r\n        width = maxWidth;\r\n      }\r\n      if (maxHeight && height > maxHeight) {\r\n        height = maxHeight;\r\n      }\r\n    }\r\n\r\n    return {\r\n      width: Math.round(width),\r\n      height: Math.round(height)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Sets up canvas με τις νέες διαστάσεις\r\n   */\r\n  private setupCanvas(width: number, height: number): void {\r\n    this.canvas.width = width;\r\n    this.canvas.height = height;\r\n\r\n    // Clear canvas\r\n    this.ctx.clearRect(0, 0, width, height);\r\n\r\n    // Set high quality rendering\r\n    this.ctx.imageSmoothingEnabled = true;\r\n    this.ctx.imageSmoothingQuality = 'high';\r\n  }\r\n\r\n  /**\r\n   * Draws image στο canvas με resizing\r\n   */\r\n  private drawImage(\r\n    img: HTMLImageElement,\r\n    dimensions: { width: number; height: number }\r\n  ): void {\r\n    this.ctx.drawImage(img, 0, 0, dimensions.width, dimensions.height);\r\n  }\r\n\r\n  /**\r\n   * Applies optimization techniques\r\n   */\r\n  private async applyOptimizations(options: CompressionOptions): Promise<void> {\r\n    // Apply sharpening για better quality στο resize\r\n    if (options.customSettings?.sharpen) {\r\n      this.applySharpeningFilter();\r\n    }\r\n\r\n    // Apply noise reduction\r\n    if (options.customSettings?.deNoise) {\r\n      this.applyNoiseReduction();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple sharpening filter\r\n   */\r\n  private applySharpeningFilter(): void {\r\n    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    const data = imageData.data;\r\n\r\n    // Simple unsharp mask implementation\r\n    const sharpenKernel = [\r\n      0, -1, 0,\r\n      -1, 5, -1,\r\n      0, -1, 0\r\n    ];\r\n\r\n    this.applyConvolutionFilter(data, this.canvas.width, this.canvas.height, sharpenKernel, 3);\r\n    this.ctx.putImageData(imageData, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Basic noise reduction\r\n   */\r\n  private applyNoiseReduction(): void {\r\n    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    const data = imageData.data;\r\n\r\n    // Gaussian blur για noise reduction\r\n    const blurKernel = [\r\n      1, 2, 1,\r\n      2, 4, 2,\r\n      1, 2, 1\r\n    ];\r\n\r\n    this.applyConvolutionFilter(data, this.canvas.width, this.canvas.height, blurKernel, 3, 16);\r\n    this.ctx.putImageData(imageData, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Generic convolution filter\r\n   */\r\n  private applyConvolutionFilter(\r\n    data: Uint8ClampedArray,\r\n    width: number,\r\n    height: number,\r\n    kernel: number[],\r\n    kernelSize: number,\r\n    divisor: number = 1\r\n  ): void {\r\n    const half = Math.floor(kernelSize / 2);\r\n    const newData = new Uint8ClampedArray(data);\r\n\r\n    for (let y = half; y < height - half; y++) {\r\n      for (let x = half; x < width - half; x++) {\r\n        let r = 0, g = 0, b = 0;\r\n\r\n        for (let ky = 0; ky < kernelSize; ky++) {\r\n          for (let kx = 0; kx < kernelSize; kx++) {\r\n            const py = y + ky - half;\r\n            const px = x + kx - half;\r\n            const pi = (py * width + px) * 4;\r\n            const ki = ky * kernelSize + kx;\r\n\r\n            r += (data[pi] ?? 0) * (kernel[ki] ?? 0);\r\n            g += (data[pi + 1] ?? 0) * (kernel[ki] ?? 0);\r\n            b += (data[pi + 2] ?? 0) * (kernel[ki] ?? 0);\r\n          }\r\n        }\r\n\r\n        const i = (y * width + x) * 4;\r\n        newData[i] = Math.max(0, Math.min(255, r / divisor));\r\n        newData[i + 1] = Math.max(0, Math.min(255, g / divisor));\r\n        newData[i + 2] = Math.max(0, Math.min(255, b / divisor));\r\n      }\r\n    }\r\n\r\n    data.set(newData);\r\n  }\r\n\r\n  /**\r\n   * Compresses canvas στο target format\r\n   */\r\n  private compressToFormat(options: CompressionOptions): Promise<Blob> {\r\n    return new Promise((resolve, reject) => {\r\n      const format = options.format || 'jpeg';\r\n      const quality = (options.quality || this.getDefaultQuality(format)) / 100;\r\n      const mimeType = SUPPORTED_FORMATS[format]?.mimeType || 'image/jpeg';\r\n\r\n      this.canvas.toBlob(\r\n        (blob) => {\r\n          if (blob) {\r\n            resolve(blob);\r\n          } else {\r\n            reject(new CompressionError('Failed to compress image', 'COMPRESSION_FAILED'));\r\n          }\r\n        },\r\n        mimeType,\r\n        quality\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generates compression metadata\r\n   */\r\n  private generateMetadata(\r\n    originalFile: File,\r\n    options: CompressionOptions,\r\n    dimensions: { width: number; height: number },\r\n    processingTime: number\r\n  ): CompressionMetadata {\r\n    return {\r\n      width: dimensions.width,\r\n      height: dimensions.height,\r\n      originalFormat: originalFile.type,\r\n      targetFormat: SUPPORTED_FORMATS[options.format || 'jpeg']?.mimeType || 'image/jpeg',\r\n      processingTime,\r\n      algorithm: 'canvas-2d'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Helper methods\r\n   */\r\n  private detectBestFormat(file: File): CompressionFormat {\r\n    if (file.type.includes('png') || file.name.toLowerCase().includes('transparent')) {\r\n      return 'webp'; // Supports transparency με better compression\r\n    }\r\n    return 'jpeg'; // Default για photos\r\n  }\r\n\r\n  private getDefaultQuality(format?: CompressionFormat): number {\r\n    return SUPPORTED_FORMATS[format || 'jpeg']?.quality.default || 85;\r\n  }\r\n\r\n  private calculateCompressionRatio(originalSize: number, compressedSize: number): number {\r\n    return Math.round(((originalSize - compressedSize) / originalSize) * 100 * 100) / 100;\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  destroy(): void {\r\n    // Cleanup canvas\r\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n  }\r\n}","import {\r\n  CompressionOptions,\r\n  CompressionValidationResult,\r\n  CompressionValidationError,\r\n  CompressionValidationWarning,\r\n  CompressionRecommendation,\r\n  CompressionFormat\r\n} from '../types';\r\n\r\nconst SUPPORTED_FORMATS = ['jpeg', 'webp', 'avif', 'png', 'original'] as const;\r\n\r\n/**\r\n * Validates compression options\r\n */\r\nexport function validateCompressionOptions(\r\n  options: CompressionOptions\r\n): CompressionValidationResult {\r\n  const errors: CompressionValidationError[] = [];\r\n  const warnings: CompressionValidationWarning[] = [];\r\n  const recommendations: CompressionRecommendation[] = [];\r\n\r\n  // Validate quality\r\n  if (options.quality !== undefined) {\r\n    if (options.quality < 1 || options.quality > 100) {\r\n      errors.push({\r\n        code: 'INVALID_QUALITY',\r\n        message: `Ποιότητα πρέπει να είναι μεταξύ 1-100. Τρέχουσα: ${options.quality}`,\r\n        severity: 'error'\r\n      });\r\n    } else if (options.quality < 50) {\r\n      warnings.push({\r\n        code: 'LOW_QUALITY',\r\n        message: 'Χαμηλή ποιότητα μπορεί να επηρεάσει την εμφάνιση της εικόνας',\r\n        suggestion: 'Σκεφτείτε να χρησιμοποιήσετε ποιότητα 60-85 για καλύτερα αποτελέσματα'\r\n      });\r\n    } else if (options.quality > 95) {\r\n      warnings.push({\r\n        code: 'HIGH_QUALITY',\r\n        message: 'Υψηλή ποιότητα μπορεί να δημιουργήσει μεγάλα αρχεία',\r\n        suggestion: 'Ποιότητα 80-90 συνήθως παρέχει καλή ισορροπία μεγέθους/ποιότητας'\r\n      });\r\n    }\r\n  }\r\n\r\n  // Validate format\r\n  if (options.format && !SUPPORTED_FORMATS.includes(options.format)) {\r\n    errors.push({\r\n      code: 'UNSUPPORTED_FORMAT',\r\n      message: `Μη υποστηριζόμενη μορφή: ${options.format}`,\r\n      severity: 'error'\r\n    });\r\n  }\r\n\r\n  // Validate dimensions\r\n  if (options.maxWidth !== undefined && options.maxWidth <= 0) {\r\n    errors.push({\r\n      code: 'INVALID_WIDTH',\r\n      message: 'Μέγιστο πλάτος πρέπει να είναι θετικός αριθμός',\r\n      severity: 'error'\r\n    });\r\n  }\r\n\r\n  if (options.maxHeight !== undefined && options.maxHeight <= 0) {\r\n    errors.push({\r\n      code: 'INVALID_HEIGHT',\r\n      message: 'Μέγιστο ύψος πρέπει να είναι θετικός αριθμός',\r\n      severity: 'error'\r\n    });\r\n  }\r\n\r\n  // Dimension recommendations\r\n  if (options.maxWidth && options.maxWidth > 4000) {\r\n    recommendations.push({\r\n      type: 'dimension',\r\n      message: 'Πολύ μεγάλο πλάτος - σκεφτείτε μείωση για καλύτερη απόδοση',\r\n      impact: 'medium',\r\n      estimatedSavings: 30\r\n    });\r\n  }\r\n\r\n  if (options.maxHeight && options.maxHeight > 4000) {\r\n    recommendations.push({\r\n      type: 'dimension',\r\n      message: 'Πολύ μεγάλο ύψος - σκεφτείτε μείωση για καλύτερη απόδοση',\r\n      impact: 'medium',\r\n      estimatedSavings: 30\r\n    });\r\n  }\r\n\r\n  // Format optimization recommendations\r\n  if (!options.format || options.format === 'jpeg') {\r\n    recommendations.push({\r\n      type: 'format',\r\n      message: 'WebP μπορεί να παρέχει 25-30% καλύτερη συμπίεση από JPEG',\r\n      impact: 'high',\r\n      estimatedSavings: 25\r\n    });\r\n  }\r\n\r\n  // Quality optimization recommendations\r\n  if (!options.quality) {\r\n    recommendations.push({\r\n      type: 'quality',\r\n      message: 'Ορίστε ποιότητα για καλύτερο έλεγχο του μεγέθους αρχείου',\r\n      impact: 'medium'\r\n    });\r\n  }\r\n\r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n    recommendations\r\n  };\r\n}\r\n\r\n/**\r\n * Recommends optimal compression options για ένα αρχείο\r\n */\r\nexport async function recommendOptimizations(file: File): Promise<CompressionOptions> {\r\n  const recommendations: CompressionOptions = {};\r\n\r\n  // Analyze file properties\r\n  const fileSize = file.size;\r\n  const fileName = file.name.toLowerCase();\r\n  const fileType = file.type;\r\n\r\n  try {\r\n    // Get image dimensions αν είναι δυνατόν\r\n    const dimensions = await getImageDimensions(file);\r\n\r\n    // Format recommendations\r\n    if (fileType.includes('png') && fileName.includes('photo')) {\r\n      recommendations.format = 'webp';\r\n      recommendations.quality = 85;\r\n    } else if (fileType.includes('jpeg')) {\r\n      recommendations.format = 'webp';\r\n      recommendations.quality = 80;\r\n    } else if (fileType.includes('png')) {\r\n      // Keep PNG για graphics/icons με transparency\r\n      recommendations.format = 'png';\r\n      recommendations.quality = 90;\r\n    } else {\r\n      recommendations.format = 'webp';\r\n      recommendations.quality = 80;\r\n    }\r\n\r\n    // Size-based recommendations\r\n    if (fileSize > 5 * 1024 * 1024) { // > 5MB\r\n      recommendations.quality = 70;\r\n      if (dimensions) {\r\n        recommendations.maxWidth = Math.min(dimensions.width, 2000);\r\n        recommendations.maxHeight = Math.min(dimensions.height, 2000);\r\n      }\r\n    } else if (fileSize > 2 * 1024 * 1024) { // > 2MB\r\n      recommendations.quality = 75;\r\n      if (dimensions) {\r\n        recommendations.maxWidth = Math.min(dimensions.width, 2500);\r\n        recommendations.maxHeight = Math.min(dimensions.height, 2500);\r\n      }\r\n    } else if (fileSize > 1 * 1024 * 1024) { // > 1MB\r\n      recommendations.quality = 80;\r\n    }\r\n\r\n    // Dimension-based recommendations\r\n    if (dimensions) {\r\n      if (dimensions.width > 3000 || dimensions.height > 3000) {\r\n        recommendations.maxWidth = 2500;\r\n        recommendations.maxHeight = 2500;\r\n        recommendations.maintainAspectRatio = true;\r\n      }\r\n    }\r\n\r\n    // Additional optimizations\r\n    recommendations.enableProgressive = true;\r\n    recommendations.stripMetadata = true;\r\n\r\n  } catch (error) {\r\n    console.warn('Failed to analyze image dimensions:', error);\r\n    // Fallback recommendations\r\n    recommendations.format = 'webp';\r\n    recommendations.quality = 80;\r\n    recommendations.stripMetadata = true;\r\n  }\r\n\r\n  return recommendations;\r\n}\r\n\r\n/**\r\n * Gets optimal format για συγκεκριμένο use case\r\n */\r\nexport function getOptimalFormat(useCase: 'web' | 'print' | 'archive' | 'thumbnail'): CompressionFormat {\r\n  switch (useCase) {\r\n    case 'web':\r\n      return 'webp';\r\n    case 'print':\r\n      return 'jpeg';\r\n    case 'archive':\r\n      return 'png';\r\n    case 'thumbnail':\r\n      return 'webp';\r\n    default:\r\n      return 'webp';\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates compression efficiency score\r\n */\r\nexport function calculateCompressionScore(\r\n  originalSize: number,\r\n  compressedSize: number,\r\n  targetQuality: number\r\n): number {\r\n  const compressionRatio = (originalSize - compressedSize) / originalSize;\r\n  const qualityPenalty = targetQuality < 70 ? (70 - targetQuality) / 100 : 0;\r\n\r\n  return Math.max(0, Math.min(100, (compressionRatio * 100) - (qualityPenalty * 20)));\r\n}\r\n\r\n/**\r\n * Helper function να πάρει dimensions από image file\r\n */\r\nfunction getImageDimensions(file: File): Promise<{ width: number; height: number }> {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    const url = URL.createObjectURL(file);\r\n\r\n    img.onload = () => {\r\n      URL.revokeObjectURL(url);\r\n      resolve({\r\n        width: img.naturalWidth,\r\n        height: img.naturalHeight\r\n      });\r\n    };\r\n\r\n    img.onerror = () => {\r\n      URL.revokeObjectURL(url);\r\n      reject(new Error('Failed to load image for dimension analysis'));\r\n    };\r\n\r\n    img.src = url;\r\n  });\r\n}\r\n\r\n/**\r\n * Validates batch compression options\r\n */\r\nexport function validateBatchOptions(\r\n  files: File[],\r\n  options: CompressionOptions\r\n): CompressionValidationResult {\r\n  const errors: CompressionValidationError[] = [];\r\n  const warnings: CompressionValidationWarning[] = [];\r\n  const recommendations: CompressionRecommendation[] = [];\r\n\r\n  // Check file count\r\n  if (files.length === 0) {\r\n    errors.push({\r\n      code: 'NO_FILES',\r\n      message: 'Δεν επιλέχθηκαν αρχεία για συμπίεση',\r\n      severity: 'error'\r\n    });\r\n  }\r\n\r\n  if (files.length > 50) {\r\n    warnings.push({\r\n      code: 'MANY_FILES',\r\n      message: 'Μεγάλος αριθμός αρχείων μπορεί να επηρεάσει την απόδοση',\r\n      suggestion: 'Σκεφτείτε να επεξεργαστείτε τα αρχεία σε μικρότερες ομάδες'\r\n    });\r\n  }\r\n\r\n  // Check total size\r\n  const totalSize = files.reduce((sum, file) => sum + file.size, 0);\r\n  if (totalSize > 500 * 1024 * 1024) { // > 500MB\r\n    warnings.push({\r\n      code: 'LARGE_BATCH',\r\n      message: 'Μεγάλο συνολικό μέγεθος αρχείων - η επεξεργασία μπορεί να πάρει αρκετό χρόνο',\r\n      suggestion: 'Επεξεργαστείτε τα αρχεία σε μικρότερες ομάδες για καλύτερη απόδοση'\r\n    });\r\n  }\r\n\r\n  // Validate individual options\r\n  const optionsValidation = validateCompressionOptions(options);\r\n  errors.push(...optionsValidation.errors);\r\n  warnings.push(...optionsValidation.warnings);\r\n  recommendations.push(...optionsValidation.recommendations);\r\n\r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n    recommendations\r\n  };\r\n}"],"mappings":"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","names":["SUPPORTED_FORMATS","progress","options"]}