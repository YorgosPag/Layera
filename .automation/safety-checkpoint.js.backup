#!/usr/bin/env node

/**
 * ðŸ›¡ï¸ LAYERA SAFETY CHECKPOINT SYSTEM
 * Î‘Ï…Ï„ÏŒÎ¼Î±Ï„Î¿ backup ÎºÎ±Î¹ commit system Ï€Î¿Ï… ÎµÎ¾Î±ÏƒÏ†Î±Î»Î¯Î¶ÎµÎ¹ ÏŒÏ„Î¹ Î· ÎµÏ†Î±ÏÎ¼Î¿Î³Î®
 * ÎµÎ¯Î½Î±Î¹ Ï€Î¬Î½Ï„Î± ÏƒÎµ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÎ® ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ git operations
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class LayeraSafetySystem {
  constructor() {
    this.projectRoot = 'C:\\layera';
    this.tokensPath = path.join(this.projectRoot, 'packages', 'tokens');
    this.distPath = path.join(this.tokensPath, 'dist', 'css', 'tokens.css');
    this.backupDir = path.join(this.projectRoot, '.automation', 'backups');
  }

  log(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString('el-GR');
    const prefix = {
      'info': 'ðŸ“',
      'success': 'âœ…',
      'warning': 'âš ï¸',
      'error': 'âŒ',
      'process': 'ðŸ”„'
    };
    console.log(`${prefix[type]} [${timestamp}] ${message}`);
  }

  execCommand(command, description) {
    this.log(`${description}...`, 'process');
    try {
      const result = execSync(command, {
        cwd: this.projectRoot,
        encoding: 'utf8',
        stdio: 'pipe'
      });
      this.log(`${description} - Î•Î Î™Î¤Î¥Î§Î©Î£`, 'success');
      return result;
    } catch (error) {
      this.log(`${description} - Î‘Î ÎŸÎ¤Î¥Î§Î™Î‘: ${error.message}`, 'error');
      throw error;
    }
  }

  createBackupDir() {
    if (!fs.existsSync(this.backupDir)) {
      fs.mkdirSync(this.backupDir, { recursive: true });
      this.log('Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®Î¸Î·ÎºÎµ Ï†Î¬ÎºÎµÎ»Î¿Ï‚ backup', 'success');
    }
  }

  backupCurrentState() {
    this.createBackupDir();
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(this.backupDir, `backup-${timestamp}`);

    this.log('Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± backup Ï„ÏÎ­Ï‡Î¿Ï…ÏƒÎ±Ï‚ ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚...', 'process');

    // Backup source files
    const srcBackup = path.join(backupPath, 'src');
    fs.mkdirSync(srcBackup, { recursive: true });
    this.execCommand(
      `robocopy "${path.join(this.tokensPath, 'src')}" "${srcBackup}" /E /R:0 /W:0`,
      'Backup source files'
    );

    // Backup dist files
    const distBackup = path.join(backupPath, 'dist');
    fs.mkdirSync(distBackup, { recursive: true });
    if (fs.existsSync(path.join(this.tokensPath, 'dist'))) {
      this.execCommand(
        `robocopy "${path.join(this.tokensPath, 'dist')}" "${distBackup}" /E /R:0 /W:0`,
        'Backup dist files'
      );
    }

    return backupPath;
  }

  buildTokens() {
    this.log('Rebuilding tokens...', 'process');
    this.execCommand(
      'pnpm --filter @layera/tokens build',
      'Build tokens'
    );

    // Verify build success
    if (fs.existsSync(this.distPath)) {
      const stats = fs.statSync(this.distPath);
      this.log(`Tokens built - Size: ${Math.round(stats.size / 1024)}KB`, 'success');

      // Verify minimum expected size (should be > 25KB for working state)
      if (stats.size < 25000) {
        throw new Error(`CSS file too small (${stats.size} bytes) - possibly broken build`);
      }
    } else {
      throw new Error('CSS file not found after build');
    }
  }

  commitWithDistFiles(message) {
    this.log('Staging changes...', 'process');

    // Add all changes
    this.execCommand('git add .', 'Stage all changes');

    // Commit source changes
    this.execCommand(
      `git commit -m "ðŸŽ¯ ${message} - SAFETY CHECKPOINT" --no-verify`,
      'Commit source changes'
    );

    // Add dist files (if they exist and are not gitignored)
    if (fs.existsSync(path.join(this.tokensPath, 'dist'))) {
      try {
        this.execCommand(
          'git add packages/tokens/dist/',
          'Stage dist files'
        );
        this.execCommand(
          `git commit -m "ðŸ“¦ Auto-generated dist files for: ${message}" --no-verify`,
          'Commit dist files'
        );
      } catch (error) {
        this.log('Dist files not committed (possibly gitignored)', 'warning');
      }
    }
  }

  verifyAppState() {
    this.log('Verifying application state...', 'process');

    // Check if CSS file exists and has reasonable size
    if (!fs.existsSync(this.distPath)) {
      throw new Error('CSS tokens file missing');
    }

    const stats = fs.statSync(this.distPath);
    if (stats.size < 25000) {
      throw new Error(`CSS tokens file too small: ${stats.size} bytes`);
    }

    // Check for critical layout variables
    const cssContent = fs.readFileSync(this.distPath, 'utf8');
    const criticalVars = [
      '--layera-global-shared-layoutSystem-header-height',
      '--layera-layoutSystem-appLayout-header-height',
      '--layera-header-fixed-height'
    ];

    for (const varName of criticalVars) {
      if (!cssContent.includes(varName)) {
        throw new Error(`Critical variable missing: ${varName}`);
      }
    }

    this.log('Application state verification - Î•Î Î™Î¤Î¥Î§Î©Î£', 'success');
  }

  run(commitMessage) {
    try {
      this.log('ðŸ›¡ï¸ Î•ÎšÎšÎ™ÎÎ—Î£Î— LAYERA SAFETY CHECKPOINT', 'info');
      this.log(`Commit Message: "${commitMessage}"`, 'info');

      // Step 1: Backup current state
      const backupPath = this.backupCurrentState();
      this.log(`Backup created: ${backupPath}`, 'success');

      // Step 2: Build tokens
      this.buildTokens();

      // Step 3: Verify application is working
      this.verifyAppState();

      // Step 4: Commit everything
      this.commitWithDistFiles(commitMessage);

      // Step 5: Final verification
      this.verifyAppState();

      this.log('ðŸŽ‰ SAFETY CHECKPOINT ÎŸÎ›ÎŸÎšÎ›Î—Î¡Î©Î˜Î—ÎšÎ• Î•Î Î™Î¤Î¥Î§Î©Î£!', 'success');
      this.log(`âœ… Î•Ï†Î±ÏÎ¼Î¿Î³Î® ÏƒÎµ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÎ® ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·`, 'success');
      this.log(`âœ… Î‘Î»Î»Î±Î³Î­Ï‚ committed Î¼Îµ Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î±`, 'success');
      this.log(`âœ… Backup Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿: ${backupPath}`, 'success');

    } catch (error) {
      this.log(`ðŸ’¥ Î£Î¦Î‘Î›ÎœÎ‘ Î£Î¤ÎŸÎ SAFETY CHECKPOINT: ${error.message}`, 'error');
      this.log('ðŸ”„ Î•Ï€Î±Î½Î±Ï†Î¿ÏÎ¬ ÏƒÎµ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î· ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Î±Ï€Î±Î¹Ï„ÎµÎ¯Ï„Î±Î¹', 'warning');
      process.exit(1);
    }
  }
}

// CLI Usage
if (require.main === module) {
  const commitMessage = process.argv[2] || 'Manual Safety Checkpoint';
  const safety = new LayeraSafetySystem();
  safety.run(commitMessage);
}

module.exports = LayeraSafetySystem;